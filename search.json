[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modern Scientific Computing with Julia",
    "section": "",
    "text": "Preface\nJulia is a modern programming language that was specifically developed for scientific computing. By combining a high-level syntax with just-in-time compilation, Julia achieves high efficiency both in terms of development time and code execution time. Its unique features facilitate the development of general, modular, extensible and thus reusable code. Julia encourages good software development practices as tools for documentation, tests, and version control are already built into the language and its ecosystem.\nJulia is a multi-paradigm programming language that lends itself both to functional and object-oriented programming patterns. Although Julia is not class-based like Python or C++, its main paradigm, multiple dispatch, and its dynamic type system provide a very powerful and extremely effective way of programming. Generally speaking, multiple dispatch tends to be more flexible and expressive than class-based object orientism and better suited for scientific software development.\nJulia‚Äôs type system is well suited for building abstraction layers which together with multiple dispatch facilitate and simplify\nThese are some of the topics covered in this book.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#status",
    "href": "index.html#status",
    "title": "Modern Scientific Computing with Julia",
    "section": "Status",
    "text": "Status\nChapters 1-3 are mostly finished and Chapter 4 is approximately 50% done (28.02.2024).",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About the Author\nMichael Kraus is a research group leader at the Max Planck Institute for Plasma Physics. His research focuses on the development of novel numerical algorithms that combine ideas from classical numerical analysis, scientific machine learning and reduced complexity modelling. He has over 20 years of experience in software development inside and outside of academia. Since 2015 Julia has been his preferred programming language for scientific software development. Michael is the main author of numerous Julia packages such as GeometricIntegrators.jl, GeometricMachineLearning.jl or ReducedComplexityModeling.jl. Since 2020 he creates and delivers training courses for scientific computing in Julia and research software engineering.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#what-kind-of-individual-would-be-interested-in-this-book",
    "href": "about.html#what-kind-of-individual-would-be-interested-in-this-book",
    "title": "About",
    "section": "What kind of individual would be interested in this book?",
    "text": "What kind of individual would be interested in this book?\nIf you are a scientist developing research software, this book is for you.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#what-knowledge-do-they-need-before-they-start-reading",
    "href": "about.html#what-knowledge-do-they-need-before-they-start-reading",
    "title": "About",
    "section": "What knowledge do they need before they start reading?",
    "text": "What knowledge do they need before they start reading?\nIf you have basic knowledge of the Julia programming language and are looking to gain expertise in scientific software development, this book is for you. Experienced programmers in some other language like Python or C++ should also be able to follow along after reviewing the introductory chapter on the Julia programming language. Some familiarity with parallel programming paradigms will be helpful in order to get the most out of the last chapters.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#why-should-they-buy-this-book",
    "href": "about.html#why-should-they-buy-this-book",
    "title": "About",
    "section": "Why should they buy this book?",
    "text": "Why should they buy this book?\nScientists already familiar with the basics of the Julia programming language will build a comprehensive toolkit for scientific software development with Julia. This book teaches essential and advanced concepts of Julia programming and important elements of the Julia ecosystem that simplify the software development process. It covers research software engineering techniques that lead to more robust, maintainable and extensible code and explains parallel programming with different paradigms such as threads, MPI and GPUs.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#what-is-the-product-approach-and-usp-of-the-book",
    "href": "about.html#what-is-the-product-approach-and-usp-of-the-book",
    "title": "About",
    "section": "What is the product approach and USP of the book?",
    "text": "What is the product approach and USP of the book?\nComplete with step-by-step explanations of important concepts and real-world example projects the reader will explore the Julia programming language and learn why it is uniquely suited for scientific software development. The reader will learn about important research software engineering practices and how Julia facilitates these practices.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#product-breakdown",
    "href": "about.html#product-breakdown",
    "title": "About",
    "section": "Product Breakdown",
    "text": "Product Breakdown\nThe reader will learn about Julia‚Äôs unique features, typical design patterns, developing software packages, following good research software engineering practices, explore useful libraries for common tasks, and develop parallel applications.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#by-the-end-of-this-book-you-will",
    "href": "about.html#by-the-end-of-this-book-you-will",
    "title": "About",
    "section": "By the end of this book you will‚Ä¶",
    "text": "By the end of this book you will‚Ä¶\nBy the end of the book, readers will be able to develop scientific software with Julia, think in a Julian way, and apply research software engineering techniques.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "content/julia-language.html",
    "href": "content/julia-language.html",
    "title": "1¬† Basics of the Julia Language",
    "section": "",
    "text": "1.1 Technical requirements\nIn order to run the examples in this and the following chapters, you need to install Julia from (https://julialang.org/downloads/). All code examples have been tested with Julia v1.10.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#development-environments",
    "href": "content/julia-language.html#development-environments",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.2 Development environments",
    "text": "1.2 Development environments\nAs with any other programming language, any text editor can be used to write and edit Julia code. There are plugins for code highlighting and extended language support for vi, Emacs, and most other common editors. At the time of writing, Visual Studio Code (https://code.visualstudio.com/) has become Julia‚Äôs de facto standard integrated development environment.\nCode can be executed on the command line by calling the Julia interpreter together with the name of a source file:\njulia myscript.jl\nAlternatively, code can be typed directly into the interactive REPL (read-eval-print loop) that is invoked by the julia command.\n\n\n\nJulia REPL\n\n\nThe screenshot in Figure 1.2 shows Julia‚Äôs startup prompt and a simple code snippet. We see that code outputs are immediately displayed in the REPL.\nJulia code can also be executed within Jupyter Notebooks or by literate programming tools such as Weave (https://github.com/JunoLab/Weave.jl). The Pluto package (https://plutojl.org/) provides a reactive notebook framework that elevates interactivity substantially beyond what is offered by Jupyter. It organizes code in cells like Jupyter, but all dependent code cells are automatically re-run on each variable change. Pluto guarantees that the state of the program is always described by the code you see in the notebook.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#julia-code",
    "href": "content/julia-language.html#julia-code",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.3 Julia code",
    "text": "1.3 Julia code\nThis section goes over some basics of writing Julia code. We start with the obvious: Variables are assigned with the = operator:\n\nx = 1.0\n\n1.0\n\n\nFunctions are called using the traditional parenthesis syntax:\n\ncos(0.0)\n\n1.0\n\n\nCode blocks are usually enclosed by some keyword like function, for, while or let and end. It is also possible to enclose code blocks with begin and end (cf.¬†the Section on Compound Expressions below), but all of the above constructs come without an explicit begin statement.\nThe command println writes the text representation of a variable to standard output, followed by a newline:\n\nprintln(1.0)\n\n1.0\n\n\n\nprintln(\"Hello World!\")\n\nHello World!\n\n\nJulia has full Unicode support:\n\nprintln(\"Greetings. „Åì„Çì„Å´„Å°„ÅØ„ÄÇ ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ. üëã\")\n\nGreetings. „Åì„Çì„Å´„Å°„ÅØ„ÄÇ ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ. üëã\n\n\nThis applies not only to strings but even to variable and function names and other identifiers:\n\nüê¢ = \"turtle\"\n\nprintln(üê¢)\n\nturtle\n\n\nSpecial symbols like Greek letters, decorations, and sub- or superscripts can be entered using LaTeX-like backslash notation with tab completion. This works in most environments, including the REPL, Visual Studio Code, and Jupyter Notebooks. For example,\nx\\hat&lt;tab&gt;\\_1&lt;tab&gt; = 2\\pi&lt;tab&gt;\nresults in\n\nxÃÇ‚ÇÅ = 2œÄ\n\n6.283185307179586\n\n\nJulia supports Unicode shortcuts for a large number of infix operators and elementary functions, e.g.,\n\n\n\n\n\n\nShort\nLong\nName\n\n\n\n\n‚â†\n!=\ninequality\n\n\n‚â§\n&lt;=\nless than or equal to\n\n\n‚â•\n&gt;=\ngreater than or equal to\n\n\n‚àà\nin\nelement of\n\n\n‚àâ\nnotin\nnot in\n\n\n√∑\ndiv\ntruncated division\n\n\n‚àö\nsqrt\nsquare root\n\n\n‚àõ\ncbrt\ncubic root\n\n\n‚äó\nkron\nKronecker product\n\n\n\n\n\nTable¬†1.1: Unicode shortcuts of some infix operators and elementary functions\n\n\n\nThis facilitates code that looks very similar to formulas on paper.\nComments are indicated by #. As seen here, everything following # is ignored:\n\nx = 2 # The first part of the line is executed, but not the comment after #\n\n2\n\n\nMultiline comments can be enclosed by #= and =#:\n\n#=\nThis is a comment.\n=#\n\nIn the next section, we will discuss more details about variables.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#variables",
    "href": "content/julia-language.html#variables",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.4 Variables",
    "text": "1.4 Variables\nWe already showed how to assign a value, say 10, to a variable, say x:\n\nx = 10\n\n10\n\n\nVariable names are case-sensitive and support Unicode. While they may contain letters (A-Z and a-z), digits 0-9, underscore _, exclamation mark !, and most Unicode symbols, they may only begin with a letter, underscore, and some specific Unicode symbols.\nJulia also allows declaring multiple variables at once:\n\nx, y = 7, 11\n\n(7, 11)\n\n\nWe can do math with x‚Äôs and y‚Äôs values and assign the result to the variable z:\n\nz = x + y\n\n18\n\n\nIn Julia, everything is an object, including primitive types like numbers and functions. Variables are just names referencing objects in memory. Thus if we reassign the result of the above addition to the variable x by x = x + y, what happens is that the result is stored in a newly allocated chunk of memory, which is then assigned to the variable x. The previous value of x is still present in memory, albeit without any variable referencing it.\n\nJulia uses garbage collection to free unreferenced memory chunks once it detects that no more references exist.\n\nAs Julia is dynamically typed, it is also possible to reassign a variable to a value of another type, e.g., a float,\n\nx = 1.0\n\n1.0\n\n\nHowever, it is strongly discouraged to change variable types, as it prevents Julia from generating efficient code. Special care is needed when working with numbers, in order to not accidentally change variable types e.g.¬†between integers and floats. This and many other topics regarding working with numbers in Julia are discussed in the next section.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#numbers",
    "href": "content/julia-language.html#numbers",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.5 Numbers",
    "text": "1.5 Numbers\nJulia provides a broader range of primitive numeric types than most languages. In addition to the standard integer and floating point types of various lengths, there are rational, complex, and arbitrary precision numbers. We will now discuss each of these number types in more detail as well as some language features that aid in writing concise code and ensuring type stability.\n\n1.5.1 Integers\nJulia has signed and unsigned integer types with 8 to 128-bit precision:\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nSigned?\nNumber of bits\nSmallest value\nLargest value\n\n\n\n\nInt8\n‚úì\n8\n-2^7\n2^7 - 1\n\n\nUInt8\n\n8\n0\n2^8 - 1\n\n\nInt16\n‚úì\n16\n-2^15\n2^15 - 1\n\n\nUInt16\n\n16\n0\n2^16 - 1\n\n\nInt32\n‚úì\n32\n-2^31\n2^31 - 1\n\n\nUInt32\n\n32\n0\n2^32 - 1\n\n\nInt64\n‚úì\n64\n-2^63\n2^63 - 1\n\n\nUInt64\n\n64\n0\n2^64 - 1\n\n\nInt128\n‚úì\n128\n-2^127\n2^127 - 1\n\n\nUInt128\n\n128\n0\n2^128 - 1\n\n\n\n\n\nTable¬†1.2: Integer types support by Julia\n\n\n\nThe default type for an integer depends on the target system‚Äôs architecture. On a 32-bit system, typeof(1) results in Int32, whereas on a 64-bit system typeof(1) results in Int64. The aliases Int and UInt refer to the system‚Äôs signed and unsigned native integer types, i.e., the command Int when executed on a 32-bit system returns Int32 and on a 64-bit system, it returns Int64. Integer literals that exceed the range of Int32 but lie within the range of Int64 always create 64-bit integers, even if the system type is 32 bits. Thus the following code creates an Int64 independent of whether it is executed on a 32-bit or 64-bit system:\n\ntypeof(3000000000)\n\nInt64\n\n\nThe typemin and typemax functions return the minimum and maximum representable values of primitive numeric types such as integers:\n\n(typemin(Int32), typemax(Int32))\n\n(-2147483648, 2147483647)\n\n\nThe values returned by typemin and typemax are always of the given argument type, e.g., Int32 in the example above. Exceeding the maximum representable value of a given type results in a wraparound behavior (type overflow) that reflects the characteristics of the underlying integer arithmetic as implemented on modern computers:\n\nx = typemax(Int64)\n\n9223372036854775807\n\n\n\nx + 1\n\n-9223372036854775808\n\n\n\nx + 1 == typemin(Int64)\n\ntrue\n\n\nThe standard division / will always return a float, even when dividing, e.g., 4 and 2:\n\n4 / 2\n\n2.0\n\n\nThe div function and the √∑ operator perform integer division:\n\n4 √∑ 2\n\n2\n\n\nInteger division by zero and dividing the lowest negative number (typemin) by -1 throws a DivideError. The remainder and modulus functions, rem and mod, throw a DivideError when their second argument is zero.\n\n\n1.5.2 Floats\nJulia has three built-in floating-point types:\n\n\n\n\n\n\nType\nPrecision\nNumber of bits\n\n\n\n\nFloat16\nhalf\n16\n\n\nFloat32\nsingle\n32\n\n\nFloat64\ndouble\n64\n\n\n\n\n\nTable¬†1.3: Floating-point types support by Julia\n\n\n\nFloating-point literals are denoted in the standard formats using . as a decimal separator and e and f in engineering notation:\n\n1.0\n\n1.0\n\n\n\n1.\n\n1.0\n\n\n\n.5\n\n0.5\n\n\n\n1e10\n\n1.0e10\n\n\n\n-2.5e-4\n\n-0.00025\n\n\nThese are all Float64 values; Float32 values are entered by writing an f in place of e:\n\n0.5f0\n\n0.5f0\n\n\n\n2.5f-4\n\n0.00025f0\n\n\n\nUnlike Int, there is no type alias Float for a specifically sized float depending on the machine architecture.\n\nUnlike integer registers, where the size of Int reflects the size of a native pointer on that machine, the floating point register sizes are specified by the IEEE-754 standard.\nFloating-point numbers have two zeros: positive zero and negative zero. These are equal when compared to each other, but they have different binary representations, which can be seen with the bitstring function\n\n0.0 == -0.0\n\ntrue\n\n\n\nbitstring(0.0)\n\n\"0000000000000000000000000000000000000000000000000000000000000000\"\n\n\n\nbitstring(-0.0)\n\n\"1000000000000000000000000000000000000000000000000000000000000000\"\n\n\nFor each floating point type, Julia provides three standard floating-point values for positive and negative infinity as well as not a number:\n\n\n\n\n\n\n\n\n\n\n\n\n\nFloat16\nFloat32\nFloat64\nName\nDescription\n\n\n\n\nInf16\nInf32\nInf\npositive infinity\na value larger than all finite floating-point values\n\n\n-Inf16\n-Inf32\n-Inf\nnegative infinity\na value smaller than all finite floating-point values\n\n\nNaN16\nNaN32\nNaN\nnot a number\na value that cannot be represented by any floating-point value\n\n\n\n\n\nTable¬†1.4: Special floating-point values representing positive and negative infinity as well as not a number\n\n\n\nThese floating-point values arise as the results of certain arithmetic operations, which is most easily seen in examples:\n\n1/0\n\nInf\n\n\n\n-5/0\n\n-Inf\n\n\n\n0.000001/0\n\nInf\n\n\n\n0/0\n\nNaN\n\n\n\n500 + Inf\n\nInf\n\n\n\n500 - Inf\n\n-Inf\n\n\n\nInf + Inf\n\nInf\n\n\n\nInf - Inf\n\nNaN\n\n\n\nInf * Inf\n\nInf\n\n\n\nInf / Inf\n\nNaN\n\n\n\n0 * Inf\n\nNaN\n\n\n\n1 / Inf\n\n0.0\n\n\nThe typemin and typemax functions also apply to floating-point types:\n\n(typemin(Float16),typemax(Float16))\n\n(-Inf16, Inf16)\n\n\n\n(typemin(Float32),typemax(Float32))\n\n(-Inf32, Inf32)\n\n\n\n(typemin(Float64),typemax(Float64))\n\n(-Inf, Inf)\n\n\nMost real numbers cannot be represented exactly with floating-point numbers. The distance between two adjacent representable floating point numbers is defined as the machine epsilon. The command eps gives the distance between 1.0 and the next larger representable floating point value:\n\neps(Float32) # 2.0^-23\n\n1.1920929f-7\n\n\n\neps(Float64) # 2.0^-52\n\n2.220446049250313e-16\n\n\n\neps() # same as eps(Float64)\n\n2.220446049250313e-16\n\n\neps can also take a floating-point value as an argument and gives the absolute difference between that value and the next representable floating-point value:\n\neps(1.0)\n\n2.220446049250313e-16\n\n\n\neps(1E3)\n\n1.1368683772161603e-13\n\n\n\neps(1E-27)\n\n1.793662034335766e-43\n\n\n\neps(0.0)\n\n5.0e-324\n\n\nWhile most programming languages support floating point numbers to various precision, native support for rational numbers is provided by only a few languages.\n\n\n1.5.3 Rational numbers\nJulia provides a native type for the representation of rational numbers, that is the ratio of two integers. They are constructed using the // operator:\n\n2//3\n\n2//3\n\n\nRational numbers are automatically reduced to their simplest form, i.e., the numerator and denominator are always divided by their highest common factor:\n\n6//9\n\n2//3\n\n\nThe denominator is always non-negative:\n\n5//-15\n\n-1//3\n\n\nThe numerator and denominator of a rational can be extracted with the corresponding functions:\n\nnumerator(2//3)\n\n2\n\n\n\ndenominator(2//3)\n\n3\n\n\nWith the float function, rationals can be converted to floating-point numbers:\n\nfloat(3//4)\n\n0.75\n\n\nIn addition to rational numbers, Julia also provides native support for complex numbers.\n\n\n1.5.4 Complex numbers\nJulia provides complex number types with support for all the standard mathematical operations. The complex number type is fully general and can represent a complex version of any other number, e.g., float, integer, or even rational, but as in most applications complex numbers are floats, Julia provides shortcuts for these types:\n\n\n\nType\nPrecision\nNumber of bits\n\n\n\n\nComplexF16\nhalf\n16\n\n\nComplexF32\nsingle\n32\n\n\nComplexF64\ndouble\n64\n\n\n\nThe imaginary part is denoted with the global constant im, representing the complex number i, which allows writing complex numbers in a very similar way to the mathematical notation (see below for details on the juxtaposition of numeric literals):\n\n1+2im\n\n1 + 2im\n\n\nComplex numbers can be built from all the other number types:\n\ntypeof(1//2 + 3//4im)\n\nComplex{Rational{Int64}}\n\n\nAll standard arithmetic operations and elementary functions can be applied to complex numbers:\n\n(1 + 2im) + (1 - 2im)\n\n2 + 0im\n\n\n\n(1 + 2im) * (2 - 3im)\n\n8 + 1im\n\n\n\nexp(1 + 2im)\n\n-1.1312043837568135 + 2.4717266720048188im\n\n\n\nsqrt(1 + 2im)\n\n1.272019649514069 + 0.7861513777574233im\n\n\nThe usual functions can be used to manipulate complex values:\n\nreal(1 + 2im)\n\n1\n\n\n\nimag(1 + 2im)\n\n2\n\n\n\nconj(1 + 2im)\n\n1 - 2im\n\n\n\nabs(1 + 2im)\n\n2.23606797749979\n\n\nMost computations can be carried out using integers, floats, rationals, or complex numbers. However, sometimes the precision offered by these standard types is not sufficient.\n\n\n1.5.5 Arbitrary precision\nJulia provides support for computations in arbitrary precision, in particular for numbers that go beyond the precision natively supported by hardware, usually 32 or 64 bits, by wrapping the GMP library (GNU Multiple Precision Arithmetic Library) and the GNU MPFR library (multiple-precision floating-point computations with correct rounding). The BigInt and BigFloat types hold arbitrary precision integer and floating point numbers. These types can be created from primitive numerical types\n\nBigInt(typemax(Int64)) + 1\n\n9223372036854775808\n\n\n\nBigFloat(2.0^66) / 3\n\n2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19\n\n\nor from strings using the big or parse functions\n\nbig\"123456789012345678901234567890\" + 1\n\n123456789012345678901234567891\n\n\n\nparse(BigInt, \"123456789012345678901234567890\") + 1\n\n123456789012345678901234567891\n\n\n\nbig\"1.23456789012345678901\"\n\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\n\n\nparse(BigFloat, \"1.23456789012345678901\")\n\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\n\nThe Julia ecosystem provides several packages implementing quadruple or higher precision floating point numbers. This includes ArbNumerics.jl, DecFP.jl, DoubleFloats.jl, MultiFloats.jl, and Quadmath.jl. Most of these packages outperform BigFloat from the Julia standard library for quadruple precision, often by one or two orders of magnitude. At the time of writing, DoubleFloats and MultiFloats appear to be the packages with the best overall performance and feature completeness.\n\n\n1.5.6 Literal coefficients\nNumeric literals represent primitive numbers in code, e.g., 1 for an integer literal and 1.0 for a floating-point literal. In Julia, variables can be preceded by a numeric literal, implying multiplication. This leads to clearer expressions and shorter numeric formulae that more closely resemble their counterparts on paper. For example, polynomials can be expressed in a very clean way:\n\nx = 3\ny = 9x^2 + 6x + 1\n\n100\n\n\nSimilarly, simple products in the exponential can be written without brackets:\n\n2^2x\n\n64\n\n\nThis works not only with variables but also with parenthesized expressions:\n\n6(x+1)^2 + 3(x+1) - 8\n\n100\n\n\nVice versa, parenthesized expressions can also be coefficients to variables:\n\n(x+1)x\n\n12\n\n\nWhile this is very convenient, there are a few pitfalls one needs to be aware of when using juxtaposition like this. Whitespaces are not allowed between numeric literals and variables or parenthesized expressions:\n\n(x+1) x\n\nERROR: ParseError:\n(x+1) x\n#    ‚îî‚îò ‚îÄ‚îÄ extra tokens after end of expression\nStacktrace:\n [1] top-level scope\n   @ none:1\nWhen immediately followed by a parenthetical, any expression other than a numeric literal is interpreted as a function, and the values in parentheses as its arguments. Thus, a parenthesized expression cannot immediately follow a variable:\n\nx(x+1)\n\nLoadError: MethodError: objects of type Int64 are not callable\nMaybe you forgot to use an operator such as *, ^, %, / etc. ?\n\n\nSimilarly, two parenthesized expressions cannot follow each other without explicitly specifying an operator:\n\n(x+1)(x-1)\n\nLoadError: MethodError: objects of type Int64 are not callable\nMaybe you forgot to use an operator such as *, ^, %, / etc. ?\n\n\nIt is important to be aware that juxtaposed literal coefficient syntax may conflict with another syntax, such as engineering notation for floating-point literals. Such ambiguities are always resolved in favor of interpretation as numeric literals, e.g., in a code snippet like\n\ne10 = 10\n2e10\n\n2.0e10\n\n\nThe expression starting with a numeric literal followed by e is always interpreted as a floating point literal, not as the numeric literal 2 multiplied by the variable e10.\n\n\n1.5.7 Zero & one\nTo avoid type conversions or even type instabilities, it is sometimes necessary to ensure that a given variable is initialized with the literal 0 or 1 of a given type, which is either specified explicitly or implicitly as the type of a given variable. The functions zero and one do precisely this: they return the literal 0 and 1 corresponding to the type in the argument or the type of the argument, e.g.\n\nzero(Float32)\n\n0.0f0\n\n\n\none(Int32)\n\n1\n\n\n\nzero(1.0)\n\n0.0\n\n\n\none(0)\n\n1\n\n\nAt first, the use of zero and one may seem a bit laborious. However, the great advantage is that it facilitates very generic code, that can operate on standard number types such as integers and floats, but also rationals and complex numbers, and even vectors or dual numbers as they are used in automatic differentiation packages such as ForwardDiff (https://github.com/JuliaDiff/ForwardDiff.jl).\nIn the next section, we discuss some of Julia‚Äôs data structures for collecting and organizing data.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#data-structures",
    "href": "content/julia-language.html#data-structures",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.6 Data structures",
    "text": "1.6 Data structures\nJulia provides several standard data structures, such as tuples, named tuples, dictionaries, and strings. In the following, we will briefly review those types and how to create and use them.\n\n1.6.1 Tuples\nA tuple is a fixed-length container that can hold multiple values of arbitrary type. Tuples are immutable, i.e., they cannot be modified once created. However, if they contain mutable values (like arrays), their content may still be modified (e.g., the elements of an array). Tuples are constructed by providing a list of values separated with commas and enclosed in parentheses:\n\nx = (0.0, \"hello\", 6*7)\n\n(0.0, \"hello\", 42)\n\n\nA tuple‚Äôs elements are accessed via square brackets:\n\nx[2]\n\n\"hello\"\n\n\nTuples can be unpacked into separate variables:\n\nx1, x2, x3 = x\n\n(0.0, \"hello\", 42)\n\n\n\nx2\n\n\"hello\"\n\n\nIf a tuple with only one element shall be created, it must be written with a comma,\n\n(1,)\n\n(1,)\n\n\nsince (1) would denote a parenthesized value\n\n(1)\n\n1\n\n\nThe expression () represents the empty (length-0) tuple:\n\n()\n\n()\n\n\nWhile tuples are just an ordered collection of variables, Julia also allows for assigning a name to each entry of the collection.\n\n\n1.6.2 Named tuples\nAs the name suggests, a NamedTuple is a tuple whose components are named\n\nx = (a = 42, b = 2^8, c = 2œÄ)\n\n(a = 42, b = 256, c = 6.283185307179586)\n\n\nFields of named tuples can be accessed by their name using the dot syntax\n\nx.a\n\n42\n\n\nSimilar to tuples, named tuples can be unpacked into separate variables\n\nx1, x2, x3 = x\n\n(a = 42, b = 256, c = 6.283185307179586)\n\n\n\nx1\n\n42\n\n\nThe package Parameters.jl allows for selectively unpacking named tuples by the @unpack macro\n\nusing Parameters\n@unpack a, b = x\n\n(a = 42, b = 256, c = 6.283185307179586)\n\n\n\na\n\n42\n\n\n\nc\n\nLoadError: UndefVarError: `c` not defined\n\n\nNamed tuples are immutable, i.e., values can neither be changed nor added or removed, and keys are always symbols. The types of all elements are stored as part of an instance of a named tuple:\n\ntypeof((a = 2, b = 3.))\n\n@NamedTuple{a::Int64, b::Float64}\n\n\nThis means that return types are always well-defined, which allows the Julia compiler to generate very efficient code around named tuples. However, this comes at a price as their immutability makes named tuples rather rigid. A more flexible (but often less performant) alternative is provided by dictionaries.\n\n\n1.6.3 Dictionaries\nDictionaries map between a collection of keys and a collection of values, where each key is associated with a single value. In Julia, both keys and values can be of any type. Dictionaries can be initialized with key-value pairs using the arrow =&gt; syntax:\n\nmydict = Dict(\"one\" =&gt; 1, 2 =&gt; 2., :three =&gt; 3+0im)\n\nDict{Any, Number} with 3 entries:\n  2      =&gt; 2.0\n  :three =&gt; 3+0im\n  \"one\"  =&gt; 1\n\n\n\nIn contrast to tuples and named tuples, dictionaries are not ordered, i.e., the values of a dictionary may appear in a different order as was used for initialization.\n\nIf the function Dict is called without arguments, it creates a new dictionary with no items, which can be added using index notation:\n\nmydict = Dict()\nmydict[\"one\"] = 1\n\n1\n\n\nElements of a dictionary can be accessed with the same index notation:\n\nmydict[\"one\"]\n\n1\n\n\nThe keys and values functions return collections of all keys and all values\n\nkeys(mydict)\n\nKeySet for a Dict{Any, Any} with 1 entry. Keys:\n  \"one\"\n\n\nWhen a dictionary is constructed, it stores the common supertype of the elements used to initialize the dictionary:\n\ntypeof(Dict(\"one\" =&gt; 1, \"two\" =&gt; 2, \"three\" =&gt; 3))\n\nDict{String, Int64}\n\n\n\ntypeof(Dict(\"one\" =&gt; 1, \"two\" =&gt; 2//3, \"three\" =&gt; 3.))\n\nDict{String, Real}\n\n\nThe first parameter of the Dict type is the common supertype of all keys, the second parameter is the common supertype of all values. In the first example, all values are integers, therefore the common value type is Int64. In the second example, the values are of different number types, which however share a common supertype Real, i.e., they are all real numbers.\nThis behavior restricts the type of elements that can be added to a dictionary. If we have a dictionary of real numbers and add another real number, there is no issue:\n\nmydict = Dict(\"one\" =&gt; 1, \"two\" =&gt; 2//3, \"three\" =&gt; 3.)\nmydict[\"four\"] = 4\nmydict\n\nDict{String, Real} with 4 entries:\n  \"two\"   =&gt; 2//3\n  \"four\"  =&gt; 4\n  \"one\"   =&gt; 1\n  \"three\" =&gt; 3.0\n\n\nHowever, if we try to add a string to the same dictionary, we find that this is not allowed:\n\nmydict[\"five\"] = \"five\"\n\nLoadError: MethodError: Cannot `convert` an object of type String to an object of type Real\n\nClosest candidates are:\n  convert(::Type{T}, ::T) where T&lt;:Number\n   @ Base number.jl:6\n  convert(::Type{T}, ::T) where T\n   @ Base Base.jl:84\n  convert(::Type{T}, ::AbstractChar) where T&lt;:Number\n   @ Base char.jl:185\n  ...\n\n\nSimilarly, in the example above all keys are strings. If we try to add a new entry with a different key type, Julia throws an exception:\n\nmydict[5] = 5\n\nLoadError: MethodError: Cannot `convert` an object of type Int64 to an object of type String\n\nClosest candidates are:\n  convert(::Type{String}, ::Base.JuliaSyntax.Kind)\n   @ Base /Users/julia/.julia/scratchspaces/a66863c6-20e8-4ff4-8a62-49f30b1f605e/agent-cache/default-honeycrisp-XG3Q6T6R70.0/build/default-honeycrisp-XG3Q6T6R70-0/julialang/julia-release-1-dot-10/base/JuliaSyntax/src/kinds.jl:975\n  convert(::Type{String}, ::String)\n   @ Base essentials.jl:321\n  convert(::Type{T}, ::T) where T&lt;:AbstractString\n   @ Base strings/basic.jl:231\n  ...\n\n\nWhen an empty dictionary is constructed, it allows for storing keys and entries of any type:\n\nDict()\n\nDict{Any, Any}()\n\n\nHowever, the types can be constrained by explicitly specifying them:\n\nDict{String,Float64}(\"one\" =&gt; 1, \"two\" =&gt; 2//3, \"three\" =&gt; 3.)\n\nDict{String, Float64} with 3 entries:\n  \"two\"   =&gt; 0.666667\n  \"one\"   =&gt; 1.0\n  \"three\" =&gt; 3.0\n\n\nIf the types do not match the specified values, Julia tries to convert them appropriately. If this is not possible, an exception will be raised.\nAs dictionaries can hold any type, they often do not have a predefined return type. This can lead to inefficient code when dictionaries are evaluated e.g.¬†within a loop. We will come back to this issue in Chapter 10 on Performance and Introspection.\nIn the next subsection, we will discuss another standard data type, namely strings.\n\n\n1.6.4 Strings\nIn Julia, strings are stored in the String type, which provides full Unicode support in the UTF-8 encoding. Strings are immutable, so a new string must be created to change a string. As in most other languages, strings are created by enclosing string literals with double quotes:\n\nstr = \"Hello, world.\"\n\n\"Hello, world.\"\n\n\nStrings can also be enclosed by triple double quotes:\n\n\"\"\"This string says \"Hello\" to the world.\"\"\"\n\n\"This string says \\\"Hello\\\" to the world.\"\n\n\nThis is convenient e.g.¬†when strings contain quotes as it avoids the need to escape them. Triple quotes are also the preferred way of enclosing multi-line strings:\n\n\"\"\"\nThis\nstring\nhas\nmany\nlines.\n\"\"\"\n\n\"This\\nstring\\nhas\\nmany\\nlines.\\n\"\n\n\nSingle characters or substrings can be extracted from a string using index syntax:\n\nstr[begin]\n\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n\n\n\nstr[5]\n\n'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n\n\n\nstr[8:12]\n\n\"world\"\n\n\nOther types can be converted to strings using string:\n\nstring(42)\n\n\"42\"\n\n\nConcatenation can be achieved by passing several arguments to string:\n\nstring(\"I am \", 10, \" years old.\")\n\n\"I am 10 years old.\"\n\n\nor by using the * operator:\n\n\"Hello\" * \", \" * \"world\"\n\n\"Hello, world\"\n\n\nJulia allows interpolation into string literals using $:\n\nage = 10\n\"I am $age years old.\"\n\n\"I am 10 years old.\"\n\n\n\n\"Next year, I will be $(age+1).\"\n\n\"Next year, I will be 11.\"\n\n\nInternally, Julia calls the string function to convert variables into string form when they are interpolated into other strings.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#functions",
    "href": "content/julia-language.html#functions",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.7 Functions",
    "text": "1.7 Functions\nIn Julia, a function starts with the function keyword, followed by the function name and a tuple of argument values, and ends with end. The following function accepts two arguments, x and y, and returns their sum x + y:\n\nfunction mysum(x,y)\n    x + y\nend\n\nmysum (generic function with 1 method)\n\n\nFunctions always return the value of the last expression evaluated. The return keyword is also available so that the above function can be equivalently written as\n\nfunction mysum(x,y)\n    return x + y\nend\n\nmysum (generic function with 1 method)\n\n\nHowever, in this example, the return keyword is unnecessary. It is rather used to break out of conditional branches with different return values. If a function does not need to return a value, it should return the value nothing:\n\nfunction printx(x)\n    println(\"x = $x\")\n    return nothing\nend\nprintx(2)\n\nx = 2\n\n\nJulia also supports a compact assignment form for defining a function\n\nmysum(x,y) = x + y\n\nmysum (generic function with 1 method)\n\n\nIn this form, the function must consist of a single expression. This is typical for functional programming, which is one of the paradigms embraced by Julia, and this short ‚Äúsingle-line‚Äù function syntax can be found in many Julia codes.\nFunction names can contain Unicode characters:\n\n‚àë(x,y) = x + y\n\n‚àë (generic function with 1 method)\n\n\nFunctions are called with the traditional parenthesis syntax:\n\nmysum(2,3)\n\n5\n\n\n\n‚àë(2,3)\n\n5\n\n\nIn Julia, values are passed to functions by sharing. Function arguments act as new variable bindings to the existing values, but the values themselves are not copied when passed to a function. Therefore, any modifications to mutable values by a function will also affect the caller.\nThe expression mysum, without parentheses, refers to the actual function object and can be manipulated like any other value. For example, it can be assigned to a different variable\n\nmyfunc = mysum\n\nmysum (generic function with 1 method)\n\n\n\nmyfunc(2,3)\n\n5\n\n\nBy default, functions return the last expression evaluated in the function body. The return keyword can be used to return immediately, providing an expression whose value is returned\n\nfunction myprod(x,y)\n    return x * y\n    x + y\nend\n\nmyprod(2,3)\n\n6\n\n\nSometimes it is useful or even necessary to specify a return type, e.g., to avoid type instabilities. To this end, the :: operator can be used in the function declaration:\n\nfunction myprod(x,y)::Float64\n    x * y\nend\n\nmyprod(2,3)\n\n6.0\n\n\nIf a function needs to return multiple values, one just returns a tuple of values. To create and destructure tuples, it is not necessary to write parentheses:\n\nfunction foo(a,b)\n    a+b, a*b\nend\n\nfoo(2,3)\n\n(5, 6)\n\n\nTuple destructuring or unpacking refers to extracting each value of the tuple into a separate variable:\n\nx, y = foo(2,3)\n\n(5, 6)\n\n\n\nx\n\n5\n\n\n\ny\n\n6\n\n\nWe will now discuss a special kind of function, namely operators.\n\n1.7.1 Operators\nJulia provides a large number of infix operators, which are functions with support for special syntax where the operator is placed between operands:\n\n1 + 2 + 3\n\n6\n\n\nThe same function can be called with the usual parenthesized list of arguments:\n\n+(1,2,3)\n\n6\n\n\nBoth forms, infix and function application, are equivalent. Internally, the former is parsed to call the latter. This implies that operators such as + and * are objects just like other functions and can be treated accordingly:\n\nplus = +\n\n+ (generic function with 189 methods)\n\n\n\nplus(1,2,3)\n\n6\n\n\nHowever, infix notation only works with the original operator name or symbol.\nAlthough not infix operators, we want to mention here several special expressions, that are mapped to specific function calls in a similar way to operators:\n\n\n\n\n\n\nExpression\nCall\n\n\n\n\nA'\nadjoint\n\n\nA[i]\ngetindex\n\n\nA[i] = x\nsetindex!\n\n\nA.n\ngetproperty\n\n\nA.n = x\nsetproperty!\n\n\n\n\n\nTable¬†1.5: Special expressions and their respective function calls\n\n\n\nA decisive feature of Julia is that for such expressions and operators (and there are many!), there is no distinction between those that come with the language and those that are defined by the user. Thus e.g.¬†indexing with the square bracket notation is available to all user types as long as proper getindex and setindex! methods are provided.\n\n\n1.7.2 Anonymous functions\nAnonymous functions are functions that are not given an explicit name. They are defined by prescribing a map from inputs to outputs with the -&gt; operator:\n\nx -&gt; 9x^2 + 6x + 1\n\n#11 (generic function with 1 method)\n\n\nHere, x is the function‚Äôs argument, and 9x^2 + 6x + 1 is the function body and thus the function‚Äôs return value. Anonymous functions are like normal functions but with a compiler-generated name. They can be assigned to variables which can then be called like any other function:\n\npoly = x -&gt; 9x^2 + 6x + 1\npoly(1)\n\n16\n\n\nAnonymous functions are primarily used for passing them to functions that take other functions as arguments. A common example of this is the map function. It applies a function to each value of an iterable like a tuple and returns a new tuple holding the resulting values:\n\nmap(x -&gt; 9x^2 + 6x + 1, (1, 2, 3))\n\n(16, 49, 100)\n\n\nIf the function should be applied to each value without returning a new tuple, the foreach function can be used:\n\nforeach(x -&gt; println(9x^2 + 6x + 1), (1, 2, 3))\n\n16\n49\n100\n\n\nTo define an anonymous function that accepts multiple arguments, tuple notation is used:\n\nmulti = (x,y,z) -&gt; 3x + y - 2z\nmulti(1,2,3)\n\n-1\n\n\nThe same notation can be used for an anonymous function without arguments:\n\nprinthi = () -&gt; println(\"Hi!\")\nprinthi()\n\nHi!\n\n\nIf an anonymous function requires multiple lines, the function body can be enclosed by begin and end, but cleaner code can be written with the do keyword:\n\nmap([-1, .5, 2]) do x\n    if x ‚â§ 0\n        return zero(x)\n    elseif x ‚â§ 1\n        return one(x)\n    else\n        return x\n    end\nend\n\n3-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n\n\nHere, the syntax do x creates an anonymous function with one argument x and passes it as the first argument to map. Similarly, do a, b creates a two-argument anonymous function, and a plain do declares an anonymous function that takes no arguments. If this behavior is desired for a custom function, this function requires a method that takes a function as the first argument:\n\nfunction printmap(f::Function, vals)\n    for x in vals\n        printx(f(x))\n    end\nend\n\nprintmap([-1, .5, 2]) do x\n    if x ‚â§ 0\n        return zero(x)\n    elseif x ‚â§ 1\n        return one(x)\n    else\n        return x\n    end\nend\n\nx = 0.0\nx = 1.0\nx = 2.0\n\n\nWhile this example may appear somewhat contrived, there are many useful applications of this paradigm, e.g., for opening a file, performing some user-specified code on the file, and ensuring that the file is closed afterward. This behavior is implemented in Julia‚Äôs own open command.\nIt has a version that runs code ensuring that the opened file is eventually closed:\nopen(\"outfile\", \"w\") do io\n    write(io, data)\nend\nThis is accomplished by the following definition:\n\nfunction open(f::Function, args...)\n    io = open(args...)\n    try\n        f(io)\n    finally\n        close(io)\n    end\nend\n\nopen (generic function with 1 method)\n\n\nHere, open opens the file for writing and then passes the resulting output stream to the anonymous function defined in the do ... end block. After the function exits, open ensures the stream is closed, regardless of whether the function exited normally or threw an exception.\n\n\n1.7.3 Varargs\nIt is often convenient to write functions that take an arbitrary number of arguments, so-called varargs functions. In Julia, varargs functions are defined by following the last argument with an ellipsis\n\nbar(a,b,x...) = (a,b,x)\n\nbar (generic function with 1 method)\n\n\nThe variables a and b are bound to the first two argument values as usual, while the variable x is bound to an iterable collection of the zero or more values passed to bar after its first two arguments:\n\nbar(1,2)\n\n(1, 2, ())\n\n\n\nbar(1,2,3)\n\n(1, 2, (3,))\n\n\n\nbar(1,2,3,4)\n\n(1, 2, (3, 4))\n\n\nIn all these cases, x is bound to a tuple of the trailing values passed to bar.\nThe values contained in an iterable collection can also be ‚Äúsplatted‚Äù into a function call as individual arguments, for which one also uses ... but in the function call:\n\nx = (2, 3, 4)\n\n(2, 3, 4)\n\n\n\nbar(1,2,x...)\n\n(1, 2, (2, 3, 4))\n\n\n\nbar(1,x...)\n\n(1, 2, (3, 4))\n\n\nThe iterable object splatted into a function call does not need to be a tuple, but it can be any iterable, e.g., a vector:\n\nx = [3, 4]\nbar(1, 2, x...)\n\n(1, 2, (3, 4))\n\n\nThe function that arguments are splatted into does not need to be a varargs function\n\nbaz(a, b) = a + b\nbaz(x...)\n\n7\n\n\nBut the size of the splatted object and the number of arguments a function takes need to match:\n\nbaz(rand(3)...)\n\nLoadError: MethodError: no method matching baz(::Float64, ::Float64, ::Float64)\n\nClosest candidates are:\n  baz(::Any, ::Any)\n   @ Main In[160]:1\n\n\nAfter discussing functions with an arbitrary number of arguments, we will move on to optional arguments.\n\n\n1.7.4 Optional arguments\nFunction arguments can have default values, which allows for omitting them in a function call:\n\nincrease(x, a=1) = x+a\n\nincrease (generic function with 2 methods)\n\n\nThis created a function with two methods. Thus optional arguments are just a convenient syntax for writing multiple method definitions with different numbers of arguments at once. The above definition allows for calling the function with either one or two arguments, and 1 is automatically passed when the second argument is not specified:\n\nincrease(4)\n\n5\n\n\n\nincrease(4, 2)\n\n6\n\n\nA particularly useful feature is that default values can refer to other arguments with evaluation from left to right\n\nincrease(x, a=x) = x+a\nincrease(4)\n\n8\n\n\nLastly, arguments can also be passed via keywords.\n\n\n1.7.5 Keyword arguments\nKeyword arguments are useful, for example, if a function takes many arguments, making it difficult to remember their order and how to call such functions. Identifying arguments by their name instead of their position makes it much easier to use complex interfaces.\nWhen defining a function, keyword arguments are separated from non-keyword arguments by a semicolon:\n\nfunction plot(x, y; color, linestyle=\"solid\", linewidth=1)\n    # ...\nend;\n\nThe function plot takes two positional arguments, x and y, and three keyword arguments, color, linestyle, and linewidth. As no default value is assigned to color, it is required to be specified by the user:\n\nplot(3, 5; color=:black)\n\n\nplot(3, 5)\n\nLoadError: UndefKeywordError: keyword argument `color` not assigned\n\n\nWhen the function plot is called, the semicolon is optional: one can call plot(3, 5, color=:black) or plot(3, 5; color=:black). An explicit semicolon is required only for passing varargs or computed keywords. Similar to varargs functions, extra keyword arguments can be collected using ...:\n\nfunction plot(x, y, z; kwargs...)\n    # ...\nend;\n\nNow that we have learned about the different ways of passing arguments to a function, we will discuss how to build new functions out of existing functions by composition.\n\n\n1.7.6 Composition\nJulia allows combining functions by composition with the ‚àò operator:\n\n(log ‚àò exp)(2)\n\n2.0\n\n\nis the same as\nlog(exp(2))\nand\n\n(sqrt ‚àò +)(3, 6)\n\n3.0\n\n\nis the same as\n\nsqrt(3 + 6)\n\n3.0\n\n\nThe inner function‚Äôs return values are the outer function‚Äôs arguments. In the REPL and suitably-configured editors, the composition operator can be typed using \\circ&lt;tab&gt;.\nComposition can also be expressed by function chaining, that is piping the output from one function to the input of the next function using the |&gt; operator:\n\n1:10 |&gt; sum |&gt; sqrt\n\n7.416198487095663\n\n\nThe result of applying sum to 1:10 is passed to the sqrt function. This is equivalent to the composition\n\n(sqrt ‚àò sum)(1:10)\n\n7.416198487095663\n\n\nAnother useful feature for extending the applicability of functions is the so-called dot syntax.\n\n\n1.7.7 Vectorization with the dot syntax\nIn Julia, functions can easily be vectorized using the dot syntax. This means that a function f(x) is applied to each element of a collection A (like a tuple or array) with the syntax f.(A). The result is stored in a new collection of the same type, here a tuple:\n\nX = (1.0, 2.0, 3.0)\nY = (4.0, 5.0, 6.0)\nsin.(œÄ .* X)\n\n(1.2246467991473532e-16, -2.4492935982947064e-16, 3.6739403974420594e-16)\n\n\nInternally f.(args...) is equivalent to broadcast(f, args...), which allows operating on multiple collections and even collections of different shapes or a mix of collections and scalars:\n\nfunc(x,y) = 3x + 4y\nfunc.(œÄ, X)\n\n(13.42477796076938, 17.42477796076938, 21.42477796076938)\n\n\n\nfunc.(X, Y)\n\n(19.0, 26.0, 33.0)\n\n\nNested f.(args...) calls are fused into a single broadcast loop:\n\nsin.(cos.(X))\n\n(0.5143952585235492, -0.4042391538522658, -0.8360218615377305)\n\n\nis equivalent to\n\nbroadcast(x -&gt; sin(cos(x)), X)\n\n(0.5143952585235492, -0.4042391538522658, -0.8360218615377305)\n\n\nThere is only a single loop over X, and a single tuple is allocated for the result. Adding dots to many operations or function calls in an expression can be tedious and lead to code that is difficult to read. Therefore, the macro @. is provided to convert every function call, operation, and assignment in an expression into the ‚Äúdotted‚Äù version:\n\n@. sin(cos(X))\n\n(0.5143952585235492, -0.4042391538522658, -0.8360218615377305)\n\n\nAfter discussing all important aspects of functions in Julia, we will briefly explore macros, which can be seen as a special kind of functions, that generate code.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#macros",
    "href": "content/julia-language.html#macros",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.8 Macros",
    "text": "1.8 Macros\nJulia features sophisticated runtime code generation and metaprogramming facilities. Many classical languages like C or C++ macros are parsed by a preprocessor, generating or manipulating code that is then interpreted and compiled by the actual compiler. In Julia, code is represented by Julia objects and can thus be generated and manipulated from within the language without an additional preprocessing step.\nIn the following, we will only explain how to apply macros and how that differs from regular functions, but we will not delve into how to define macros. We will explore Julia‚Äôs metaprogramming facilities in more detail in the section on Domain Specific Languages in Chapter 5.\nMacros are invoked with the syntax @name expr1 expr2 ... or @name(expr1, expr2, ...), e.g.,\n\n@assert 1 == one(0)\n\nMacros act differently from functions. A function takes a number of arguments, performs some operations on them, and returns a result (or nothing). A macro can also take several arguments but returns an expression: Julia‚Äôs representation of executable code. This expression is then automatically compiled and executed. Macros execute code at a different level than functions, namely when code is parsed, thus allowing to modify, generate and insert code before the actual code (the expression returned by the macro) is executed.\nJulia features many useful macros, e.g., for testing or code introspection. These will be explained in detail later, in Chapter 6 and 10. Now we move on to the different language elements Julia provides to control the flow of a program.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#control-flow",
    "href": "content/julia-language.html#control-flow",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.9 Control flow",
    "text": "1.9 Control flow\nJulia provides most of the control flow mechanisms typical for high-level programming languages: conditional evaluation with if, elseif and else, repeated evaluation with for and while, and exception handling with try and catch, error and throw. Julia does not feature a switch-case like control structure. However, several packages such as MLStyle (https://github.com/thautwarm/MLStyle.jl) provide such structures.\nWe will start this section with a short overview of compound expressions, that group several subexpressions into a single expression. Then we explain conditionals and related topics such as the ternary operator and short circuit notation before we move on to loops and finally exceptions.\n\n1.9.1 Compound expressions\nJulia provides multiple ways to generate compound expressions, that is groups of subexpressions that behave like a single expression: begin blocks and ; chains. In both cases, the value that is returned by the compound expressions is the value of the last subexpression:\n\nz = begin\n    x = 1\n    y = 2\n    x + y\nend\n\n3\n\n\n\nz = (x = 1; y = 2; x + y)\n\n3\n\n\nWhile begin blocks are typically multiline and ; chains are typically single-line, there is no strict need for this:\n\nbegin x = 1; y = 2; x + y end\n\n3\n\n\n\n(x = 1;\n y = 2;\n x + y)\n\n3\n\n\nAfter compound expressions, we will now move on to conditional expressions.\n\n\n1.9.2 Conditionals\nConditionals or if-clauses allow branching code into parts that are evaluated and parts that are not evaluated, depending on whether some boolean expression evaluates to true or false.\nA typical if-elseif-else conditional has the following form:\n\nif c == :yellow\n    println(\"You like yellow. Really?\")\nelseif c == :blue\n    println(\"You like blue. Me too.\")\nelseif c == :red || c == :green\n    println(\"You like red or green. I can't tell the difference.\")\nelse\n    println(\"You seem to like some odd color.\")\nend\n\nJulia evaluates the conditional expressions in order until one evaluates to true. Then the corresponding code block is evaluated, and no further conditional expressions are evaluated. A conditional can have arbitrarily many elseif blocks but only one else block, which must be the last. The elseif and else blocks are optional. Conditional expressions can be connected using || (or) and && (and).\nUnlike many other languages, in Julia, conditional expressions have to evaluate to either true or false, elsewise an error is thrown, indicating that the conditional returns the wrong type:\n\nif 1\n    println(\"true\")\nend\n\nLoadError: TypeError: non-boolean (Int64) used in boolean context\n\n\nConditional blocks do not introduce a local scope (more on variable scopes below). This means that variables that are newly defined within a block can be used after the conditional expression:\n\nfunction mycolor(c)\n    if c == :yellow\n        comment = \"You like yellow. Really?\"\n    elseif c == :blue\n        comment = \"You like blue. Me too.\"\n    elseif c == :red || c == :green\n        comment = \"You like red or green. I can't tell the difference.\"\n    else\n        comment = \"You seem to like some odd color.\"\n    end\n    println(comment)\nend;\n\nmycolor(:pink)\n\nYou seem to like some odd color.\n\n\nIf a variable defined within a block is used later on, all branches must define a value for that variable.\n\n\n1.9.3 Ternary operator\nJulia provides a very concise syntax for single-expression if-else statements, the so-called ternary operator ?:, which takes three operands:\n\na ? b : c\n\nThe expression a is a conditional expression, the expression b is evaluated if a is true, and the expression c is evaluated if a is false.\n\ntestnegative(x) = println(x &lt; 0 ? \"x is negative\" : \"x is non-negative\")\ntestnegative(-1)\n\nx is negative\n\n\nConditionals with three or more branches can be constructed by chaining multiple uses of the ternary operator. However, this quickly results in hard-to-read code and should thus be avoided.\nA typical use of the ternary operator is to discriminate return values:\n\nmymin(x, y) = x &lt; y ? x : y\n\nmymin (generic function with 1 method)\n\n\n\n\n1.9.4 Short circuit\nWhen chaining boolean expressions with || and &&, Julia evaluates only the minimum number of expressions necessary to determine the final value of the entire chain. In the expression a && b, the subexpression b is only evaluated if a evaluates to true. If a is false, necessarily the whole expression is false and there is no need to evaluate b. In the expression a || b, the subexpression b is only evaluated if a evaluates to false. If a is true, necessarily the whole expression is true and again there is no need to evaluate b.\n\ntrue && true\n\ntrue\n\n\n\ntrue && false\n\nfalse\n\n\n\nfalse && true\n\nfalse\n\n\n\nfalse && false\n\nfalse\n\n\n\ntrue || true\n\ntrue\n\n\n\ntrue || false\n\ntrue\n\n\n\nfalse || true\n\ntrue\n\n\n\nfalse || false\n\nfalse\n\n\nThis behavior can be used to write one-line if statements in a very comprehensive way. The following code\n&lt;condition&gt; && &lt;statement&gt;\nis equivalent to\nif &lt;condition&gt;\n    &lt;statement&gt;\nend\nand\n&lt;condition&gt; || &lt;statement&gt;\nis equivalent to\nif ! &lt;condition&gt;\n    &lt;statement&gt;\nend\nWhile the condition expressions used in the operands of && or || must be boolean values (true or false), any type of expression can be used at the end of a conditional chain.\n\n\n1.9.5 Loops\nJulia knows two kinds of loops: for loops and while loops. In while loops, some expression (the loop body) is repeatedly evaluated as long as some conditional expression is true. On the other hand, for loops operate on an iterable container like a tuple or an array. In each loop cycle, they assign a value of the iterable to a loop variable and evaluate the loop body, which typically depends on the loop variable.\n\nFor\nThe general form of a Julia for loop is as follows:\n\nfor &lt;loop variable&gt; = &lt;iterable&gt;\n    # ...\n    # loop body\n    # ...\nend\n\nThe iterable can be some range like 1:3, representing the sequence of numbers 1, 2, 3:\n\nfor i = 1:3\n    println(i)\nend\n\n1\n2\n3\n\n\nInstead of the keyword =, one can also use in or ‚àà, which often leads to clearer code. The iterable can also be any iterable container, such as a tuple or an array:\n\nfor x ‚àà (1.0, ‚ÑØ, œÄ)\n    println(x)\nend\n\n1.0\n‚ÑØ\nœÄ\n\n\n\nfor s in (\"foo\", \"bar\")\n    println(s)\nend\n\nfoo\nbar\n\n\nThe break keyword can be used to stop the iteration before a for loop cycled through all elements of an iterable:\n\nfor j in 1:1000\n    println(j)\n    if j &gt;= 2\n        break\n    end\nend\n\n1\n2\n\n\nThe continue keyword allows for stopping an iteration but continuing the loop, i.e., jumping to the next iteration:\n\nfor i in 1:10\n    if i % 4 != 0\n        continue\n    end\n    println(i)\nend\n\n4\n8\n\n\nNested loops can be combined into a single loop over the cartesian product of all iterables:\n\nfor i in 1:2, j in 3:4\n    println((i, j))\nend\n\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n\n\nThere is one difference to nested loops, though: in nested loops, a break statement only exits the innermost loop in which it is called. Here, it exits the entire nest of loops.\nEven when combining nested loops, iterables may refer to outer loop variables:\n\nfor i in 1:2, j in 1:i\n    println((i, j))\nend\n\n(1, 1)\n(2, 1)\n(2, 2)\n\n\nThe pairs function provides a convenient way to loop over key/value pairs of a NamedTuple or Dict:\n\nnt = (a = 23, b = 42)\n\nfor (k,v) in pairs(nt)\n    println(\"$k =&gt; $v\")\nend\n\na =&gt; 23\nb =&gt; 42\n\n\nSimilarly, if one wants to loop over value pairs of two separate iterables (in contrast to the Cartesian product of their values), one can use the zip function:\n\nfor (k,v) in zip(keys(nt), values(nt))\n    println(\"$k =&gt; $v\")\nend\n\na =&gt; 23\nb =&gt; 42\n\n\nThe second kind of loop Julia knows is the while loop.\n\n\nWhile\nIn Julia, while loops have the form:\n\nwhile &lt;condition&gt;\n    # ...\n    # loop body\n    # ...\nend\n\nThe &lt;condition&gt; is some expression that evaluates to either true or false. As long as it is true, the loop body is executed. If &lt;condition&gt; is false when the while loop is executed the first time, the loop body is never executed:\n\ni = 0\nwhile i &gt; 0\n    println(i)\n    i += 1\nend\n\nUnlike for loops, while loops do not define loop variables, i.e., all variables on which the &lt;condition&gt; depends must be defined before the while loop.\n\n\n\n1.9.6 Exceptions\nExceptions occur when a program encounters an unexpected condition that prevents it from continuing execution, e.g., a function argument may have a type or value on which a specific operation cannot be executed:\n\nfunction sqrt_inv(x)\n    println(\"We will now compute the square root of the inverse of $x.\")\n    result = sqrt(1 √∑ x)\n    println(\"The square root of the inverse of $x is $result.\")\n    return result\nend\n\nsqrt_inv(0)\n\nWe will now compute the square root of the inverse of 0.\nLoadError: DivideError: integer division error\n\n\nJulia supports different types of exceptions that allow for discriminating the reason for a program interruption and usually contain a diagnostic error message that helps to track down the problem.\n\nArgumentError\nBoundsError\nCompositeException\nDimensionMismatch\nDivideError\nDomainError\nEOFError\nErrorException\nInexactError\nInitError\nInterruptException\nInvalidStateException\nKeyError\nLoadError\nOutOfMemoryError\nReadOnlyMemoryError\nRemoteException\nMethodError\nOverflowError\nMeta.ParseError\nSystemError\nTypeError\nUndefRefError\nUndefVarError\nStringIndexError\n\nIf, for example, the sqrt function is applied to a negative real value, it does not just throw a generic ErrorException, but instead, it throws a DomainError:\n\nsqrt(-1)\n\nLoadError: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n\n\nJulia‚Äôs error messages are typically quite explanatory and often provide a possible solution to the problem at hand. It is also possible to define custom exception types:\n\nstruct GridError &lt;: Exception end\n\nExceptions interrupt the normal control flow and terminate a program unless it features specific code to handle such exceptional conditions.\n\nException handling\nThe try and catch statements allow for testing if a code section throws an exception and handling the exception if necessary to not crash the code:\n\ntry\n    # ...\n    # Code that is expected to sometimes throw an exception\n    # ...\ncatch\n    # ...\n    # Code to handle exceptions\n    # ...\nend\n\nExceptions can be handled in different ways, e.g., by logging them, printing out an error statement, or returning a placeholder value. In the following example, the sqrt function throws an exception. Placing a try/catch block around it allows for mitigating this issue:\n\ntry\n    sqrt(-1)\ncatch\n    println(\"You cannot compute the square root of just anything!\")\nend\n\nYou cannot compute the square root of just anything!\n\n\nThe exception can also be assigned to some variable, e.g., to implement different behavior depending on the type of the Exception:\n\nsqrt_inv(x) = try\n    sqrt(1 √∑ x)\ncatch e\n    if isa(e, DivideError)\n        println(\"DivideError: dividing by zero is usually not a good idea.\")\n    elseif isa(e, DomainError)\n        println(\"DomainError: you could try sqrt(complex(1 √∑ x, 0)) instead.\")\n    end\nend\n\nsqrt_inv(1)\n\n1.0\n\n\n\nsqrt_inv(0)\n\nDivideError: dividing by zero is usually not a good idea.\n\n\n\nsqrt_inv(-1)\n\nDomainError: you could try sqrt(complex(1 √∑ x, 0)) instead.\n\n\nThe try/catch syntax has the disadvantage of being much slower than conditional branching. This is not a problem, e.g., when opening a file and checking for an error. However, it can quickly become a bottleneck in numerical computations, e.g., when a function that is called many times from within a loop features a try/catch clause. If it is clear from the outset, when certain exceptions occur, these can also be handled with a simple if-elseif-else clause:\n\nfunction sqrt_inv(x)\n    if x == 0\n        println(\"Dividing by zero is usually not a good idea.\")\n    elseif x &lt; 0\n        println(\"x is outside the domain. You could try sqrt(complex(1 √∑ x, 0)) instead.\")\n    else\n        return sqrt(1 √∑ x)\n    end\n    return NaN\nend\n\nsqrt_inv(0)\n\nDividing by zero is usually not a good idea.\nNaN\n\n\nSince Julia v1.8, it is also possible to run a code block only in the event that no exception is thrown in the try block. This can be done with an else clause:\n\ntry\n    # ...\n    # Code that is expected sometimes to throw an exception\n    # ...\ncatch\n    # ...\n    # Code to handle exceptions\n    # ...\nelse\n    # ...\n    # Code that is run if no exception occurs\n    # ...\nend\n\nIt is often necessary to run some code regardless of an exception being thrown or not, e.g., for closing a file. For this task, Julia provides the finally keyword:\n\ntry\n    # ...\n    # Code that is expected sometimes to throw an exception\n    # ...\nfinally\n    # ...\n    # Code that is executed after try or try/catch block\n    # ...\nend\n\nWhen only a try block is present, the finally block is executed whenever the try block is left, e.g., due to an exception, a return statement, or just after finishing normally. When finally follows a try/catch block, it either runs after the try block is exited normally or, if an exception occurs, after the catch block handles the exception.\n\n\nThrow and rethrow\nAn exception can be triggered with the throw keyword. In our sqrt_inv example, we could throw a DivideError if the argument is zero:\n\nfunction sqrt_inv(x)\n    x == 0 && throw(DivideError())\n    println(\"Computing the square root of the inverse of $x.\")\n    sqrt(1 √∑ x)\nend\n\nsqrt_inv(0)\n\nLoadError: DivideError: integer division error\n\n\nThis example is somewhat contrived as the div function would also throw a DivideError exception.\nNote that DivideError without parentheses is not an exception but a type of exception that needs to be called to obtain an actual Exception object:\n\ntypeof(DivideError()) &lt;: Exception\n\ntrue\n\n\n\ntypeof(DivideError) &lt;: Exception\n\nfalse\n\n\n\ntypeof(DivideError)\n\nDataType\n\n\nMost exception types take one or more arguments that are used for error reporting by providing additional information on where and why an error occurred. In our sqrt_inv example, we could throw a TypeError if the argument is not a Number:\n\nfunction sqrt_inv(x)\n    typeof(x) &lt;: Number || throw(TypeError(:sqrt_inv, \"\", Number, x))\n    sqrt(1 √∑ x)\nend\n\nsqrt_inv(\"10\")\n\nLoadError: TypeError: in sqrt_inv, expected Number, got a value of type String\n\n\nThe rethrow keyword can be used to continue propagating an exception from within a catch block, such as if it had not been caught:\n\nsqrt_inv(x) = try\n    sqrt(1 √∑ x)\ncatch e\n    if isa(e, DivideError)\n        println(\"DivideError: dividing by zero is usually not a good idea.\")\n        return NaN\n    else\n        rethrow()\n    end\nend\n\nsqrt_inv(1)\n\n1.0\n\n\n\nsqrt_inv(0)\n\nDivideError: dividing by zero is usually not a good idea.\nNaN\n\n\n\nsqrt_inv(-1)\n\nLoadError: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n\n\nJulia provides a shortcut for raising a generic ErrorException by the error function, which takes an error message as an argument:\n\nsqrt_inv(x) = x == 0 ? error(\"You shall not invert zeros!\") : sqrt(1 √∑ x)\nsqrt_inv(0)\n\nLoadError: You shall not invert zeros!\n\n\nThe error function interrupts the normal control flow and stops the execution of the code unless some try/catch block catches the ErrorException.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#packages",
    "href": "content/julia-language.html#packages",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.10 Packages",
    "text": "1.10 Packages\nJulia has a large ecosystem of packages for almost all aspects of scientific computing and beyond. It has a built-in package manager that makes it very easy to install, update and remove packages, keep track of package dependencies, and resolve them. This is one of the major advantages of Julia over legacy languages such as C, C++, or Fortran: using external packages is painless. There is no need to build complicated make chains, resolve linking issues, or anything the like. More details on that can be found in Chapter 6 on Package Development.\n\n1.10.1 Installing packages\nJulia‚Äôs package Manager, Pkg, comes with its own REPL. It is accessed by pressing ] on the Julia REPL. To return to the Julia REPL, press backspace or ^C. Upon entering the Pkg REPL, the prompt should look like this:\n(@v1.9) pkg&gt;\nThe Pkg REPL features interactive help, which is accessed by ?:\n(@v1.9) pkg&gt; ?\nIt displays a list of the available commands along with short descriptions. Preceding a specific command with ? provides more information on that command:\n(@v1.9) pkg&gt; ?develop\nPackages can be installed using the add command:\n(@v1.9) pkg&gt; add Plots\nIt is possible to specify multiple packages at once:\n(@v1.9) pkg&gt; add StaticArrays OffsetArrays\nPackages can also be installed by specifying their repository‚Äôs URL:\n(@v1.9) pkg&gt; add https://github.com/JuliaPlots/Plots.jl\nThis is useful for unregistered packages not listed in Julia‚Äôs package registry. Local packages can be installed by specifying their path:\n(@v1.9) pkg&gt; add ../MyPackage\nA specific version of a package can be installed by appending the version number after the @ symbol:\n(@v1.9) pkg&gt; add Plots@1.35\nSimilarly, a specific branch of a package can be installed by appending the branch name after the # symbol:\n(@v1.9) pkg&gt; add ../MyPackage#my-dev-branch\nA specific commit can be installed by replacing the branch name with the commit hash. The command free is used to go back to the default version of the package:\n(@v1.9) pkg&gt; free MyPackage\nIf a package is added with the add command, even a local package or a development branch, Julia will install the last version committed with git. If, instead, the current version on the file system, possibly containing uncommitted changes, should be used, the package has to be added with the dev command:\n(@v1.9) pkg&gt; dev ../MyPackage\nPackages are removed with the rm command, which, like add, allows for specifying one or more packages at once:\n(@v1.9) pkg&gt; rm StaticArrays OffsetArrays\nThe status command (or short st) lists all packages that were manually added, i.e., it does not show dependencies that were installed automatically by the package manager,\n(@v1.9) pkg&gt; status\nTo see all installed packages, the -m flag needs to be passed to status:\n(@v1.9) pkg&gt; st -m\nThe update command (or short up) updates all installed packages:\n(@v1.9) pkg&gt; update\nIf only a specific package should be updated, its name can be passed to update as an argument:\n(@v1.9) pkg&gt; update Plots\nAfter we installed a new package, we also need to know how to use it.\n\n\n1.10.2 Using packages\nJulia features two commands to load packages, using and import. Both can be called either on the package itself or with specific symbols defined in the package. When calling\n\nusing MyModule\n\nall names (functions, macros, variables, constants) that are exported by the package are made available in the current namespace. Calling\n\nusing MyModule: x, p\n\nmakes only specific symbols, here x and p, available in the current namespace. When calling\n\nimport MyModule\n\nall symbols in the package are made accessible, but they are not imported into the current namespace. Therefore symbols can only be accessed by explicitly specifying them with the package name, e.g., MyModule.x, but not via x alone. Another difference between using and import is that functions imported with using cannot be extended with new methods. Methods can only be added to functions imported with import.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#environments",
    "href": "content/julia-language.html#environments",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.11 Environments",
    "text": "1.11 Environments\nIn addition to installing, updating, and removing packages, Julia‚Äôs package manager also offers powerful facilities for managing dependencies and setting up environments. In essence, any folder can host a Julia environment. Starting Julia with the --project=&lt;path&gt; argument specifies to use the environment defined in &lt;path&gt;. The shortcut julia --project for julia --project=. uses the current directory as the environment. Two files define an environment, Project.toml and Manifest.toml. In Project.toml, metadata and all explicit dependencies are listed, possibly with compatibility information, that restricts the allowed version of all or some dependencies. The Manifest.toml file specifies which version of each explicit and implicit dependency is currently installed. This is a compelling feature of Julia, as storing the Project.toml and Manifest.toml files, e.g., together with simulation results, allows for reproducing the environment of that specific simulation exactly.\nIn the Pkg REPL, the prompt always includes the active environment, which is modified by Pkg commands such as add, rm, and up. If the prompt shows something like (@v1.9), we are in the default environment for Julia v1.9. If the prompt shows (GeometricIntegrators) pkg&gt;, we are in the GeometricIntegrators environment.\nAn environment can also be activated from within the Pkg REPL with the activate command:\n(@v1.9) pkg&gt; activate tutorial\n  Activating new project at `/private/tmp/tutorial`\n\n(tutorial) pkg&gt;\nThe REPL prompt changed to reflect the new active environment, and Pkg indicates that it created a new environment in /private/tmp/tutorial as the tutorial environment did not yet exist in the current path. Running activate with no arguments returns to the default environment:\n(tutorial) pkg&gt; activate\n  Activating project at `~/.julia/environments/v1.9`\n\n(@v1.9) pkg&gt;\nCalling status in the new environment shows that the project is still empty, i.e., no packages have been installed yet:\n(tutorial) pkg&gt; status\nStatus `/private/tmp/tutorial/Project.toml` (empty project)\nWhen packages are added, removed, or updated, Pkg updates the Project.toml and Manifest.toml files accordingly. Given those two files, a copy of an environment in the exact same state can be instantiated anywhere using the instantiate command:\n(tutorial) pkg&gt; instantiate\nThis will install all the environment‚Äôs explicit and implicit dependencies in the version saved in the Manifest.toml file.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/julia-language.html#summary-and-outlook",
    "href": "content/julia-language.html#summary-and-outlook",
    "title": "1¬† Basics of the Julia Language",
    "section": "1.12 Summary and outlook",
    "text": "1.12 Summary and outlook\nThis chapter provided a crash course in the Julia programming language, covering the most basic elements, every aspiring Julia artisan needs to know. The next two chapters will complete our overview of the Julia language, explaining some of its most decisive and distinctive features, namely its type system, methods, and multiple dispatch. After that, we will discuss arrays, which are an elementary component of every scientific programmer‚Äôs toolkit, and conclude with some useful design patterns before moving to Part 2 on Research software engineering.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Basics of the Julia Language</span>"
    ]
  },
  {
    "objectID": "content/type-system.html",
    "href": "content/type-system.html",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "",
    "text": "2.1 Types, variables, and values\nProgramming languages such as C++ distinguish between types, objects, values, variables, references, and pointers (see e.g.¬†Bjarne Stroustrop‚Äôs definitions of these terms in The C++ Programming Language or A Tour of C++). Unfortunately, these terms are not used consistently across different programming languages. Moreover, Julia only discriminates between types, values, and variables. It is essential to define and clarify the meaning and understand the difference and interplay between these concepts.\nA type specifies what kind of data an object represents, e.g., a number, a string, some data collection, or a function. Types provide important information to the computer, e.g., how much memory is needed to create an object and how to access it.\nA value is some entity in memory representing a certain kind of data. A variable is a name used to access a value. It can be thought of as a reference to a location in memory.\nA value can be assigned to several variables or no variable at all. A variable can at most refer to one value. It can also be left uninitialized and thus not refer to any value.\nA value always has a fixed, well-defined type. In Julia, variables do not have types; they are just names that refer to values. However, Julia allows to restrict the type of values that can be assigned to a variable.\nVariable declaration refers to the process of specifying an identifier, and variable assignment refers to determining which value a variable should refer to. While many programming languages require these to be separate processes, Julia considers the assignment of a value to a nonexisting variable as the implicit declaration of that variable. Nonetheless, declaring a variable without assigning a value is also possible using the global and local keywords, e.g.,\nglobal x\nThe details of global and local variables will be discussed in the section on variable scopes.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#type-systems",
    "href": "content/type-system.html#type-systems",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.2 Type systems",
    "text": "2.2 Type systems\nEvery programming language has a system of type checking, which is the process of verifying and enforcing type constraints. This system ensures that only values of the correct types are used at each step of a program thus minimizing errors during execution. It is important to understand the differences between dynamic and static type systems, explicit and implicit type systems, as well as strong and weak type systems. These terms are used to characterize how a programming language handles data types, which significantly impacts how to write, test, and maintain code.\nUnfortunately, these concepts are often confounded and falsely identified. Static typing is often mistaken as explicit typing and dynamic typing as implicit typing. Similarly, static type systems are often equated with compiled languages and dynamic type systems with interpreted languages. However, these are all different concepts that need to be considered separately. Both static and dynamic type systems can be implicit or explicit, and both compiled or interpreted languages can be statically or dynamically typed.\nIn the following, we try to clarify each of these terms before classifying Julia‚Äôs type system in terms of these concepts.\n\n2.2.1 Static vs.¬†dynamic type systems\nWith static type systems, the type of every expression must be computable without executing the program, providing a limited form of program verification. With dynamic type systems, fewer such a priori checks can be performed as type information on all the values manipulated by the program is available only at runtime. Therefore dynamically typed languages are prone to certain runtime errors that can be detected only by static type checking. Typically this amounts to an operation being applied to a value with a type not supported by the operation. Such problems can be quite a challenge to debug. An inapplicable operation may occur long after the original programming mistake that caused the value to have the wrong type. Therefore programming practices such as unit testing and test-driven development are particularly important with dynamically typed languages.\nIn dynamically type-checked languages, some kind of runtime type information (RTTI) containing a reference to the appropriate type is attached to each value. As this information has to be retrieved repeatedly at every execution of the program, languages with dynamic type systems often involve higher computational costs and memory demands than languages with static type systems. Moreover, the lack of type information at compile time often does not allow for the level of optimization possible with statically type-checked languages. The latter can produce optimized machine code that is stripped of type checks, as those have already been performed ahead of runtime and do not need to store any runtime type information.\nMost classical programming languages are either statically typed or dynamically typed. However, some languages allow parts of a program to be statically typed, with other parts dynamically typed. This is referred to as gradual typing.\n\n\n2.2.2 Explicit vs.¬†implicit type systems\nWith explicit type systems, the programmer must manually declare the type of each variable. Implicit type systems use type inference to deduce the type of values, thus obviating the need to declare them explicitly. In explicit typing, types are associated with variables, not values. In implicit typing, types are associated with values, not variables. Many languages that support implicit typing also allow for explicit typing where needed.\n\n\n2.2.3 Strong vs.¬†weak type systems\nThe concepts of strongly vs.¬†weakly typed languages are not as well-defined as those discussed above. Typically, strong typing refers to languages that enforce typing rules strongly, meaning they do not allow any automatic type conversions at all or only such conversions that do not lose information. If lossy type conversions are allowed, the language is referred to as weakly typed.\n\n\n2.2.4 Nominal vs.¬†structural type systems\nNominal (or nominative) means name-based. In nominal type systems, the equivalence of data types and the hierarchical relationships between types are established by the names of the types and explicit declarations. Two values are considered type-compatible if and only if they are of the same type, and a type is considered a subtype of another type only if this is explicitly declared.\nStructural means property-based. In structural type systems, the equivalence of data types and the hierarchical relationships between types are established by the structure of the types instead of their names. Two values are considered type-compatible if all their properties are matching. For example, two structs are considered equivalent if they have the same number and kind of fields, even if they are defined independently as separate types. If one type has all the properties of another type, but not vice versa, the first type is considered a subtype of the second. For example, if type A is a struct with three fields, and type B is a struct with five fields, where the types of the first three fields match those of the fields in type A, then type B is considered a subtype of type A.\n\n\n2.2.5 Julia‚Äôs type system\nIn terms of the concepts defined above, Julia‚Äôs type system is dynamic, implicit, strong and nominal. Moreover, Julia‚Äôs type system is parametric, meaning that types can be parameterized by other types, symbols, numbers, bools, or tuples.\nLike in most other dynamically typed languages, methods in Julia are polymorphic by default. This means methods will accept values of any type unless their argument types are restricted. Such type restrictions can be used to assure code correctness, e.g., to avoid a method being applied to some type that is not supported by all the operations in the method. More importantly, it facilitates method dispatch on the types of function arguments. This aspect will be discussed in detail in the next chapter.\nJulia encourages writing generic code, which means applying as few type restrictions as necessary to guarantee the ability of a method to operate correctly on its input data or to dispatch between different methods of a function.\nJulia distinguishes between abstract types and concrete types. The difference is that concrete types can be instantiated while abstract types cannot. Subtypes can only be derived from abstract types. Concrete types are final and cannot serve as supertypes. This may seem restrictive and somewhat unusual to someone with a background in traditional class-based object-oriented (CBOO) languages like Python or C++. However, it offers many advantages with only minor disadvantages. While in CBOO languages, structure as well as behavior are inherited from supertypes to subtypes, in Julia only behavior is inherited, and composition is embraced over the inheritance of structure. This avoids various limitations of CBOO languages and often leads to cleaner code that is easier to understand and has a more transparent structure. Admittedly, appreciating the Julian way of programming requires some adjustment of thinking and rewiring of the object-oriented programmer‚Äôs brain, but it is well worth the effort, especially in the realms of scientific computing.\nJulia does not distinguish between object and non-object values, but all values are proper objects with a type, and all types are equally first-class members of Julia‚Äôs type graph.\n\nIn particular, there is no distinction between primitive types and composite types like in C++ or Java, where instances of the former are referred to as variables and instances of the latter as objects, and both are not created equal, one with the new keyword and one without. In Julia, all values are objects. Therefore Julia does not make a distinction between variables and references.\n\nAfter this short excursion into type set theory that allowed us to perform a basic characterization of Julia‚Äôs type system, we will now learn how to make use of types in practice.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#working-with-types",
    "href": "content/type-system.html#working-with-types",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.3 Working with types",
    "text": "2.3 Working with types\nJulia does not require to specify the type of a value associated with some variable; thus by default values that are assigned to variables can be of any type. A lot of useful Julia code can be written without ever worrying about types. Still, sometimes restricting types is required, e.g., to utilize Julia‚Äôs multiple-dispatch mechanism or to aid the compiler in producing performant code. Other good reasons for explicitly specifying or restricting types include increasing expressiveness, improving code readability, catching programmer errors, and confirming that a program works correctly, thus ultimately increasing robustness. Typically, it is a good idea to start by writing general code that restricts types as little as possible or not at all and then gradually introduce type annotations where necessary.\nTo annotate types, Julia provides the :: operator, which is followed by a type, e.g.,\n\nglobal x::Float64\n\nThis forces the value referenced by x to be of type Float64. If the variable is assigned a value of a different type, Julia uses the convert command to perform an appropriate type conversion:\n\nx = 1\nx\n\n1.0\n\n\nThe inner workings of this mechanism will be described in Chapters 5.\n\nType annotations for global variables as above are only supported since Julia v1.8.\n\nIf a concrete type is specified, the value must be an instance of this very type. If an abstract type is specified, it suffices for the value to be an instance of any subtype of that type, e.g.,\n\ny::Real = 1.0\n\n1.0\n\n\nThe type of y is Float64, as is verified by the typeof function:\n\ntypeof(y)\n\nFloat64\n\n\nThe isa function confirms that the type of the value referenced by y is indeed a subtype of Real:\n\nisa(y, Real)\n\ntrue\n\n\nIf an automatic conversion is not possible, an error is thrown:\n\nz::Int64 = 1.5\n\nLoadError: InexactError: Int64(1.5)\n\n\nNote, however, that the following assignment works without problems:\n\nz::Int64 = 1.0\nz\n\n1\n\n\nThe value 1.0 can be truncated to an integer value without any loss of information.\n\nWhen the :: operator is appended to a variable on the left-hand side of an assignment or as part of a global or local declaration, it restricts the variable to always refer to a value of the specified type, very much like a type declaration in an explicitly-typed language such as C. This feature helps avoid type unstable code that could occur if an assignment to a variable changes its type unexpectedly, which would be detrimental to performance.\n\nType declarations can not only be attached to variable declarations but also to method definitions. In the following example, the return type of relu is declared to be Float64:\n\nfunction relu(x)::Float64\n    if x ‚â§ 0\n        return 0\n    else\n        return x\n    end\nend\n\nrelu (generic function with 1 method)\n\n\nThis enforces that the returned value is always converted to Float64:\n\nrelu(1)\n\n1.0\n\n\n\ntypeof(relu(1))\n\nFloat64\n\n\nIn Julia, every expression returns a value, every function, and also every assignment. For example, the following assignment returns the value 3:\n\nz = 3\n\n3\n\n\nThis implies that every expression is associated with a return type. When the :: operator is appended to an expression, its return value is asserted as an instance of the subsequent type. If the type assertion fails, an exception is thrown:\n\n(1+2)::Float64\n\nLoadError: TypeError: in typeassert, expected Float64, got a value of type Int64\n\n\nIf the assertion passes, the value of the expression on the left is returned:\n\n(1+2)::Int64\n\n3\n\n\nThis syntax provides a concise way of applying type assertions on the return type of any expression.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#different-kinds-of-types",
    "href": "content/type-system.html#different-kinds-of-types",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.4 Different kinds of types",
    "text": "2.4 Different kinds of types\nJulia‚Äôs type system knows two fundamental kinds of types: abstract and concrete types; and there are two kinds of concrete types: primitive and composite types. We will now discuss the various types, starting with abstract, primitive, and composite types, followed by special cases like singletons and mutable composite types.\n\n2.4.1 Abstract types\nHierarchies of abstract types provide the backbone of Julia‚Äôs programming model. They describe relations between concrete types and provide a context for them to fit in. They allow implementing methods that apply to a whole group of types instead of just one type alone and separate behavior from implementation. A typical design pattern in Julia defines an interface for an abstract type that encodes a desired behavior. The actual implementation of such an interface typically happens on all levels of a type hierarchy. If a piece of code makes sense for a group of types, it is implemented for the common supertype of those types. If a piece of code only makes sense for a specific concrete type, it is implemented for this type only. Even if a piece of code makes sense for several types, a type-specific implementation can be added to leverage the characteristics of the respective type for efficiency.\nNew abstract types are introduced with the abstract type keyword followed by the name of the new type. For example, a new abstract type MyAbstractType can be defined by:\n\nabstract type MyAbstractType end\n\nOptionally, the name of the type can be followed by &lt;: and an existing abstract type:\n\nabstract type MyAbstractSubtype &lt;: MyAbstractType end\n\nThis makes MyAbstractSubtype a subtype of the parent type or supertype MyAbstractType. If no supertype is explicitly specified, the default supertype is Any, which is at the top of Julia‚Äôs type graph. Therefore, all types are subtypes of Any and all objects are instances thereof.\nThe &lt;: operator generally means ‚Äúis a subtype of‚Äù. It is not only used in type declarations but also in expressions, where it acts as a subtype operator. It returns true when its left operand is a subtype of its right operand:\n\nInteger &lt;: Number\n\ntrue\n\n\n\nString &lt;: Number\n\nfalse\n\n\nNote that all types are considered a subtype of themselves, both abstract and concrete types:\n\nNumber &lt;: Number\n\ntrue\n\n\n\nFloat64 &lt;: Float64\n\ntrue\n\n\nThe supertype of a type can also be explicitly identified with the supertype function:\n\nsupertype(Float64)\n\nAbstractFloat\n\n\n\nsupertype(AbstractFloat)\n\nReal\n\n\n\nsupertype(Real)\n\nNumber\n\n\nIn order to get an idea about the aforementioned type hierarchies, let us consider Julia‚Äôs native number types. In the previous chapter, we encountered several concrete number types:\n\nInt8, Int16, Int32, Int64, and Int128 for signed integers,\nUInt8, UInt16, UInt32, UInt64, and UInt128 for unsigned integers,\nFloat16, Float32, and Float64 for floating-point numbers.\n\nWhile the different number types in each group have different lengths, they all represent the same kind of data, and we expect the members of each group to behave the same. We also expect a piece of code to make sense for all group members as long as the behavior it implements is not explicitly dependent on the bit length of the type. Therefore all signed integers share a common supertype, Signed, while all unsigned integers share a common supertype, Unsigned. This allows to implement methods that are the same for all signed integers to work on arguments of type Signed, while the corresponding methods for unsigned integers work on arguments of type Unsigned.\nTo a lesser but still large extent, we expect signed and unsigned integers to behave the same. That is why both, Signed and Unsigned, have a common supertype Integer. Behavior whose implementation is identical to signed and unsigned integers can thus be implemented in a common method that accepts arguments of type Integer.\nSimilarly, all float types share a common supertype AbstractFloat, and both Integer and AbstractFloat share a common supertype Real, which again is a subtype of Number. The Number type, on the other hand, derives from Any and is thus the most general number type in Julia. The part of Julia‚Äôs numerical type hierarchy that we just discussed can be summarized as follows:\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\nSome other types we did not list are Rational, another subtype of Real, and Complex, a subtype of Number.\n\n\n2.4.2 Primitive types\nJulia knows two kinds of concrete types: primitive types and composite types. Primitive types only consist of bits. Examples are integers and floating-point values, bools and characters. Primitive types are the basic building blocks for composite types.\nIn Julia, all primitive types are declared natively in Julia itself, and it is straightforward to define custom primitive types using the following syntax:\n\nprimitive type ¬´name¬ª ¬´bits¬ª end\nprimitive type ¬´name¬ª &lt;: ¬´supertype¬ª ¬´bits¬ª end\n\nWith the first line, the new type will be a subtype of Any, while in the second line, a supertype is explicitly specified. The storage required by the type is specified in bits, although currently only multiples of 8 are supported. Consider the type declaration in the following example:\n\nprimitive type Float128 &lt;: AbstractFloat 128 end\n\nThis defines a custom 128-bit type that is a subtype of AbstractFloat.\n\nIt is rarely ever necessary to implement a custom primitive type. If some special behavior is required, it is usually better to wrap one of the standard types.\n\n\n\n2.4.3 Composite types\nComposite types are collections of named fields whose instances can be treated as single values. Each field is an instance of either a primitive or another composite type. In other languages, composite types are called structs, records, or objects.\nNew composite types are introduced with the struct keyword followed by the name of the new type and a list of field names. For example, a new composite type FooBar with two fields, foo and bar, can be defined by:\n\nstruct FooBar\n    foo\n    bar\nend\n\nOptionally, the name of the type can be followed by &lt;: and an abstract type:\n\nstruct SubFooBar &lt;: MyAbstractType\n    foo\n    bar\nend\n\nThis makes SubFooBar a subtype of MyAbstractType. If no supertype is explicitly specified, the new type becomes a subtype of Any. The types of fields can be annotated with the :: operator, e.g.,\n\nstruct TypedFooBar\n    foo::Real\n    bar::Float64\nend\n\nBoth concrete types and abstract types can be used. In the latter case, the field can hold values of all concrete subtypes of the specified abstract type, e.g., the field foo in TypedFooBar can hold all kinds of real numbers, including Int8, Int16, and other ints, but also Float32, Float64, and Rational. In contrast, the field bar is constrained only to hold values of type Float64. In the absence of type annotations, the type of a field defaults to Any. Therefore such fields can hold values of any type.\nTo create an instance of a composite type, we have to call its constructor by applying the type name like a function and passing the values of the fields as arguments. For example, an instance of the FooBar type can be created by\n\nfb = FooBar(\"Hello\", 42)\n\nFooBar(\"Hello\", 42)\n\n\nJulia generates two default constructors automatically: one that accepts arguments that match the field types exactly and one that accepts any kind of arguments and tries to convert them to the types of the fields.\nOur FooBar has no type constraints so we can initialize both fields with any value. However, if we try to instantiate the TypedFooBar type, the values for foo and bar must be convertible to any subtype of Real and Float64, respectively. If the given values are not convertible without losing information, an exception is raised:\n\nTypedFooBar(4 + 2im, 42)\n\nLoadError: InexactError: Real(4 + 2im)\n\n\nThe first argument is a Complex that cannot be converted into a Real unless the imaginary part is zero:\n\nTypedFooBar(4 + 0im, 42)\n\nTypedFooBar(4, 42.0)\n\n\nIn the following example, the first argument is a Rational, which is a subtype of Real and thus will not be converted. The second argument is an Int, which is converted to Float64 according to the type declaration:\n\nTypedFooBar(4 // 2, 42)\n\nTypedFooBar(2//1, 42.0)\n\n\nThe next chapter, Methods and Multiple Dispatch, will discuss constructors in more detail.\nThe values of the fields of a composite type can be accessed using the . notation. For example, the fb variable references a value of type FooBar, which has two fields, foo and bar, that can be accessed as follows:\n\nfb.foo\n\n\"Hello\"\n\n\n\nfb.bar\n\n42\n\n\nIf a field is accessed, that does not exist, an exception is raised:\n\nfb.baz\n\nLoadError: type FooBar has no field baz\n\n\nThe field names of a type can be retrieved by the fieldnames function:\n\nfieldnames(FooBar)\n\n(:foo, :bar)\n\n\nNote that this function has to be applied to a type, not to an instance:\n\nfieldnames(fb)\n\nLoadError: MethodError: no method matching fieldnames(::FooBar)\n\nClosest candidates are:\n  fieldnames(::Core.TypeofBottom)\n   @ Base reflection.jl:170\n  fieldnames(::Type{&lt;:Tuple})\n   @ Base reflection.jl:172\n  fieldnames(::UnionAll)\n   @ Base reflection.jl:169\n  ...\n\n\nIf we want to retrieve the fields of a type from an instance, we have to use fieldnames in conjunction with the typeof function, e.g., fieldnames(typeof(fb)).\n\n\n2.4.4 Immutability\nThe fields of composite types cannot be modified once an instance is created: they are immutable. Julia also supports mutable composite objects, which can be declared with the keyword mutable struct. Before we discuss these in more detail in the next section, let us first understand why the default behavior for fields is to be immutable, as it may seem odd at first.\nSome advantages are compiler-related: immutable objects may be represented more efficiently in memory, and sometimes memory allocation can be avoided altogether. Another advantage is related to program safety: if some fields need to satisfy invariants, these can be checked in a custom constructor for a type. However, they can only be guaranteed after instantiation if a type is immutable. Otherwise, the value of the corresponding field could be changed after the fact in a way that violates the invariants enforced by the constructor.\nSome essential properties of immutability in Julia are important to understand. Obviously, the value of an immutable type cannot be modified. If we try to do so, an exception will be raised. We can see this when trying to modify one of the fields of an instance of our FooBar type:\n\nfb.foo = 1\n\nLoadError: setfield!: immutable struct of type FooBar cannot be changed\n\n\nThis has various consequences. It implies that values of primitive types cannot be changed once they are set. Therefore, there are no in-place operations on primitive types, and even operations like x += 3 will allocate a new instance of some number type and re-assign the variable x to reference that new value instead of overwriting the value originally referenced by x.\nFor composite types, it implies that their fields‚Äô values will never change once instantiated. Fields that are primitive types will always hold the same sequence of bits. Fields that are composite types will always reference the same composite value.\nA vital detail is that the immutability of a composite type is not passed on to its fields. If a field of an immutable composite type references a mutable type, then its values remain mutable. However, as the field itself is immutable, the reference cannot be changed, so that once set the field will always reference the same value. For example, consider an immutable type that has a field referencing an array. After initialization, the field will always reference the same array, but the elements of the array can be changed nonetheless.\nImmutability only applies to the values of the fields of the immutable object. Its fields cannot be changed to reference different values, e.g., if an immutable object is created with a field that holds an array, this field will always reference the same array. Still, we can change the elements of the array as long as the array itself is mutable.\n\n\n2.4.5 Mutable composite types\nAs sometimes immutable structs are too much of a restriction, Julia also allows declaring a composite type to be mutable by using the mutable struct keyword instead of struct:\n\nmutable struct MutableFooBar\n    foo::Real\n    bar::Float64\nend\n\nInstances of a mutable struct can be modified:\n\nmfb = MutableFooBar(4//2, 42)\n\nMutableFooBar(2//1, 42.0)\n\n\n\nmfb.foo = 23\nmfb\n\nMutableFooBar(23, 42.0)\n\n\nThe foo field of mfb is first initialized to 42 and then changed to 23. Note that this does not change the bit content of the value referenced by foo from 42 to 23, but instead a new number value is created and foo is changed to refer to this new value.\n\nSince Julia v1.8 it is possible to set individual fields of a mutable struct to be immutable or constant by preceding the field name with const.\n\nThis allows us to adapt the FooBar type to have one mutable field foo and one immutable field bar:\n\nmutable struct PartiallyMutableFooBar\n    foo::Real\n    const bar::Float64\nend\n\npmfb = PartiallyMutableFooBar(4//2, 42)\npmfb.foo = 23\npmfb.bar = 23\n\nLoadError: setfield!: const field .bar of type PartiallyMutableFooBar cannot be changed\n\n\nThe mutability of fields aside, mutable types behave exactly the same as immutable types, at least from the programmer‚Äôs perspective. Under the hood, however, Julia can treat instances of mutable and immutable types quite differently. This concerns allocations on the heap vs.¬†allocations on the stack or the identification of objects by their address vs.¬†identification by their value. These differences allow the compiler to apply certain optimizations in the case of immutable types that are not possible for mutable types.\nFor example, sufficiently small immutable values like single numbers are usually allocated on the stack, while mutable values are allocated on the heap. Mutable objects can only be reliably identified by their address as they might hold different values over time. Therefore they must have stable memory addresses and are passed to functions via reference. Immutable objects, on the other hand, are associated with specific field values, and the field values alone are required to identify the object uniquely. These differences allow the compiler to freely copy immutable values since it is impossible to distinguish between the original object and a copy programmatically.\n\n\n2.4.6 Singletons\nJulia implements some special behavior for a special kind of composite type, namely for immutable composite types with no fields. Such types are called singletons. They are declared like usual immutable types, without any special keyword, but just with a lack of fields:\n\nstruct NoFields end\n\nOf course, such types can also be the subtype of some abstract type.\nWhat is special about singletons, is that there can be only one instance of such types. The === operator can be used to confirm that the two instances of NoFields are actually one and the same:\n\nNoFields() === NoFields()\n\ntrue\n\n\nWithout the discussion of the next chapter, Methods and Multiple Dispatch, it is difficult to see the utility of the singleton type construct. In short, it allows for specializing function behavior on a type that is given as an explicit argument rather than implied by the types of the other arguments. We will return to this topic in Chapters 3 and 5 as this is a common design pattern in Julia.\n\n\n2.4.7 Type aliases\nA type alias, i.e., a new name for an already expressible type, can be declared by a simple assignment statement:\n\nconst FB = FooBar\n\nFooBar\n\n\nAfter such a definition, the alias can be used in the same way as the original type, e.g., to create an instance, we can call FB as a constructor:\n\nfb = FB(4 // 2, 42)\n\nFooBar(2//1, 42)\n\n\nInternally, Julia uses this feature to define the Int and UInt aliases, which refer to either Int32 or Int64 and UInt32 or UInt64, respectively, depending on the native pointer size of the system.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#parametric-types",
    "href": "content/type-system.html#parametric-types",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.5 Parametric types",
    "text": "2.5 Parametric types\nParametric types are one of the most powerful features of Julia‚Äôs type system. As the name suggests, these are types that depend on parameters in a similar way to templates in C++ or generics in Python. Declaring a parametric type introduces not only one new type but a whole family of new types, namely one for each possible combination of parameter values. All declared types (abstract, primitive, composite) can be parameterized by any type or a value of any bits type. This is a handy feature for generic programming as well as for performance.\nAll declared types (abstract, primitive, composite) can be amended by type parameters. Parametric types are defined in a very similar way as non-parametric types. The only difference is that the type name is followed by curly braces that contain one or more type parameters. We will discuss this in more detail for all declared types, starting with parametric composite types, as these are the most often used kind of parametric types.\n\n2.5.1 Parametric composite types\nA parametric composite type, depending on the parameter T, is declared by:\n\nstruct ParametricFooBar{T}\n    foo::T\n    bar::T\nend\n\nThis declaration states that the type has two fields, foo and bar, which are both of type T (cf.¬†type annotations earlier in this chapter). The parametric type ParametricFooBar{T} can be turned into a concrete type by specifying a value for T, for example ParametricFooBar{Float64}. This type can be used like any other composite type, e.g., it can be instantiated in the usual way by:\n\nParametricFooBar{Float64}(23, 42)\n\nParametricFooBar{Float64}(23.0, 42.0)\n\n\nThe type ParametricFooBar{Float64} is equivalent to the ParametricFooBar type with T replaced by Float64, i.e., it is equivalent to\n\nstruct FooBarF64\n    foo::Float64\n    bar::Float64\nend\n\nBy inserting different values for T, such as Float32, Int, AbstractString, etc., we obtain different concrete types whose fields foo and bar are of the respective type. Thus the declaration of ParametricFooBar{T} does not define only one type but an infinite number of types.\nJulia provides two default constructors for parametric composite types: one that expects the type parameters to be explicitly specified and one that tries to deduce the type parameters from the types of the arguments. If we instantiate a parametric type like in the example above, that is, with all type parameters explicitly given, we are effectively instantiating a concrete type, ParametricFooBar{Float64}, and thus the default constructor works in the very same way as for concrete composite types: exactly one argument must be supplied for each field, and if the arguments‚Äô types do not match the prescribed types of the fields, Julia tries to convert them.\nOften it is not necessary to provide values for the parameters explicitly as they can be deduced from the types of the arguments. Therefore the name of the parametric type without values for the parameters can also be used as a constructor as long as the values of the type parameters can be determined unambiguously. Thus, an instance of ParametricFooBar{Float64} can also created by:\n\nParametricFooBar(23., 42.)\n\nParametricFooBar{Float64}(23.0, 42.0)\n\n\nNote that providing arguments of different number types does not allow for an unambiguous determination of the type parameter T:\n\nParametricFooBar(23, 42.)\n\nLoadError: MethodError: no method matching ParametricFooBar(::Int64, ::Float64)\n\nClosest candidates are:\n  ParametricFooBar(::T, ::T) where T\n   @ Main In[48]:2\n\n\nHowever, custom constructor methods that allow handling such cases appropriately can be defined as discussed in Chapter 3.\nOften it may not make sense for type parameters to take any possible type but only a restricted set of types, e.g., a type may only be a subtype of Number but not an AbstractString or anything else. In such situations, the range of the parameter T can be constrained by using the &lt;: syntax followed by a type:\n\nstruct RealFooBar{T &lt;: Real}\n    foo::T\n    bar::T\nend\n\nWith this restriction in place, we can still create instances with real field values but not e.g.¬†with complex values:\n\nRealFooBar(23., 42.)\n\nRealFooBar{Float64}(23.0, 42.0)\n\n\n\nRealFooBar(23 + 23im, 42 + 42im)\n\nLoadError: MethodError: no method matching RealFooBar(::Complex{Int64}, ::Complex{Int64})\n\n\nType parameters are evaluated from left to right and can depend on the preceding parameters:\n\nstruct ArrayFooBar{T &lt;: Number, A &lt;: AbstractArray{T}}\n    x::A\nend\n\nThis type has a field x that holds an array, whose type is a type parameter. In addition, the element type of the array is also a type parameter and restricted to be some kind of number type.\nThis mostly concludes the basic discussion of parametric types. Although we will briefly discuss parametric abstract and primitive types in the following two sections, everything works pretty much the same as with composite types.\n\n\n2.5.2 Parametric abstract types\nA parametric abstract type, depending on the parameter T, is declared by:\n\nabstract type MyParametricAbstractType{T} end\n\nAs with composite types, this does not only declare one abstract type but a whole collection of abstract types. We obtain a distinct abstract type MyParametricAbstractType{T} for each value of T.\nThe range of type parameters for abstract types can be constrained in the same way as for composite types:\n\nabstract type MyRealAbstractType{T &lt;: Real} end\n\nWith this, concrete abstract types can only be formed when using appropriate parameter values:\n\nMyRealAbstractType{Real}\n\nMyRealAbstractType{Real}\n\n\n\nMyRealAbstractType{Float64}\n\nMyRealAbstractType{Float64}\n\n\n\nMyRealAbstractType{AbstractString}\n\nLoadError: TypeError: in MyRealAbstractType, in T, expected T&lt;:Real, got Type{AbstractString}\n\n\nThe last example raises an exception as AbstractString is not a subtype of Real.\n\n\n2.5.3 Parametric primitive types\nEven primitive types can be declared parametrically, although this is probably a feature most scientific software developers will never use. Julia uses this feature to represent pointers as follows:\n\n# 32-bit system:\nprimitive type Ptr{T} 32 end\n\n# 64-bit system:\nprimitive type Ptr{T} 64 end\n\nIn contrast to typical parametric composite types, the type parameter T is not used in the definition of the type itself. After all, primitive types do not have fields whose type could be annotated. Instead, it is used as a tag that denotes what kind of object the pointer refers to, e.g., to distinguish a pointer to a Float64 variable, which would be of type Ptr{Float64}, and a pointer to an Int64 variable, which would be of type Ptr{Int64}, even though both pointers have identical representations.\nThis concludes the discussion of parametric types. In the next section, we discuss how different sets of concrete and parametric types relate to each other.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#type-set-theory",
    "href": "content/type-system.html#type-set-theory",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.6 Type set theory",
    "text": "2.6 Type set theory\nWhen considering type hierarchies in Julia, there exist a few potential pitfalls, especially with parametric types, and it is crucial to understand them. We will thus analyze which types constitute subtypes of other types and which do not, although at first glance, one might expect them to.\nWe will discuss these issues based on Julia‚Äôs abstract array type, AbstractArray{T,N}, and its default concrete array type, Array{T,N} &lt;: DenseArray{T,N} &lt;: AbstractArray{T,N}. Both have two parameters, T denoting the type of the array elements and N denoting the dimension of an array.\nThe parametric types Array and AbstractArray are valid type objects whose subtypes contain all types that can be obtained by specifying the parameters T and N. For example, upon fixing the element type T to Float64 and the dimension N to 1, we can verify that the following intuitive subtype relationships hold in practice:\n\nAbstractArray{Float64,1} &lt;: AbstractArray\n\ntrue\n\n\n\nArray{Float64,1} &lt;: Array\n\ntrue\n\n\n\nArray{Float64,1} &lt;: AbstractArray\n\ntrue\n\n\nConcrete types with different values of the parameters are never subtypes of each other, not even if the parameter of one subtype is itself a subtype of the parameter of the other subtype, e.g., even though we have Float64 &lt;: Real the following expressions are not true:\n\nAbstractArray{Float64,1} &lt;: AbstractArray{Real,1}\n\nfalse\n\n\n\nArray{Float64,1} &lt;: Array{Real,1}\n\nfalse\n\n\nA concrete parametric subtype of an abstract parametric type can only be considered a proper subtype if the type parameters of the two types match:\n\nArray{Float64,1} &lt;: AbstractArray{Float64,1}\n\ntrue\n\n\nAs a consequence, some care is needed when annotating method arguments. If, for example, we restrict an argument to be of type Array{Real,1} the method cannot be applied to values of type Array{Float64,1} as it is not a subtype of Array{Real,1}:\n\nprintreal(a::Array{Real,1}) = println(a)\nprintreal(Array{Float64,1}())\n\nLoadError: MethodError: no method matching printreal(::Vector{Float64})\n\nClosest candidates are:\n  printreal(::Vector{Real})\n   @ Main In[68]:1\n\n\nThis problem can be solved by using the notation Array{&lt;:Real,1}, which represents the set of all concrete Array types with parameter N = 1 and parameter T a subtype of Real:\n\nAbstractArray{Float64,1} &lt;: AbstractArray{&lt;:Real,1}\n\ntrue\n\n\n\nArray{Float64,1} &lt;: Array{&lt;:Real,1}\n\ntrue\n\n\n\nArray{Float64,1} &lt;: AbstractArray{&lt;:Real,1}\n\ntrue\n\n\nThus we can adapt the above method as follows in order to make it work:\n\nprintsubofreal(a::Array{&lt;:Real,1}) = println(a)\nprintsubofreal(Array{Float64,1}())\n\nFloat64[]\n\n\nThe printsubofreal accepts all one-dimensional arrays whose element type is a subtype of Real.\nThis concludes the discussion of basic type set theory, which hopefully shed some light on the relationships between concrete types, parametric types and abstract types. In the next section, we discuss some technical details on the inner workings of abstract types.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#unionall-types",
    "href": "content/type-system.html#unionall-types",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.7 UnionAll types",
    "text": "2.7 UnionAll types\nThe type of parametric types like Array cannot be a normal DataType. On the one hand, we have just seen that parametric types act as supertypes for all their instances, but a DataType is final and cannot be a supertype for any other type. On the other hand, without specifying values for all type parameters, a parametric type cannot be instantiated and thus does not constitute a concrete type. This suggests that parametric types are of a different type, namely a UnionAll type. For each parameter, such a type represents the union of all possible types originating from a parametric type by applying all permissible values of the parameter. For parametric types with more than one parameter, this representation is constructed in a nested manner.\nLet us illuminate this in more detail with two examples: the Ptr{T} type as a parametric type with just one parameter and the Array{T,N} type as an example with multiple parameters. Above we just wrote Ptr and Array for the respective UnionAll types. More accurately, these types are expressed with the where keyword as Ptr{T} where T and Array{T,N} where N where T, where each where introduces a type parameter.\nIt is possible to restrict type parameters with subtype relations. For example, Ptr{T} where T &lt;: Number is a pointer that can only be associated with objects that are some kind of Number. The same type can be expressed more conveniently by Ptr{&lt;:Number}. If a type has multiple parameters, they can be restricted individually. For example, Array{T} where T &lt;: Number and Array{&lt;:Number} denote an array that is restricted to hold numbers but whose dimension is still arbitrary.\nIf we specialize a parametric type, for example Array{T,N} to Array{Float64,2}, we are first substituting T for Float64 and then N for 2. Remember that Array{T,N} is a short form for Array{T,N} where N where T. Thus we first substitute the outermost type parameter, which is T, resulting in another UnionAll type which depends only on one type parameter, and then we substitute the remaining type parameter, which is the inner parameter N in the original parametric type. Therefore the syntax Array{Float64,2} is equivalent to Array{Float64}{2}, which also explains why it is possible to partially instantiate a type, e.g., Array{Float64}, where the first type parameter is fixed but the second parameter is still free. We can also just fix the second parameter, resorting to the where syntax, as in Array{T,1} where T, which refers to all one-dimensional arrays with arbitrary element type T. Of course, this can also be combined with a type restriction, e.g., Array{T,1} where T &lt;: Number and Array{&lt;:Number,1} denote all one-dimensional arrays whose elements are of some subtype of Number.\nIt is often useful to assign names to partially specialized parametric types. This can be achieved by a simple assignment. For example, Julia defines the Vector{T} type as follows:\n\nVector{T} = Array{T,1}\n\nThis is equivalent to\n\nconst Vector = Array{T,1} where T\n\nWith this definition, writing Vector{Float64} is equivalent to Array{Float64,1}. The Vector type represents all one-dimensional Array types.\nThe UnionAll type is only one special type in Julia‚Äôs type system. Another family of important types is type unions.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#type-unions",
    "href": "content/type-system.html#type-unions",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.8 Type unions",
    "text": "2.8 Type unions\nType unions are special abstract types whose possible values are all instances of any of its argument types. A type union can be constructed with the Union keyword:\n\nconst IntOrFloat = Union{Int64,Float64}\n\nUnion{Float64, Int64}\n\n\nThis type can hold either integer or float values:\n\n42 :: IntOrFloat\n\n42\n\n\n\n42.0 :: IntOrFloat\n\n42.0\n\n\nIf we try to assign a different value to an instance of IntOrFloat, an exception is raised:\n\n42 + 23im :: IntOrFloat\n\nLoadError: TypeError: in typeassert, expected Union{Float64, Int64}, got a value of type Complex{Bool}\n\n\nIn many programming languages, type unions are a construct used only internally by the compiler for reasoning about types. In contrast to most other languages, Julia exposes this construct to the programmer.\nA typical design pattern in Julia, based on the Union type, is annotating optional fields with Union{T, Nothing}. The type Nothing is a singleton type, thus it has only one instance, namely the nothing object. It serves a similar purpose as the void or null keywords in languages such as C or C++. However, in contrast to many other languages, nothing in Julia is not just a keyword but an actual object, that is an instance of the Nothing type. If a field is annotated by the type union Union{T, Nothing}, where T is often restricted to be a subtype of some other type, e.g., Union{T, Nothing} where {T &lt;: AbstractArray}, it can hold either a value of type T or nothing.\nThe singleton type Missing and its instance missing can be used similarly to indicate that a field does not have a value. Although fields and variables can be left uninitialized, accessing them raises an exception immediately. Thus, setting them to nothing or missing is often preferred. As both types behave quite differently, the choice of which to use depends on the context. For example, adding a number to nothing raises an error, while adding a number to missing results in missing:\n\nnothing + 2\n\nLoadError: MethodError: no method matching +(::Nothing, ::Int64)\n\nClosest candidates are:\n  +(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:587\n  +(::Missing, ::Number)\n   @ Base missing.jl:123\n  +(::BigFloat, ::Union{Int16, Int32, Int64, Int8})\n   @ Base mpfr.jl:447\n  ...\n\n\n\nmissing + 2\n\nmissing\n\n\nThis concludes the discussion of special types in Julia‚Äôs type system. We will close this chapter with an overview of how to obtain information about values and their types.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#type-introspection",
    "href": "content/type-system.html#type-introspection",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.9 Type introspection",
    "text": "2.9 Type introspection\nIn Section 2.3, Working with types, we already encountered some of the means Julia provides for type introspection, such as the typeof and isa functions. As in Julia, everything is an object, including types, they can be passed to functions as arguments just like anything else. For reference, we briefly summarize some of Julia‚Äôs most important introspection functions in one place.\nThe isa function is applied to a value and a type. It returns true if the value is of the given type and false else:\n\nisa(42, Int)\n\ntrue\n\n\n\nisa(42, Float64)\n\nfalse\n\n\nThe typeof function is applied to a value and returns its type:\n\ntypeof(42)\n\nInt64\n\n\nSince types are objects, they also have types:\n\ntypeof(Int)\n\nDataType\n\n\nAll declared types (abstract, primitive, composite) are represented by the DataType type, which is a composite type that stores the kind of the type, its size, the storage layout, the field names and parameters if present, and is an instance of itself:\n\ntypeof(DataType)\n\nDataType\n\n\nThe supertype function is applied to a type and returns its supertype:\n\nsupertype(Float64)\n\nAbstractFloat\n\n\n\nsupertype(Number)\n\nAny\n\n\n\nsupertype(Any)\n\nAny\n\n\nThe supertype function can only be applied to declared types, that is, instances of DataType, but not e.g.¬†to type unions such as Union{Float32,Float64}, even if they share a common supertype:\n\nsupertype(Union{Float32,Float64})\n\nLoadError: MethodError: no method matching supertype(::Type{Union{Float32, Float64}})\n\nClosest candidates are:\n  supertype(::UnionAll)\n   @ Base operators.jl:44\n  supertype(::DataType)\n   @ Base operators.jl:43\n\n\nThe subtypes function does exactly the opposite of the supertype function: it is applied to an abstract type and returns all its subtypes:\n\nsubtypes(Real)\n\n4-element Vector{Any}:\n AbstractFloat\n AbstractIrrational\n Integer\n Rational\n\n\n\nsubtypes(AbstractFloat)\n\n5-element Vector{Any}:\n BigFloat\n Float128\n Float16\n Float32\n Float64\n\n\nThe &lt;: operator checks whether the operand on the left is a subtype of the operand on the right:\n\nNumber &lt;: Any\n\ntrue\n\n\n\nAny &lt;: Number\n\nfalse\n\n\nJulia provides several functions for examining a given type. The functions isabstracttype, isprimitivetype, issingletontype, and isstructtype can be used to check the kind of a type:\n\nisabstracttype(Number)\n\ntrue\n\n\n\nisprimitivetype(Int)\n\ntrue\n\n\n\nissingletontype(NoFields)\n\ntrue\n\n\n\nisstructtype(FooBar)\n\ntrue\n\n\nThe functions ismutabletype and ismutable can be used to check if a type or a value, respectively, is immutable:\n\nismutabletype(Int)\n\nfalse\n\n\n\nismutable(42)\n\nfalse\n\n\nThe fieldnames function is applied to a type and returns the names of all its fields:\n\nfieldnames(FooBar)\n\n(:foo, :bar)\n\n\nSimilarly, the fieldtypes function is applied to a type and returns the types of all its fields:\n\nfieldtypes(FooBar)\n\n(Any, Any)\n\n\n\nfieldtypes(TypedFooBar)\n\n(Real, Float64)\n\n\nSeveral more functions like this exist for examining a composite type‚Äôs inner workings. However, their use is slightly more intricate, so the reader is referred to the Julia Manual for more details on those.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/type-system.html#summary",
    "href": "content/type-system.html#summary",
    "title": "2¬† Julia‚Äôs Type System",
    "section": "2.10 Summary",
    "text": "2.10 Summary\nIn this chapter, we discussed Julia‚Äôs type system, how to define abstract and concrete types, and how parametric types can be used to define whole families of types. We have glimpsed at the construction of type hierarchies by analyzing parts of Julia‚Äôs number and array types.\nWe have learned how the different kinds of types interact and relate to each other and discussed some of the intricacies of hierarchies of parametric types.\nThe type system is at the core of what makes Julia unique. Together with the multiple dispatch paradigm, which will be discussed in the next chapter, it is responsible for the sublime productivity and expressivity of the language.\nIt‚Äôs all in the types‚Ä¶",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Julia's Type System</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html",
    "href": "content/methods-multiple-dispatch.html",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "",
    "text": "3.1 Functions, methods, and dispatch\nA function is a map from a tuple of arguments to a return value. A function can be thought of as an operation that implements a specific conceptual behavior. The actual implementation of that behavior may vary greatly depending on the number and types of the function‚Äôs arguments.\nFor example, the summation and multiplication of integers are very different from the same operations applied to floating-point numbers, although the mathematical operation is the same. The different implementations all describe the same concept and thus should be referred to by the same function name. It would be atrocious if different implementations of summation for different argument types all needed different identifiers such as sum_ints, sum_floats, sum_float_to_int, etc., but that is what many programming languages require. Although most programming languages support calling standard functions such as summation and multiplication for different types by the standard operators + and *, this is a special behavior hardcoded for a limited number of functions and operators and is typically unavailable for user-defined functions. Pythonistas may say that Python allows overloading operators like +, -, *, and / using so-called magic methods, which is true, but again, this functionality is only available for a limited number of predefined operators. No user-defined function, neither inside nor outside a class, can have more than one implementation depending on the number or type of arguments.\nJulia allows the provision of more than a single implementation of a function under the same name. A function can have different implementations, referred to as a method, for different counts and types of arguments (the method signature). The different implementations need not be defined in the same place, at the same time, or even in the same package. This flexibility is one of the main reasons for Julia‚Äôs exceptional extensibility. As all functions are first class, this applies to user-defined functions, to functions in the standard library, as well as to a large number of infix operators such as + and *.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#functions-methods-and-dispatch",
    "href": "content/methods-multiple-dispatch.html#functions-methods-and-dispatch",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "",
    "text": "Be aware that in Python, the term method refers to an operation associated with a class, while the term function refers to an operation that is not associated with a class. In Julia, the term function refers to some conceptual behavior, while the term method refers to a specific implementation of that behavior for a certain number and type of arguments.\n\n\n3.1.1 Dispatch\nThe process of choosing a method is called dispatch. In traditional CBOO languages, dispatch is based solely on the first argument, which is the class to which a method belongs. For example, in Python, a method is called by obj.mymethod(arg1, arg2), but the definition of that method reads def mymethod(self, arg1, arg2):. That is, the object to which the method belongs is always passed to the method as the first argument, followed by the actual arguments specified by the user. The method executed is selected solely by the first argument, which selects the object and thus the corresponding class in which the method has been defined. In some languages, the argument on which dispatch occurs is implied rather than explicitly written out. For example, in C++ or Java, a method is also called by obj.mymethod(arg1, arg2), but there is no additional argument in the definition of the function, only arg1 and arg2. Still, a reference to the object that receives the method call is accessible inside the method via the this keyword.\nJulia selects the method executed when a function is called based on the number of arguments and the types of all the function arguments. This is known as multiple dynamic dispatch or multiple dispatch for short. In scientific computing, this approach turns out to be of great advantage and often appears more natural than a CBOO approach. Considering mathematical operations such as + or *, for example, it makes little sense for these operations to belong to one argument more than the other. In the expression x + y, should the summation operation belong to x or y? There is no obvious choice! Moreover, the particular implementation of the operation depends on the types of all the arguments. Adding two integers, two floating point numbers, or an integer and a float all require different implementations.\nThis dilemma, however, extends far beyond purely mathematical code.\n\n\n3.1.2 Object-oriented programming\nWhen talking about object-oriented programming languages, many developers think about class-based object-oriented languages, above and below referred to as CBOO languages, such as C++, Java, Python, and Ruby. In CBOO languages, composite types have data fields as well as named functions associated with them, and the combination is called an object. However, not all object-oriented languages are class-based, and even if a language supports classes, not all objects need to be composite types. For example, in Ruby or Smalltalk, all values are objects whether they are composites or not. In other languages like C++ and Java, primitive values, such as integers and floating-point values, are not objects, but only instances of user-defined composite types are proper objects with associated methods. These languages, even though (mostly) class-based, are less pure object-oriented languages.\nJulia is a pure object-oriented programming language, as all values are objects, but it is not class-based, as functions are not part of the objects on which they operate. Class-based programming is somewhat antithetical to Julia‚Äôs focus on multiple dispatch, where the method that is executed when calling a function is selected based on the types of all the function‚Äôs arguments instead of just the first one. Therefore, it does not make sense for a function to be part of any specific composite type. This, however, does not mean that Julia is not an object-oriented language. It is just not class-based.\nAs everything is an object in Julia, the same is true for functions. Function objects can be thought of as holding all the methods implemented for a given function name. It turns out that organizing methods this way and discerning them by their arguments instead of organizing them as members of composite types and discerning them by the corresponding objects is a highly beneficial aspect of Julia‚Äôs design. This will become clearer after the discussion of the next section on the expression problem.\n\n\n3.1.3 The expression problem\n\n\n3.1.4 Multiple dispatch vs.¬†operator overloading",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#defining-methods",
    "href": "content/methods-multiple-dispatch.html#defining-methods",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "3.2 Defining methods",
    "text": "3.2 Defining methods\nThe basics of defining functions (and methods) have already been discussed in Chapter 1. Still, an important point neglected entirely in that discussion is the difference between functions and methods and how to define more than one method for a function.\nMost examples of functions we considered so far were defined with a single method that had a fixed number of arguments but no constraints on argument types. Such functions behave very much like functions in traditional dynamically typed languages. However, Julia allows the provision of more than a single method definition. A function can have an arbitrary number of methods, meaning different implementations of a specific behavior for different arguments. To this end, you just need to define the function multiple times with different arguments.\nThe simplest way to discern different methods is by the number of arguments. Let us define a function printargs with two methods, one taking one argument and one taking two arguments:\n\nprintargs(x) = println(\"One argument: \", x)\nprintargs(x, y) = println(\"Two arguments: $x and $y\")\n\nprintargs (generic function with 2 methods)\n\n\nIf we call the function, depending on the number of arguments, either the first or the second method is executed:\n\nprintargs(1)\nprintargs(œÄ, \"abc\")\n\nOne argument: 1\nTwo arguments: œÄ and abc\n\n\nIf we call the function with a different number of arguments, an error is thrown:\n\nprintargs()\n\nLoadError: MethodError: no method matching printargs()\n\nClosest candidates are:\n  printargs(::Any, ::Any)\n   @ Main In[2]:2\n  printargs(::Any)\n   @ Main In[2]:1\n\n\nJulia selects methods not only based on the number of arguments but also the types of arguments. The signatures of method definitions can be annotated with the :: type-assertion operator to indicate the types of arguments a method is applicable to.\nConsider a function that adds two numbers and multiplies the result by 2:\n\naddmul2(x::Float64, y::Float64) = 2(x + y)\n\naddmul2 (generic function with 1 method)\n\n\nThis method definition is only applicable when x and y are both values of type Float64:\n\naddmul2(1.0, 2.0)\n\n6.0\n\n\nIf any of the two arguments is of another type, we will be confronted with a MethodError\n\naddmul2(1.0, 2.0f0)\n\nLoadError: MethodError: no method matching addmul2(::Float64, ::Float32)\n\nClosest candidates are:\n  addmul2(::Float64, ::Float64)\n   @ Main In[5]:1\n\n\nIf the argument types are restricted to concrete types such as Float64, the types of the provided values must match the prescribed types exactly. Julia does not perform automatic conversion, even if lossless conversion is possible. Thus, in the example above, there is no automatic promotion of 32-bit floating-point values to 64-bit floating-point values.\nFor the implementation of the addmul2 function above, it is no problem to loosen the type restrictions:\n\naddmul2(x::Number, y::Number) = 2(x + y)\n\naddmul2 (generic function with 2 methods)\n\n\nThis method applies to any pair of arguments whose type is derived from Number. Thus, it can, for example, also be applied to two integer values:\n\naddmul2(1, 2)\n\n6\n\n\nThe method can even be applied to values of different types as long as both are numeric values:\n\naddmul2(1+2im, 3.0)\n\n8.0 + 4.0im\n\n\nThe fact that this works is entirely due to the properties of the + operation and specifically to the fact that it has methods for handling disparate numeric types. Note that the first method can only be called if both arguments are of type Float64. As soon as at least one argument is of a different number type, the more general second method, applicable to all subtypes of Number, is called. For non-numeric values that are not a subtype of Number and for fewer or more arguments, the function addmul2 remains undefined, and applying it will still result in a MethodError:\n\naddmul2(1.0, \"2.0\")\n\nLoadError: MethodError: no method matching addmul2(::Float64, ::String)\n\nClosest candidates are:\n  addmul2(::Float64, ::Float64)\n   @ Main In[5]:1\n  addmul2(::Number, ::Number)\n   @ Main In[8]:1\n\n\n\naddmul2(1.0, 2.0, 3.0)\n\nLoadError: MethodError: no method matching addmul2(::Float64, ::Float64, ::Float64)\n\nClosest candidates are:\n  addmul2(::Float64, ::Float64)\n   @ Main In[5]:1\n  addmul2(::Number, ::Number)\n   @ Main In[8]:1\n\n\nWhenever more than one method is defined for a function and the function is applied, Julia executes the method whose signature matches the number and types of the arguments most closely. In the addmul2 example, we specified two method definitions, one for two arguments of type Float64 and one more general for two arguments of any subtype of Number. These two methods define the behavior for addmul2. If the addmul2 function is called with two Float64 arguments, the method that accepts two Number arguments is applicable, but the method that accepts two Float64 arguments is more specific and thus called.\nNot constraining an argument‚Äôs type in a method definition is equivalent to annotating it to be of type Any, which is the supertype of all types in Julia. As this is the least specific type constraint, a method with unconstrained argument types will only be called if no other method definition applies to the provided argument types. This behavior is often used to define a generic fallback method for a function. A typical use case is to print a warning like in the following example:\n\naddmul2(x, y) = println(\"addmul2 is not applicable to argument types ($(typeof(x)),$(typeof(y)))\")\n\naddmul2 (generic function with 3 methods)\n\n\nWe can now call addmul2 with any pair or arguments without raising an error:\n\naddmul2(1.0, \"2.0\")\n\naddmul2 is not applicable to argument types (Float64,String)\n\n\nAfter this discussion on how to define methods and functions, we will now learn how to retrieve information about them.\n\n3.2.1 Generic function objects\nIn Julia, functions are objects, just like everything else, and they can be assigned to variables, passed as function arguments, or returned as values. The function object is responsible for the bookkeeping of all the methods defined for a function. The definition of the first method for a function creates the actual function object. Every subsequent method definition adds a new method to the existing function object. It is also possible to create a function without defining any methods by specifying just an empty function block without arguments:\n\nfunction empty end\n\nempty (generic function with 0 methods)\n\n\nThis can be useful for separating interface definitions from implementations or for documentation purposes.\nA function object can be accessed interactively via its name. For example, if we type the name of the addmul2 function, we see that there are currently three methods defined:\n\naddmul2\n\naddmul2 (generic function with 3 methods)\n\n\nThe signatures of those methods can be retrieved by the methods function:\n\nmethods(addmul2)\n\n# 3 methods for generic function addmul2 from Íçü‚¶É35mMainÍçü‚¶É39m: addmul2(x::Float64, y::Float64) in Main at In[5]:1  addmul2(x::Number, y::Number) in Main at In[8]:1  addmul2(x, y) in Main at In[13]:1 \n\n\nIt also shows the file and line number where the methods were defined. As the code in this book is executed in a notebook, the line numbers correspond to the input cells.\nThe applicable function can be used to query if a function has a method that accepts a specific tuple of arguments, for example\n\napplicable(addmul2, 1.0)\n\nfalse\n\n\n\napplicable(addmul2, 1.0, 2.0)\n\ntrue\n\n\nThis function is handy for checking if a user-provided function has the correct interface, for example, the right-hand side of an ordinary differential equation in some solver package.\n\n\n3.2.2 Method ambiguities\nWhen defining functions with multiple methods, a little care is needed to avoid method ambiguities. If we define several methods with the same number of arguments, constraining some argument types but not others or constraining some to concrete types and others to abstract types, it is possible to create a situation in which Julia cannot uniquely determine which method to call for a given set of arguments. Consider the following example of a function taking two arguments:\n\niamambiguous(x::Int64, y) = 2(x + y)\niamambiguous(x, y::Int64) = 2(x + y)\n\niamambiguous (generic function with 2 methods)\n\n\nIf we call this function with an Int64 value in only one of the arguments, everything is fine:\n\niamambiguous(1, 2.0)\n\n6.0\n\n\n\niamambiguous(1.0, 2)\n\n6.0\n\n\nHowever, see what happens if we call it with two Int64 values:\n\niamambiguous(1, 2)\n\nLoadError: MethodError: iamambiguous(::Int64, ::Int64) is ambiguous.\n\nCandidates:\n  iamambiguous(x, y::Int64)\n    @ Main In[20]:2\n  iamambiguous(x::Int64, y)\n    @ Main In[20]:1\n\nPossible fix, define\n  iamambiguous(::Int64, ::Int64)\n\n\nJulia raises a MethodError as there is no unique most specific method applicable to that set of arguments. Either of the above methods could handle the function call, and neither is more specific than the other. What is nice, though, is that Julia also suggests how to fix this situation, namely by defining an additional method that takes two Int64 arguments:\n\niamnotambiguous(x::Int64, y::Int64) = 2(x + y)\niamnotambiguous(x::Int64, y) = 2(x + y)\niamnotambiguous(x, y::Int64) = 2(x + y)\niamnotambiguous(1, 2)\n\n6\n\n\nWith these definitions, there is a unique most specific method for all supported combinations of arguments. If both arguments are of type Int64, the first method is invoked. If only the first argument is of type Int64, the second method is invoked. If only the second argument is of type Int64, the third method is invoked. If none of the arguments is of type Int64, then a method error is thrown as no appropriate method has been defined.\nIf a user-defined function has ambiguous methods, the Julia coding guidelines recommend defining the disambiguating method first in order to avoid the existence of ambiguities at any time.\n\n\n3.2.3 Arbitrary numbers of arguments\nFunctions that accept a variable number of arguments are called varargs functions. Such functions are defined by appending an ellipsis to the last positional argument in a method definition:\n\nprintvarargs(x...) = println(\"$(length(x)) arguments: \", x)\n\nWe can call this method with any number of arguments or no arguments at all:\n\nprintvarargs()\n\n0 arguments: ()\n\n\n\nprintvarargs(1, 2)\n\n2 arguments: (1, 2)\n\n\nThe varargs argument can be preceded by other positional arguments, but it always has to be the last argument:\n\nprintxyz(x, y, z...) = println(\"x = $x and y = $y, and the other $(length(z)) arguments are $z\")\nprintxyz(1, 2, 3, 4)\n\nx = 1 and y = 2, and the other 2 arguments are (3, 4)\n\n\n\nprintxy(x..., y) = println(\"x = $x and y = $y\")\n\nLoadError: syntax: invalid \"...\" on non-final argument around In[29]:1\n\n\nInside the method, the varargs variable x is an iterable collection with zero or more values. Often, it is not used directly but passed on to another function in the form of single values via splatting:\n\nfunction printxyz(x, y, z...)\n    println(\"x = $x and y = $y and then we have\")\n    printvarargs(z...)\nend\nprintxyz(1, 2, 3, 4)\n\nx = 1 and y = 2 and then we have\n2 arguments: (3, 4)\n\n\nVarargs can be constrained similarly to normal arguments in type but also in number using the parametric Vararg{T,N} type. The parameter T restricts the type of possible arguments. It is Any by default but can be restricted to more specific abstract or concrete types. The parameter N denotes the number of varargs. If no restriction on the number of arguments is required, N can be omitted. Let us consider some examples. If we want to restrict the number of varargs but not their types, we can use the following syntax:\n\nprintxy(x, y::Vararg{Any,2}) = println(\"x = $x, y[1] = $(y[1]) and y[2] = $(y[2])\")\nprintxy(1,2,3)\n\nx = 1, y[1] = 2 and y[2] = 3\n\n\nThis method can only be called with exactly three arguments, no more, no less:\n\nprintxy(1,2)\n\nLoadError: MethodError: no method matching printxy(::Int64, ::Int64)\n\nClosest candidates are:\n  printxy(::Any, ::Any, ::Any)\n   @ Main In[31]:1\n\n\n\nprintxy(1,2,3,4)\n\nLoadError: MethodError: no method matching printxy(::Int64, ::Int64, ::Int64, ::Int64)\n\nClosest candidates are:\n  printxy(::Any, ::Any, ::Any)\n   @ Main In[31]:1\n\n\nIf we want to restrict the type of varargs, but not their number, we can use the following syntax:\n\nprintints(x::Vararg{Int}) = println(\"x = $x\")\nprintints(1,2,3)\n\nx = (1, 2, 3)\n\n\nThis, however, can be expressed more compactly as follows:\n\nprintints(x::Int...) = println(\"x = $x\")\n\nType decorations with the Vararg{T,N} type are most useful if the number of varargs needs to be restricted. If only type constraints need to be applied to varargs, the usual type decoration with a trailing ellipsis is shorter and easier to read. Note that no ellipsis is added if types are constrained via the Vararg{T,N} type.\n\n\n3.2.4 Optional arguments\nOften, it is desirable to specify default values for certain arguments, thus making those arguments optional. Julia supports optional arguments with the usual syntax:\n\naddmul2opt(x=1, y=2) = 2(x + y)\n\naddmul2opt (generic function with 3 methods)\n\n\nWe see that this declaration leads to the definition of three methods, namely:\n\naddmul2opt(x,y) = 2(x + y)\naddmul2opt(x) = addmul2opt(x,2)\naddmul2opt() = addmul2opt(1,2)\n\nThis implies that optional arguments are not a property of a specific function method but rather a property of the function itself.\nOptional arguments always have to follow non-optional arguments. Therefore, this definition is allowed:\n\naddmul2opt(x, y=2) = 2(x + y)\n\nWhile this definition raises an error:\n\naddmul2opt(x=1, y) = 2(x + y)\n\nLoadError: syntax: optional positional arguments must occur at end around In[39]:1\n\n\nJulia‚Äôs treatment of optional arguments involves a few potential pitfalls. In the definition above, calling addmul2opt() and calling addmul2opt(1,2) both result in 6 as addmul2opt() calls the first method with arguments (1,2). We can alter this behavior by defining an additional, more specialized method. Consider adding the following method:\n\naddmul2opt(x::Int, y::Int, z::Int = 3) = 2(x + y + z)\n\naddmul2opt (generic function with 5 methods)\n\n\n\naddmul2opt(1,2)\n\n12\n\n\n\naddmul2opt()\n\n12\n\n\nWith this additional definition, addmul2opt() and addmul2opt(1,2) still return the same result, but now it is 12 for both. That is, we changed the behavior not only of the method that takes two arguments in case these arguments are of type Int, but we also changed the behavior of the method addmul2opt() that takes no arguments. The latter acts as a relay to the method that takes two arguments, providing it with some default values. Thus, by the dynamic nature of multiple dispatch and the type of the default arguments we provided in the original definition of addmul2opt, the method addmul2opt() now relays to the new method, which is specialized to integer-valued arguments (the type of the default values).\nThe way Julia implements optional arguments can also lead to unexpected method ambiguities or the unintended override of existing methods. Consider the following definitions:\n\naddmul2amb(x::Int, y=2, z=3) = 2(x + y + z)\naddmul2amb(x, y::Float64) = 2(x + y)\naddmul2amb(1, 2.0)\n\nLoadError: MethodError: addmul2amb(::Int64, ::Float64) is ambiguous.\n\nCandidates:\n  addmul2amb(x, y::Float64)\n    @ Main In[43]:2\n  addmul2amb(x::Int64, y)\n    @ Main In[43]:1\n\nPossible fix, define\n  addmul2amb(::Int64, ::Float64)\n\n\nAmong others, the first declaration results in the following method definition:\n\naddmul2amb(x::Int, y) = addmul2amb(x, y, 3)\n\nTherefore, in the call addmul2amb(1, 2.0), no unique most specific method exists.\nSimilarly, we may get an unexpected result if we define the following methods:\n\naddmul2override(x, y) = 2(x + y)\naddmul2override(x=1, y=2, z=3) = 2(x + y + z)\naddmul2override(1, 2)\n\n12\n\n\nBy the first method definition, we would expect addmul2override(1, 2) to result in 6. Still, in practice, it results in 12, as the second declaration includes the following method definition, which, in the absence of any type constraints, overwrites the original definition of addmul2override(x, y):\n\naddmul2override(x, y) = 2(x + y + 3)\n\nWhile this behavior is entirely logical in the context of multiple dispatch, it may at first appear unintuitive. Thus, it is important to know how Julia treats optional arguments.\n\n\n3.2.5 Keyword arguments\nIf a function has a large number of arguments, it is often challenging to remember their order. Think, for example, of a plotting routine and all the arguments determining the style of the plot. It is much easier to call such a function when the individual arguments are identified by name instead of position.\nWhen defining a method, the keyword arguments are separated from the positional arguments by a semicolon:\n\nfunction plot(x, y; linewidth, markersize)\n    ###\nend\n\nWhen calling such a method, this separation is not necessary, and the semicolon is optional. Therefore, the following function calls are equivalent:\n\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = 2, markersize = 10)\nplot([0.0, 1.0], [1.0, 2.0], linewidth = 2, markersize = 10)\n\nIf we omit one of the keyword arguments, an error is raised:\n\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = 2)\n\nLoadError: UndefKeywordError: keyword argument `markersize` not assigned\n\n\nIn many cases, keyword arguments are specified with a default value, e.g.\n\nfunction plot(x, y; linewidth = 2, markersize = 10)\n    ###\nend\n\nIf this is the case, the plot function can also be called without passing any of the keyword arguments or just a subset thereof:\n\nplot([0.0, 1.0], [1.0, 2.0])\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = 1)\nplot([0.0, 1.0], [1.0, 2.0]; markersize = 5)\n\nKeyword arguments are evaluated from left to right, and default expressions can depend on keyword arguments on the left as well as positional arguments:\n\nfunction plot(x, y; linewidth = 2, markersize = 5*linewidth)\n    ###\nend\n\nIf we call a function that takes keyword arguments, the argument‚Äôs name can sometimes be inferred. If, for example, we pass an existing identifier after the semicolon, the name of the keyword argument is inferred from the name of the identifier so that the following two calls to the plot function are equivalent:\n\nlinewidth = 2\nplot([0.0, 1.0], [1.0, 2.0]; linewidth)\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = linewidth)\n\nThis even works with fields of composite types so that the following two calls to plot are also equivalent:\n\noptions = (linewidth = 2, markersize = 10)\nplot([0.0, 1.0], [1.0, 2.0]; options.linewidth)\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = options.linewidth)\n\nTo pass keywords at runtime, an expression like key =&gt; value can be used after the semicolon, where key needs to be a symbol:\n\nargname = :linewidth\nargvalue = 5\nplot([0.0, 1.0], [1.0, 2.0]; argname =&gt; argvalue)\n\nis equivalent to\n\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = 5)\n\nSimilar to positional arguments, it is possible to decorate keyword arguments with type annotations:\n\nfunction plot(x, y; linewidth::Int = 2, markersize::Int = 5*linewidth)\n    ###\nend\n\nNote, however, that, unlike positional arguments, keyword arguments do not participate in method dispatch. Instead, keyword arguments are processed only after identifying the appropriate method based on its positional arguments and their types.\nKeyword arguments can be used together with a variable number of positional arguments, and in a similar fashion, we can also have additional keyword arguments:\n\nfunction plot(args...; linestyle = :solid, kwargs...)\n    ###\nend\n\nInside the plot function, kwargs is available as a key-value iterator over a named tuple. However, this syntax is most often used to pass on keyword arguments to another function or method along the lines of the following example:\n\nfunction plot(x, y, args...; linestyle = :solid, kwargs...)\n    p = plot(x, y; kwargs...)\n    setlinestyle!(p, linestyle)\n    ###\n    return p\nend\n\nWith this syntax, a keyword argument may be provided more than once, typically when splatting varargs and explicitly providing the argument, for example:\n\noptions = (linewidth = 2, markersize = 10)\nplot([0.0, 1.0], [1.0, 2.0]; options..., linewidth = 5)\n\nIn such a case, the rightmost occurrence takes precedence. This means that in the above example linewidth = 5 is used, but if we switch the order of the arguments, the value linewidth = 2 from the options tuple is used instead:\n\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = 5, options...)\n\nKeyword arguments may only appear multiple times when all occurrences but one are implicitly specified, e.g., as elements of iterables. Explicitly specifying the same keyword argument twice or more is not allowed and results in a syntax error:\n\nplot([0.0, 1.0], [1.0, 2.0]; linewidth = 3, linewidth = 5)\n\nLoadError: syntax: keyword argument \"linewidth\" repeated in call to \"plot\" around In[62]:1\n\n\nThis concludes the discussion about passing arguments to a function. Next, we will see how to make objects callable.\n\n\n3.2.6 Functors\nFunctors are types whose objects are callable and thus behave like functions. This is easily achieved by adding methods to a special function that is identified by the type instead of a generic name:\n\nstruct Power\n    pow::Int\nend\n\nfunction (p::Power)(x)\n    x^p.pow\nend\n\np = Power(5)\np(2)\n\n32\n\n\nFunctors are helpful for implementing concise interfaces in many problems, e.g., evaluation of polynomials, integration of differential equations, transfer functions, neural network layers, and many more. Moreover, functors are at the core of type constructors and closures, as will be discussed later in this chapter.\n\n\n3.2.7 Anonymous functions and closures\nAnonymous functions are functions without an explicit name. We have already encountered them in Chapter 1, but we briefly want to discuss some technical details in light of what we have learned in this chapter.\nAnonymous functions can be created in two equivalent ways:\n\nx -&gt; cos(x)^2 + sin(x)^2\n\nfunction (x)\n    cos(x)^2 + sin(x)^2\nend\n\n#19 (generic function with 1 method)\n\n\nBoth declarations return a generic function object with a compiler-generated name based on consecutive numbering. An anonymous function that does not expect an argument can be defined by\n\n() -&gt; 42\n\n#21 (generic function with 1 method)\n\n\nOn their own, such declarations are not particularly useful as they do not provide a convenient way for calling the declared function. In order to do so, they have to be assigned to some variable, as in the following example:\n\nf = x -&gt; cos(x)^2 + sin(x)^2\n\n#23 (generic function with 1 method)\n\n\nNow, the function can be called like any other function via the variable f:\n\nf(2)\n\n1.0\n\n\nThe main use case for anonymous functions is to pass them to other functions as arguments, for example, to the map function, as we have already seen in Chapter 1:\n\nmap(x -&gt; cos(x)^2 + sin(x)^2, [1.0, 2.0, 4.0])\n\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\n\nAnother common use case for anonymous functions is closures. These are functions that refer to their surrounding environment by capturing variables.\n\ntimestep = 0.1\nnexttimestep = x -&gt; x + timestep\nnexttimestep(1.0)\n\n1.1\n\n\nA typical application of closures is the solution of a nonlinear system of equations of the form f(x) = 0, i.e., finding the roots x of f. Many nonlinear solvers expect the function to solve for to have the interface f!(y,x) computing y = f(x), so that y is the value of the function f for input x. More often than not, the function f! computing f takes additional inputs other than y and x, e.g., configuration variables, temporary arrays, or additional static inputs. To pass a function with the correct interface to the solver, a closure is usually the simplest solution, cf.¬†the following example:\n\nfunction f!(y, x, t, params)\n    ###\nend\n\nfunction solve(f, x‚ÇÄ)\n    ###\nend\n\nparameters = (œâ = 0.5, k = 2)\nt‚ÇÄ = 0.0\nx‚ÇÄ = rand(3)\n\nx = solve((y,x) -&gt; f!(y, x, t‚ÇÄ, parameters), x‚ÇÄ)\n\nHere, the function f! defines the nonlinear function whose zeros we want to determine. The first argument, y, is the value of f. The second argument, x, is the argument on which the function f is evaluted, e.g., the current state of a system of dynamical equations. The third argument, t, is an additional argument, e.g., time. The fourth argument, params, is a NamedTuple of parameters on which the function depends. The function solve performs the actual nonlinear solver step for the function f using x‚ÇÄ as an initial guess. After specifying values for the parameters, the argument t, and the initial guess for x, we call the solve method, passing as the first argument a closure with the expected interface that captures all the additional arguments of f!.\n\n\n3.2.8 Local scope\nAnonymous functions are often defined within a local scope, e.g., within another function. The same is possible with generic, named functions:\n\nfunction factory(x)\n    addmul2(y::Number) = 2(x + y)\n    addmul2(y::Int) = 2y\n    return addmul2\nend\n\nf = factory(2)\nf(2)\n\n4\n\n\n\nf(2.0)\n\n8.0\n\n\nOne should refrain from defining local methods conditionally, e.g., within an if-else clause, as this will obfuscate which method will actually be defined. Still, one can use anonymous functions in such situations.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#parametric-methods",
    "href": "content/methods-multiple-dispatch.html#parametric-methods",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "3.3 Parametric methods",
    "text": "3.3 Parametric methods\nSimilar to types, method definitions can have type parameters. These typically arise from annotating arguments with parametric types. Parametric methods allow extracting type information from arguments, dispatching on specific parameter values, and matching compatible parameters of argument types. They are expressed using the same where syntax that we have already encountered in the section on UnionAll types in the previous chapter.\nThe following method has one type parameter that is assigned to the type of its argument:\n\nprinttype(x::T) where {T} = println(T)\n\nprinttype (generic function with 1 method)\n\n\nWhen the method is called, the value of T is the type of x. Within the signature or body of a method, method parameters can be used just like any other value. Parametric methods are commonly used in Julia to extract parameter values of parametric types. The following functions return the element type and the dimension of an array, respectively:\n\neltype(::AbstractArray{T,N}) where {T,N} = T\nndims(::AbstractArray{T,N}) where {T,N} = N\n\nx = rand(3,4)\nprintln(eltype(x))\nprintln(ndims(x))\n\nThese methods have two type parameters, T and N, which are assigned to the type parameters of the parametric type AbstractArray and thus hold the values of these parameters when the methods are executed. This example allows for two interesting observations. First, if we have multiple parameters, they can be collected in braces, separated with commas, as in where {T,N} in the example. This syntax is equivalent to the nested expression where N where T. Second, if we are only interested in extracting type information, it is unnecessary to assign a variable name to the argument but only a type decorator.\nMethod parameters can also be constrained in full analogy to type parameters.\n\nisnumber(x::T) where {T &lt;: Number} = true\nisnumber(x) = false\n\nisnumber (generic function with 2 methods)\n\n\n\nisnumber(1.0)\n\ntrue\n\n\n\nisnumber(\"1.0\")\n\nfalse\n\n\nThe first method is executed if the argument is an instance of Number, and the second method is elsewise. Defining function behavior by dispatch like this is an idiomatic design pattern in Julia.\nAnother common pattern is the use of parameters for restricting the applicability of a method to compatible argument types. The following method appends an element to a vector, but only if the element type of the vector and the type of the additional value match:\n\nappend(a::Vector{T}, x::T) where {T} = [a..., x]\nappend([1,2,3], 4)\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\nIf the types do not match, a MethodError is raised as no compatible method has been defined:\n\nappend([1,2,3], 4.0)\n\nLoadError: MethodError: no method matching append(::Vector{Int64}, ::Float64)\n\nClosest candidates are:\n  append(::Vector{T}, ::T) where T\n   @ Main In[77]:1\n\n\nParametric methods are a truly powerful paradigm, facilitating general code while at the same time guaranteeing correct behavior, e.g., by restricting arguments to compatible types and facilitating lean implementations of function behavior by dispatch.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#constructors",
    "href": "content/methods-multiple-dispatch.html#constructors",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "3.4 Constructors",
    "text": "3.4 Constructors\nNow that we have learned the inners of functions and methods, it is time to discuss constructors in more detail. Constructors are functions that create new instances of composite types. They are invoked by applying the type name like a function. Being a function, the behavior of a constructor is defined by its method.\nWe mentioned in the previous chapter that two default constructors are provided for composite types. Both take as many arguments as the type has fields, but one requires the type of each argument to match the exact type of the corresponding field, while the other accepts arguments of any type and tries to convert the arguments to the correct field types. Of course, no conversion is required if no type restrictions are applied.\nOften, these default constructors are all that is needed, but sometimes we need the constructor to do more than assign values to an object‚Äôs fields. Typical examples include verifying or enforcing specific properties of the field values, so-called invariants, e.g., the positivity of a float, convenience constructors that compute some or all of the field values on the fly, or the initialization of recursive data structures. In such cases, we need to implement custom constructors.\nThere are two types of constructors, outer and inner constructors, whose differences and different purposes we will discuss in the following. After that, we will elaborate on the specifics of parametric constructors and incomplete initialization.\n\n3.4.1 Outer constructor methods\nThe purpose of outer constructors is primarily to add functionality for object creation, such as convenience methods that compute the values for a struct‚Äôs fields from some input parameters.\nFor example, consider a struct holding temporary arrays for a Newton solver that solves a nonlinear equation of the form y = f(x) with x \\in \\mathbb{R}^n and y \\in \\mathbb{R}^m. The struct needs to store vectors for x and y and a matrix for the Jacobian j = df/dx with j \\in \\mathbb{R}^m \\times \\mathbb{R}^n:\n\nstruct NewtonSolver{T}\n    x::Vector{T}\n    y::Vector{T}\n    j::Matrix{T}\nend\n\nThe default constructors expect three arrays for x, y, and j. However, we typically want to initialize this structure by providing only vectors for x and y. There is no need to initialize j to specific values, and its size can be inferred from the sizes of x and y. To be able to construct a NewtonSolver just from x and y, we need to add a convenience constructor:\n\nfunction NewtonSolver(x::Vector{T}, y::Vector{T}) where {T}\n    NewtonSolver(zero(x), zero(y), zero(y * x'))\nend\n\nx = rand(3)\ny = rand(4)\ns = NewtonSolver(x, y)\n\nNewtonSolver{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])\n\n\nThis method calls one of the default constructors with the three arrays it expects. Similarly, we could add a constructor that takes a datatype and the vector lengths m and n and creates all arrays from scratch:\n\nfunction NewtonSolver(::Type{T}, n::Int, m::Int) where {T}\n    x = zeros(T, n)\n    y = zeros(T, m)\n    j = zeros(T, m, n)\n    NewtonSolver(x, y, j)\nend\nNewtonSolver(Float64, 3, 4)\n\nNewtonSolver{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])\n\n\nWe may also want to add an additional constructor that assumes Float64 as the default data type:\n\nNewtonSolver(n, m) = NewtonSolver(Float64, n, m)\nNewtonSolver(3, 4)\n\nNewtonSolver{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])\n\n\nThe above constructor methods are called outer constructors as they are defined outside a type definition like regular methods. They are limited in that they can only create a new instance by calling another inner constructor method, either the automatically provided or a custom one. Thus, they are also not suited to enforce invariants or to construct self-referential objects. To achieve these tasks, we need custom inner constructor methods.\n\n\n3.4.2 Inner constructor methods\nAs the name suggests, inner constructor methods are defined within a type declaration. In contrast to outer constructors, they have access to a function called new that creates an instance of the respective type. If an inner constructor is defined, it is assumed that we want to override the default behavior, and therefore no default constructor method is provided.\nConsider a simple example of a type that stores two values and expects one to be larger than the other. We can enforce this invariant by adding an appropriate @assert statement in a custom inner constructor:\n\nstruct GreaterThanFooBar\n    foo\n    bar\n    function GreaterThanFooBar(foo, bar)\n        @assert bar &gt; foo\n        new(foo, bar)\n    end\nend\n\nThe name of the inner constructor has to match the type‚Äôs name. If we try to instantiate this type with incompatible arguments, an AssertionError is raised:\n\nGreaterThanFooBar(1.0, 2.0)\n\nGreaterThanFooBar(1.0, 2.0)\n\n\n\nGreaterThanFooBar(2.0, 1.0)\n\nLoadError: AssertionError: bar &gt; foo\n\n\nNote that invariants can only be enforced for immutable types, as the fields of mutable types can be altered at any time after instantiation.\nWe could also add assertions like the above into an outer constructor. However, that would not guarantee that they are indeed always satisfied, as we could directly call one of the default inner constructors unaware of these constraints. As only inner constructors can create an instance of an object, only therein can constraints be enforced.\nThe Julia coding guidelines suggest defining as few inner constructor methods as possible, namely those that explicitly take values for all fields, perform essential error checking, and enforce invariants. Convenience constructors that supply default values or compute initial data for the fields of a type should be implemented as outer constructors that call the inner constructors, which take care of consistency checks and instantiation.\n\n\n3.4.3 Parametric constructor methods\nConstructors for parametric composite types have a few twists. With the default constructors, type parameters can either be provided explicitly or inferred from the types of the arguments. Recall the ParametricFooBar type from the previous chapter:\n\nstruct ParametricFooBar{T}\n    foo::T\n    bar::T\nend\n\nIt can be instantiated with an explicit value for T or with an implied value:\n\nParametricFooBar{Float64}(23, 42)\n\nParametricFooBar{Float64}(23.0, 42.0)\n\n\n\nParametricFooBar(23, 42)\n\nParametricFooBar{Int64}(23, 42)\n\n\nIn the first example, the arguments are converted to the provided type. In the second example, the type parameter is implied by the type of the arguments. For this to work, the types of both arguments must agree. Otherwise, the type parameter cannot be inferred:\n\nParametricFooBar(23.0, 42)\n\nLoadError: MethodError: no method matching ParametricFooBar(::Float64, ::Int64)\n\nClosest candidates are:\n  ParametricFooBar(::T, ::T) where T\n   @ Main In[86]:2\n\n\nFor parametric types, Julia provides an inner default constructor, which expects the type parameters to be provided, as well as an outer default constructor, which infers the parameter and passes it on to the inner constructor. These default constructors are equivalent to the following explicit definitions:\n\nstruct ParametricFooBar{T}\n    foo::T\n    bar::T\n    ParametricFooBar{T}(foo, bar) where {T} = new(foo, bar)\nend\nParametricFooBar(foo::T, bar::T) where {T} = ParametricFooBar{T}(foo, bar)\n\nNote that the outer constructor expects both arguments‚Äô values to be of the same type.\nThe inner constructor ParametricFooBar{T} constitutes a different function for each value of T, just like the parametric type ParametricFooBar{T} constitutes a concrete type for each value of T. This is to say that, e.g., ParametricFooBar{Float64} and ParametricFooBar{Float32} are different constructor functions and not different methods of the same function. Each function, such as ParametricFooBar{Float64}, behaves like a non-parametric default inner constructor.\nIt is also possible to define inner constructors that infer the type parameters. Let us reconsider our NewtonSolver above. It would make sense to add an inner constructor that ensures that all arrays are of compatible size:\n\nstruct NewtonSolverStrict{T}\n    x::Vector{T}\n    y::Vector{T}\n    j::Matrix{T}\n\n    function NewtonSolverStrict(x::Vector{T}, y::Vector{T}, j::Matrix{T}) where {T}\n        @assert axes(j,1) == axes(y,1)\n        @assert axes(j,2) == axes(x,1)\n        new{T}(x, y, j)\n    end\nend\n\nNewtonSolverStrict(zeros(3), zeros(4), zeros(4,3))\n\nNewtonSolverStrict{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])\n\n\nThis constructor infers the type of the arrays and passes it on to new as a parameter. As this constructor prevents the generation of default constructors, the type parameter T cannot be set manually.\n\n\n3.4.4 Incomplete initialization\nThere is one more point we touched upon but did not yet discuss in detail, namely the construction of self-referential objects, or more generally, recursive data structures.\nConsider the following type that is supposed to store a reference to a value of itself:\n\nstruct MeMyselfAndI\n    ref::MeMyselfAndI\nend\n\nThis definition may seem innocent but try to instantiate an object of this type. You will quickly realize that you are facing a chicken and egg problem: in order to call the constructor of this type, you need to provide a value of the same type, but where does that very first instance come from?\nThis problem can only be solved by making the type mutable and allowing for incomplete initialization so that we can create a MeMyselfAndI instance whose ref field does not refer to any value. The incomplete MeMyselfAndI instance can then be used to initialize another instance or set the reference to itself. We achieve this by calling the new function with fewer arguments than the number of fields in the type:\n\nmutable struct MeMyselfAndI\n    ref::MeMyselfAndI\n    MeMyselfAndI() = (m = new(); m.ref = m)\n    MeMyselfAndI(m::MeMyselfAndI) = new(m)\nend\n\nThe first constructor creates an instance whose ref field is uninitialized, assigns a reference to itself, and returns the fully initialized object. The second constructor behaves like the default constructor, which was not provided automatically due to the definition of the first constructor. Let us do some quick experiments with this type:\n\nm = MeMyselfAndI()\n\nMeMyselfAndI(MeMyselfAndI(#= circular reference @-1 =#))\n\n\n\nm === m.ref === m.ref.ref\n\ntrue\n\n\n\nMeMyselfAndI(m).ref === m\n\ntrue\n\n\nWe observe the expected behavior. Note Julia remarking that we have defined a circular reference.\nInner constructors can also return objects with uninitialized fields, although this is not encouraged. Accessing an uninitialized field results in an immediate error.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#generic-code-and-specialization",
    "href": "content/methods-multiple-dispatch.html#generic-code-and-specialization",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "3.5 Generic code and specialization",
    "text": "3.5 Generic code and specialization",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#coding-guidelines",
    "href": "content/methods-multiple-dispatch.html#coding-guidelines",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "3.6 Coding guidelines",
    "text": "3.6 Coding guidelines",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#case-study-dispatch-on-empty-types",
    "href": "content/methods-multiple-dispatch.html#case-study-dispatch-on-empty-types",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "3.7 Case study: dispatch on empty types",
    "text": "3.7 Case study: dispatch on empty types",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/methods-multiple-dispatch.html#summary",
    "href": "content/methods-multiple-dispatch.html#summary",
    "title": "3¬† Methods & Multiple Dispatch",
    "section": "3.8 Summary",
    "text": "3.8 Summary\nIn this chapter, we learned the inner workings of functions and methods in Julia. We explored the concept of multiple dispatch and put it in perspective to single dispatch in traditional class-based object-oriented (CBOO) programming languages. We discussed why Julia is an object-oriented language although it is not class-based, even in a purer sense than many traditional object-oriented languages like C++ or Java.\nWe learned all the details of defining functions and methods with positional arguments, keyword arguments, arbitrary numbers of arguments, arguments with and without default values, and how to define parametric functions, anonymous functions, closures, and functors. In light of this new knowledge, we revisited constructors, in particular the differences between inner and outer constructors, and how to achieve intricate tasks like enforcing invariants or the construction of self-referential objects.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Methods & Multiple Dispatch</span>"
    ]
  },
  {
    "objectID": "content/arrays.html",
    "href": "content/arrays.html",
    "title": "4¬† Working with Arrays",
    "section": "",
    "text": "4.1 Vectors, matrices, arrays\nAn array is a collection of data that is organized in an n-dimensional grid. The data at each grid point is often given by numbers, such as Float64 or Int64, but Julia arrays can hold any data type. The simplest instances of an array are the one-dimensional kind known as vector and the two-dimensional kind known as matrix. These are the typical objects that are manipulated in linear algebra. However, in scientific computing we often also need higher-dimensional arrays, for example to represent data on a three- or higher-dimensional mesh. In the following, we will discuss the various ways to create arrays before discussing Julia‚Äôs array type in a little more detail.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "content/arrays.html#vectors-matrices-arrays",
    "href": "content/arrays.html#vectors-matrices-arrays",
    "title": "4¬† Working with Arrays",
    "section": "",
    "text": "4.1.1 Array literals\nIn Julia, arrays can be generated much like tuples, but replacing the brackets (,) with square brackets [,]:\n\n[0.0, 23.0, 42.0]\n\n3-element Vector{Float64}:\n  0.0\n 23.0\n 42.0\n\n\nThis creates a Vector whose elements are all of type Float64 as indicated in the output. An array can also have elements of different types as in the following example:\n\n[0.0, \"hello\", 6*7]\n\n3-element Vector{Any}:\n  0.0\n   \"hello\"\n 42\n\n\nThis creates a vector with elements of type Any. When an array is initialized with values of different types, Julia tries to promote all values to a common type. If this is not possible due to a lack of appropriate promotion rules, the element type of the array is determined to be Any. The topic of promotion will be discussed in more detail in Chapter 5.\n\nJulia arrays are largely implemented in Julia itself. High performance is achieved through the specialization of code to the specific element type by the compiler. Note, however, that the generation of high-performance code is only possible for arrays with concrete element types such as Float64 or Int64, but not for arrays with abstract types such as Real or Any.\n\nIn the last example, we initialize the array with a Float64, a String, and an Integer. While Float64 and Integer can be promoted to Float64, numbers and strings cannot be promoted to a common type, thus the element type of the array is Any. The situation is slightly different if we initialize the array with values of different number types:\n\n[0.0, 460//20, 6*7]\n\n3-element Vector{Float64}:\n  0.0\n 23.0\n 42.0\n\n\nHere, we initialize the array with a Float64, a Rational, and an Integer, all of which can be promoted to Float64.\n\nNote that promotion usually applies conversion to a type that can faithfully represent all of the original values but not always. A typical example is the promotion of a Rational and some AbstractFloat, where truncation can happen as in the following example:\n\n[1.0f0, 2//3]\n\n2-element Vector{Float32}:\n 1.0\n 0.6666667\n\n\n\nIt is also possible to specify the element type explicitly:\n\nRational[1.0f0, 2//3]\n\n2-element Vector{Rational}:\n  1\n 2//3\n\n\nIf an empty array is constructed, it is of type Any by default.\n\n[]\n\nAny[]\n\n\nArrays with more dimensions than a vector, such as a matrix, can be generated with different literals. The simplest and most visual way to create a matrix is as follows:\n\n[1 2\n 3 4]\n\n2√ó2 Matrix{Int64}:\n 1  2\n 3  4\n\n\nIt is also possible to concatenate two or more vectors, higher-dimensional arrays or scalars. Concatenation is denoted by newlines or single semicolons for vertical concatenation, and spaces, tabs or double semicolons for horizontal concatenation:\n\n[[1,2] [3,4]]\n\n2√ó2 Matrix{Int64}:\n 1  3\n 2  4\n\n\n\n[[1,2];; [3,4]]\n\n2√ó2 Matrix{Int64}:\n 1  3\n 2  4\n\n\n\n[[1,2]\n [3,4]]\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\n[1; 2; 3; 4]\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\n[1;; 2;; 3;; 4]\n\n1√ó4 Matrix{Int64}:\n 1  2  3  4\n\n\n\n[1  2  3  4]\n\n1√ó4 Matrix{Int64}:\n 1  2  3  4\n\n\nThe semicolon notation is the most versatile as it applies to arbitrary-dimensional arrays. A single ; concatenates the first dimension, two ;; concatenates the second dimension, and so on.\n\n\n4.1.2 Convenience constructors\nJulia provides several functions that simplify the generation of arrays, e.g., with typical initial values, such as zeros, ones, or other scalars, random numbers, ranges, or concatenations of existing arrays.\nThe functions zeros(dims...) and ones(dims...) generate arrays that are pre-filled with the respective values:\n\nzeros(3)\n\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\n\n\nones(2, 2)\n\n2√ó2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n\n\nThey can be called with an arbitrary number of lengths per dimension and they also allow to specify a number type T as the first argument in zeros(T, dims...) and ones(T, dims...):\n\nones(Int, 2, 2)\n\n2√ó2 Matrix{Int64}:\n 1  1\n 1  1\n\n\nSimilarly, fill(x, dims...) can be used to generate any array with dimensions dims that has x set to all its values:\n\nfill(œÄ, 2, 2)\n\n2√ó2 Matrix{Irrational{:œÄ}}:\n œÄ  œÄ\n œÄ  œÄ\n\n\nThe functions rand(T, dims...) and randn(T, dims...) provide arras prefilled with uniformly distributed or normally distributed random values, respectively:\n\nrand(Float32, 2, 2)\n\n2√ó2 Matrix{Float32}:\n 0.993133  0.437135\n 0.64229   0.890833\n\n\nAs with zeros and ones, the type parameter T can be omitted:\n\nrandn(2, 2)\n\n2√ó2 Matrix{Float64}:\n 1.15147  -1.37344\n 0.5068    0.781393\n\n\nIf an array shall be initialized not with constant or random values but with a range of values, the function range(start, stop, n) can be used:\n\nrange(1, 2, 11)\n\n1.0:0.1:2.0\n\n\nThis command does not actually construct an array but a generator for an array. To obtain the corresponding array, we need to apply the collect function or enclose the expression followed by ; in square brackets:\n\ncollect(range(1, 2, 3))\n\n3-element Vector{Float64}:\n 1.0\n 1.5\n 2.0\n\n\n\n[range(1, 2, 3);]\n\n3-element Vector{Float64}:\n 1.0\n 1.5\n 2.0\n\n\nNew arrays can also be created from existing ones by concatenation via cat(A...; dims), hcat(A...), and vcat(A...), where A is a list of arrays and dims are the dimensions along which to concatenate:\n\ncat(ones(2, 2), zeros(2, 2); dims=1)\n\n4√ó2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n 0.0  0.0\n 0.0  0.0\n\n\n\ncat(ones(2, 2), zeros(2, 2); dims=2)\n\n2√ó4 Matrix{Float64}:\n 1.0  1.0  0.0  0.0\n 1.0  1.0  0.0  0.0\n\n\n\ncat(ones(2, 2), fill(2.0, 2, 2); dims=(1,2))\n\n4√ó4 Matrix{Float64}:\n 1.0  1.0  0.0  0.0\n 1.0  1.0  0.0  0.0\n 0.0  0.0  2.0  2.0\n 0.0  0.0  2.0  2.0\n\n\nThe command vcat(A...) is the same as cat(A...; dims=1) or [a; b; c] if A = (a,b,c). Similarly, hcat(A...) is the same as cat(A...; dims=2) or [a b c] or [a;; b;; c].\nJulia also supports zero-dimensional array, which can be created by omitting the dimensional arguments to zeros, ones or fill:\n\nzeros()\n\n0-dimensional Array{Float64, 0}:\n0.0\n\n\n\nfill(3)\n\n0-dimensional Array{Int64, 0}:\n3\n\n\nNext, we will see how to generate arrays whose values are initialized by evaluating a formula or a function.\n\n\n4.1.3 Comprehensions and generators\nComprehensions allow for the initialization of arrays with the result of arbitrarily complex expressions that are evaluated on a range of values for each of their arguments. Two simple examples of a one- and a two-dimensional array are the following:\n\n[ x^2 for x in 1:3 ]\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\n\n[ cos(œÄ*x) * sin(œÄ*y) for x in 0:1//2:1, y in 0:1//2:2 ]\n\n3√ó5 Matrix{Float64}:\n  0.0   1.0           1.22465e-16  -1.0          -2.44929e-16\n  0.0   6.12323e-17   7.4988e-33   -6.12323e-17  -1.49976e-32\n -0.0  -1.0          -1.22465e-16   1.0           2.44929e-16\n\n\nThe dimension and size of the resulting array depend on the number of arguments and elements in the respective ranges. The element type depends on the result of the expression. Should the expression return values of different types depending on its input values, Julia tries to promote them to a common type in the same way as with array literals. Similarly, the element type can also be specified explicitly:\n\nFloat32[ x^2 for x in 1:3 ]\n\n3-element Vector{Float32}:\n 1.0\n 4.0\n 9.0\n\n\nIf the square brackets are replaced with normal brackets, a comprehension returns a generator, similar to the range command in the previous section:\n\n(x^2 for x in 1:3)\n\nBase.Generator{UnitRange{Int64}, var\"#15#16\"}(var\"#15#16\"(), 1:3)\n\n\nGenerators are objects that do not precompute their return values but can be evaluated on demand. When we enclose a generator in square brackets or pass it to collect, it is evaluated on all specified values for its arguments and the result is written into an array of the appropriate dimension.\n\n\n4.1.4 Basic linear algebra\nJulia comes with a comprehensive library of linear algebra operations. While some are defined in Base, most are contained in the LinearAlgebra module of the standard library.\nLet us also define some example vectors x and y and a matrix A that we will use repeatedly in the examples:\n\nx = [3, 2, 1]; y = [1, 2, 3]; A = [1 2 3; 2 1 0; 3 0 1];\n\nThe standard multiplication operator * denotes vector-vector, matrix-vector, matrix-matrix, etc., multiplication:\n\nA * x\n\n3-element Vector{Int64}:\n 10\n  8\n 10\n\n\nIf the size of the arrays does not match, this operation will not be successful:\n\nx * y\n\nLoadError: MethodError: no method matching *(::Vector{Int64}, ::Vector{Int64})\n\nClosest candidates are:\n  *(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:587\n  *(::SparseArrays.CHOLMOD.Sparse, ::VecOrMat)\n   @ SparseArrays /Applications/Julia-1.10.app/Contents/Resources/julia/share/julia/stdlib/v1.10/SparseArrays/src/solvers/cholmod.jl:1218\n  *(::LinearAlgebra.UniformScaling, ::AbstractVecOrMat)\n   @ LinearAlgebra /Applications/Julia-1.10.app/Contents/Resources/julia/share/julia/stdlib/v1.10/LinearAlgebra/src/uniformscaling.jl:262\n  ...\n\n\nThus, to compute the scalar product of two vectors, the left vector needs to be transposed, which can be achieved by appending the adjoint operator ' to the vector:\n\nx' * y\n\n10\n\n\nThis is not the same as taking the adjoint of the right vector:\n\nx * y'\n\n3√ó3 Matrix{Int64}:\n 3  6  9\n 2  4  6\n 1  2  3\n\n\n\nNote that the adjoint operator does not only transpose the array but also applies complex conjugation in the case of complex-valued arrays. For real-valued arrays, this does not make a difference. However, if strict transposition is desired, the transpose command can be used instead of the adjoint operator or the adjoint command.\n\nThe following examples require to load the LinearAlgebra module:\n\nusing LinearAlgebra\n\nThe scalar product can also be computed with the ‚ãÖ operator (typed \\cdot followed by &lt;tab&gt;):\n\nx ‚ãÖ y\n\n10\n\n\nSimilarly, the cross product of two vectors can be computed with √ó (types \\times followed by &lt;tab&gt;):\n\nx √ó y\n\n3-element Vector{Int64}:\n  4\n -8\n  4\n\n\nThe LinearAlgebra module includes many standard operations such as det, tr, inv, eigvals, and eigvecs for the determinant of a matrix, its trace, its inverse, its eigenvalues and eigenvectors, respectively. It allows to solve linear systems with the \\ operator:\n\nA \\ x\n\n3-element Vector{Float64}:\n  0.3333333333333333\n  1.3333333333333335\n -1.1102230246251565e-16\n\n\nThe LinearAlgebra module also provides special matrix types, such as the identity matrix, symmetric and Hermitian matrices, and contains a broad selection of methods for matrix factorization and the solution of linear systems. Many of the operations are also provided as in-place variants. For a detailed overview of the available methods, please see the section on the Linear Algebra module of the Standard Library in the Julia manual.\n\n\n4.1.5 Element-wise operations and vectorization\nAll of the above operations acted on vectors and matrices as a whole. If instead an operation should be applied element-wise, the dot syntax can be used, e.g.:\n\nx .* y\n\n3-element Vector{Int64}:\n 3\n 4\n 3\n\n\nThis is often referred to as vectorization or broadcasting, a topic that we will discuss in more detail later in this chapter. The dot syntax can be applied to arithmetic operators, such as -, +, *, /, and ^, to comparison operators, such as ==, !=, ‚âà, and ‚ââ, as well as to general scalar operations, such as cos, sin, exp, or abs:\n\ncos.(A)\n\n3√ó3 Matrix{Float64}:\n  0.540302  -0.416147  -0.989992\n -0.416147   0.540302   1.0\n -0.989992   1.0        0.540302\n\n\nIf a composition of operations shall be applied, they can be fused by using several . operations:\n\nacos.(cos.(A ./ 2))\n\n3√ó3 Matrix{Float64}:\n 0.5  1.0  1.5\n 1.0  0.5  0.0\n 1.5  0.0  0.5\n\n\nIf a composition is more complicated or has many elements, it is often easier to precede the corresponding expression with the @. macro, which applies broadcasting to every function call in the expression, instead of applying the dot syntax to each single function call manually:\n\n@. acos(cos(A / 2))\n\n3√ó3 Matrix{Float64}:\n 0.5  1.0  1.5\n 1.0  0.5  0.0\n 1.5  0.0  0.5\n\n\nIn the next section, we will have a brief look at Julia‚Äôs standard Array type.\n\n\n4.1.6 The array type\nIn the examples above, we have seen many objects whose types were indicated as Vector or Matrix. These are not actual types but merely aliases to the generic array type Array{T,N} with the dimension type parameter N set to 1 or 2, respectively:\n\nVector{T} = Array{T,1}\nMatrix{T} = Array{T,2}\n\nThe other type parameter, T, denotes the element type. Thus, a Vector{Int64} is an Array{Int64,1} and a Matrix{Float64} is an Array{Float64,2} as Julia is not too shy to tell us:\n\nVector{Int64}\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\nMatrix{Float64}\n\nMatrix{Float64} (alias for Array{Float64, 2})\n\n\nAside from literals and all the convenience constructors we have seen, we can also create uninitialized arrays using the default constructor, Array{T}(undef, dims...), where the first argument undef refers to the UndefInitializer and dims correspond to the size of each dimension:\n\nv = Vector{Int64}(undef, 2)\n\n2-element Vector{Int64}:\n 4496736976\n 5206595632\n\n\n\nw = Array{Float64,2}(undef, 2, 4)\n\n2√ó4 Matrix{Float64}:\n 5.0e-324  NaN         2.5e-323    3.5e-323\n 1.0e-323    2.0e-323  3.0e-323  NaN\n\n\nJulia provides several functions to retrieve information about an array, for example, ndims for the number of dimensions, length for the number of elements, and size for the sizes of each dimension:\n\nndims(w)\n\n2\n\n\n\nlength(w)\n\n8\n\n\n\nsize(w)\n\n(2, 4)\n\n\n\nsize(w, 1)\n\n2\n\n\nThe axes function returns the index ranges for each dimension:\n\naxes(w)\n\n(Base.OneTo(2), Base.OneTo(4))\n\n\n\naxes(w, 1)\n\nBase.OneTo(2)\n\n\nWe will use the axes function later on when discussing how to iterate over arrays. Another useful function is eltype which returns the type of an array‚Äôs elements:\n\neltype(w)\n\nFloat64\n\n\nAs the Array type is parametric, with the element type and dimension as type parameters, it is concrete only when all its type parameters are specified. This is of particular importance when arrays serve as fields in composite types.\n\n\n4.1.7 Arrays as fields in composite types\nWhen directly accessing fields of a composite type in a performance-critical part of the code, most prominently from within a loop, it is crucial for the types of those fields to be fully specified. For a scalar number, it suffices to provide the number type, but for arrays both the element type and the dimension have to be specified:\n\nstruct MyTypedType\n    x::Float64\n    A::Vector{Float64}\nend\n\nLet us define a simple function that operates on this type by multiplying the scalar x with each element of A and summing the result:\n\nfunction scaledsum(m)\n    s = zero(m.x)\n    for a in m.A\n        s += m.x * a\n    end\nend\n\nscaledsum (generic function with 1 method)\n\n\nNow check the runtime and allocations with the @btime macro from the BenchmarkTools.jl package:\n\nm = MyTypedType(3.0, rand(100))\n@btime scaledsum(m);\n\n  32.737 ns (0 allocations: 0 bytes)\n\n\nEverything seems fine: the runtime is very short and there are no allocations. This changes if we do not specify concrete types for the fields in our type:\n\nstruct MyUntypedType\n    x::Real\n    A::Vector\nend\nm = MyUntypedType(3.0, rand(100))\n@btime scaledsum(m);\n\n  9.375 Œºs (300 allocations: 4.69 KiB)\n\n\nThe runtime increases by a large factor and we observe a similarly large number of allocations for temporary data structures. With the types not specified, Julia needs to create boilerplate code that wraps the fields of our composite type and prevents the generation of optimized and efficient code.\nEven though MyTypedType prevents these issues, in practice, its implementation is not ideal as it specifies x as well as the elements of A to be of type Float64. This is very specific, limiting the reusability of this type. For example, we cannot use it for solving a problem on GPUs that only support Float32 values. This problem can easily be avoided by adding a type parameter similar to the Array type:\n\nstruct MyType{T}\n    x::T\n    A::Vector{T}\nend\n\nWith this, we get both efficient and general code:\n\nm = MyType(3.0f0, rand(Float32, 100))\n@btime scaledsum(m);\n\n  12.012 ns (0 allocations: 0 bytes)\n\n\nNote that for simple types like this, the default constructor is able to figure out the type parameters and there is no need to provide custom constructors. This may be different in more complex composite types.\nWhile the definition of MyType{T} is a typical design pattern in Julia, it can be overkill in some situations. There is no strict need to specify all the types of a composite type‚Äôs fields if they are never directly accessed in computation-heavy code. The fields could be passed individually to computational functions instead. This is often referred to as a function call barrier. When a function is called, Julia generates and compiles optimized code for the specific types of the arguments, but only if they can be uniquely determined. If we pass an instance of MyUntypedType Julia cannot uniquely determine the types of its fields. However, if we pass its fields x and A individually to a function, Julia can figure out their types and generate efficient code.\nTo this end, we need to implement a second scaledsum method, that takes a scalar and an array instead of a composite type that holds these two values:\n\nfunction scaledsum(x, A)\n    s = zero(x)\n    for a in A\n        s += x * a\n    end\nend\n\nscaledsum (generic function with 2 methods)\n\n\nIf we call this on the fields of MyUntypedType instead of a MyUntypedType value directly, we still obtain good performance without unnecessary allocations:\n\nm = MyUntypedType(3.0, rand(100))\n@btime scaledsum(m.x, m.A);\n\n  43.180 ns (0 allocations: 0 bytes)\n\n\nNote, however, that there is still some overhead for extracting the field values from the object:\n\nm = MyUntypedType(3.0, rand(100))\nx = m.x\nA = m.A\n@btime scaledsum(x, A);\n\n  11.678 ns (0 allocations: 0 bytes)\n\n\nWhich of the two approaches is more appropriate depends very much on the problem at hand. If a function operates on many fields of a complex composite type, passing all the fields individually seems unpractical and will often result in code that is hard to read. On the other hand, composite types with a substantial number of fields, which may be of parametric types themselves, can easily require a large number of type parameters making the type hard to understand and its handling unnecessarily complicated.\nThis concludes the section on how arrays are created and handled. Next, we discuss the various ways of indexing arrays, looping over their elements, and applying maps to the elements of an array.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "content/arrays.html#indexing",
    "href": "content/arrays.html#indexing",
    "title": "4¬† Working with Arrays",
    "section": "4.2 Indexing",
    "text": "4.2 Indexing\nIn this section, we will discuss the different ways of indexing arrays, cartesian indexing and linear indexing, how to assign values, and how to generate views instead of copies when accessing array elements.\n\n4.2.1 Basic indexing\nBasic array indexing works the same way as for tuples and other collections using square bracket notation:\n\na = collect(1:10)\na[3]\n\n3\n\n\nIndex ranges are specified the same as standard ranges:\n\na[4:6]\n\n3-element Vector{Int64}:\n 4\n 5\n 6\n\n\n\na[1:3:9]\n\n3-element Vector{Int64}:\n 1\n 4\n 7\n\n\nJulia supports two keywords for denoting the first and last element of an array, namely begin and end:\n\na[begin], a[end]\n\n(1, 10)\n\n\nThe begin and end keywords also allow for index arithmetics:\n\na[begin+2], a[end-2]\n\n(3, 8)\n\n\nA zero-dimensional array is indexed by empty square brackets:\n\nz = fill(œÄ)\nz[]\n\nœÄ = 3.1415926535897...\n\n\nNote that in this example c refers to the array object and c[] to the value of its only element. We can also use logical expressions to index an array:\n\na[a .% 3 .== 0]\n\n3-element Vector{Int64}:\n 3\n 6\n 9\n\n\nHere, the index corresponds to a bit mask, which is an array of the same size as a that contains either true for those indices whose values should be returned, or false for those values that should be omitted.\n\n\n4.2.2 Cartesian indexing\nThese were just the most basic examples of indexing a vector. In general, an n-dimensional array A is indexed using cartesian indexing via:\n\nA[I_1, I_2, ..., I_n]\n\nWe have to provide a separate set of indices I_k for each dimension. Each I_k can be any type of supported indices, e.g., a scalar integer, an array of integers or booleans, a range, a CartesianIndex{N}, an array thereof, a colon :, representing all indices of the respective dimension, or the aforementioned keywords begin and end. Let us consider some examples:\n\nb = reshape(a, (2,5))\n\n2√ó5 Matrix{Int64}:\n 1  3  5  7   9\n 2  4  6  8  10\n\n\n\nb[:, 3]\n\n2-element Vector{Int64}:\n 5\n 6\n\n\n\nb[1:1, 2:4]\n\n1√ó3 Matrix{Int64}:\n 3  5  7\n\n\n\nb[2, [2,4]]\n\n2-element Vector{Int64}:\n 4\n 8\n\n\n\nb[[2], [2,4]]\n\n1√ó2 Matrix{Int64}:\n 4  8\n\n\n\nb[(1, 2:4)...]\n\n3-element Vector{Int64}:\n 3\n 5\n 7\n\n\nIn the last example, we used tuple unpacking. This can be useful if indices are provided programmatically. The same is true for the CartesianIndex{N} object. It represents a multidimensional index containing N scalar indices and behaves similarly to an N-tuple. It can be used to index any number of dimensions in an array. As an example, let us consider a three-dimensional array:\n\nc = collect(reshape(1:27, (3,3,3)));\n\nWe can use a CartesianIndex to index each dimension individually, like with scalar indices:\n\nc[CartesianIndex(1), CartesianIndex(2), CartesianIndex(3)]\n\n22\n\n\nWe can also use a CartesianIndex to index all dimensions at once:\n\nc[CartesianIndex(1,2,3)]\n\n22\n\n\nBut we can also use cartesian indices to index any subset of dimensions:\n\nc[1, CartesianIndex(2,3)] == c[CartesianIndex(1,2), 3] == 22\n\ntrue\n\n\nAs we will see in the next section on looping and mapping, Julia uses CartesianIndex internally when iterating over arrays, but it can also be beneficial to use CartesianIndex programmatically. For example, we can use an array of CartesianIndex to index another array, e.g., to extract the diagonal elements of an array:\n\nc[[CartesianIndex(i,i,i) for i in 1:3]]\n\n3-element Vector{Int64}:\n  1\n 14\n 27\n\n\nIn all of the examples, we have seen so far, we provided separate indices for each dimension, which is referred to as cartesian indexing.\n\nNote that arrays can be indexed with more indices than they have dimensions, but the index in the additional dimensions can only take the value 1:\n\nc[1,2,3,1,1]\n\n22\n\n\nOn the other hand, it is not allowed to omit indices, i.e., to specify only two indices of a three-dimensional array:\n\nc[1,2]\n\nLoadError: BoundsError: attempt to access 3√ó3√ó3 Array{Int64, 3} at index [1, 2]\n\n\nThere is only one exception: omitting trailing dimensions of length 1:\n\nd = collect(reshape(1:6, (2,3,1)))\nd[1,2]\n\n3\n\n\n\nJulia also supports an alternative way of indexing arrays: linear indexing. This is discussed in the next section.\n\n\n4.2.3 Linear indexing\nMultidimensional arrays can also be indexed by just one index. This is referred to as linear indexing. In memory, arrays are stored as a linear sequence of elements. Different programming languages use a different ordering for these elements. For example, C, C++ and Python use so-called row-major ordering, where matrices are stored row-by-row, whereas Fortran, Julia, Matlab and R use so-called column-major ordering, where matrices are stored column-by-column, and higher-dimensional arrays accordingly.\n\n\n\nMemory layout: row-major (top) vs.¬†column-major (bottom).\n\n\nWith linear indexing, the index corresponds to the position of an element in memory when the array is viewed as a one-dimensional object, such as if the array had been reshaped into a vector:\n\nd = collect(reshape(1:6, (2,3)))\n\n2√ó3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\n\n\nd[4]\n\n4\n\n\nAt first glance, linear indexing may seem like another exception to the cartesian indexing rule that we have to provide an index for each dimension of an array, but it truly is a different way of indexing.\n\nNote that linear indexing takes precedence over the omission of trailing dimensions of length 1.\n\nLinear indices can be converted into cartesian indices and vice versa using the LinearIndices and CartesianIndices objects as follows:\n\nCartesianIndices(d)[4]\n\nCartesianIndex(2, 2)\n\n\n\nLinearIndices(d)[2,2]\n\n4\n\n\nWe will come back to linear indexing when we discuss how to iterate over an array.\n\n\n4.2.4 Value assignment\nValues of an n-dimensional array A are set using the same cartesian indexing notation we have seen before:\n\nA[I_1, I_2, ..., I_n] = X\n\nAs before each I_k can be any type of supported indices, including the colon :, begin and end keywords. If a single element is selected, the value X on the right-hand side has to be a scalar value. If a subarray of A is selected by the indices I_k, the value X must be either an array whose size and dimension match that of the selected subarray or a vector whose length equals the number of elements of the subarray. The selected values of A are overwritten with the corresponding values of X, specifically the value A[I_1[i_1], I_2[i_2], ..., I_n[i_n]] is overwritten with the value X[i_1, i_2, ..., i_n]. Let us consider some examples:\n\nd = collect(reshape(1.0:6.0, (2,3)))\n\n2√ó3 Matrix{Float64}:\n 1.0  3.0  5.0\n 2.0  4.0  6.0\n\n\n\nd[2, 3] = 36\nd[:, 1] = [-1., -2.]\nd[1, 2:3] = d[1:2, 2].^2\nd\n\n2√ó3 Matrix{Float64}:\n -1.0  9.0  16.0\n -2.0  4.0  36.0\n\n\nShould the elements of X have a different type than the elements of A, they are converted appropriately if possible.\n\nNote that Julia throws an error if the dimension of the left-hand side and right-hand side expressions do not match, even if the right-hand side value is a scalar:\n\nd[:] = 1\n\nLoadError: ArgumentError: indexed assignment with a single value to possibly many locations is not supported; perhaps use broadcasting `.=` instead?\n\n\n\nSimilar to element-wise operation on arrays, the dot notation can be used to set values of an array element-wise. For example, the following expression sets all the selected elements of A to the scalar value x:\n\nA[I_1, I_2, ..., I_n] .= x\n\nThis works also without selecting specific elements (this is the correct version of the erroneous expression d[:] = 1 shown above):\n\nd .= 1\nd\n\n2√ó3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n\nThe dot notation also allows for applying arithmetic operations element-wise and inplace using the .+=, .-=, .*=, ./=, and .^= operators, which all have the obvious meaning, e.g.:\n\nd = collect(reshape(1.0:6.0, (2,3)))\nd .^= 2\n\n2√ó3 Matrix{Float64}:\n 1.0   9.0  25.0\n 4.0  16.0  36.0\n\n\nVectorized assignments using the dot syntax are closely related to broadcasts, which will be discussed in the next section, but before that, we will conclude this section with another important aspect of accessing arrays.\n\n\n4.2.5 Views\nIf we access an array via slicing, Julia will create a copy of the subarray we selected unless it is on the left-hand side of an assignment. To exemplify what that means, let us create an array, select a slice, and change some of its values:\n\na = collect(reshape(1:6, (2,3)))\nb = a[1, :]\nb .*= 2\nb\n\n3-element Vector{Int64}:\n  2\n  6\n 10\n\n\n\na\n\n2√ó3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\n\nWe see that a has not changed, because when we changed b we operated on a copy of the elements of a. While copying data is not always bad and can in fact be advantageous for performance (more on that below) it can just as well be very detrimental for performance if more time is spent on allocating and copying than on computing.\nCopying can be avoided by using views. A view is a wrapper around an array that behaves like an array but does not store actual data. Instead, it references the data of the array it wraps and only translates the indices on which it is evaluated into the corresponding indices of the original array.\nJulia provides several ways to create views. The easiest way to use views instead of copies is by writing the @views macro at the beginning of a code line:\n\n@views b = a[1:1, :]\n\n1√ó3 view(::Matrix{Int64}, 1:1, :) with eltype Int64:\n 1  3  5\n\n\nIf we change b now, we also change a:\n\nb .*= 2\nb\n\n1√ó3 view(::Matrix{Int64}, 1:1, :) with eltype Int64:\n 2  6  10\n\n\n\na\n\n2√ó3 Matrix{Int64}:\n 2  6  10\n 2  4   6\n\n\nThe @views macro creates views for all array slices in an expression. If we want to use views in more than just one line of code, we can encapsulate the respective code using begin and end or any other code block delimiter such as for ... end or while ... end:\n\n@views begin\n    # code to use views ...\nend\n\nMore granular control is facilitated by the @view macro, which acts only on the following array, for example in a function call:\n\nf(x, y) = x .+ y\nf(b[1,:], @view a[1,:])\n\n3-element Vector{Int64}:\n  4\n 12\n 20\n\n\nHere, a view is created only for the slice of a but not for the slice of b which is copied instead.\n\nUsing the @view macro like this, a bit of care is needed. Consider the following expression that results in an error:\n\nf(@view a[1,:], b[1,:])\n\nLoadError: LoadError: ArgumentError: Invalid use of @view macro: argument must be a reference expression A[...].\nin expression starting at In[104]:1\n\n\nThis is due to the way Julia is parsing macros. Macro arguments can either be separated by spaces or by brackets like in a function call. If spaces are used, like in this example, Julia assumes that everything that follows belongs to the macro‚Äôs arguments. Here, the tuple (a[1,:], b[1,:]) is passed instead of just a[1,:], but the macro does not expect such a tuple as its argument. This can be avoided by using bracket syntax instead of space syntax:\n\nf(@view(a[1,:]), b[1,:])\n\n3-element Vector{Int64}:\n  4\n 12\n 20\n\n\n\nLastly, views can also be created with the view(A, I_1, I_2, ..., I_n) function, which takes an array A as its first argument and any type of supported indices I_k for each of the array‚Äôs dimensions as consecutive arguments. Therefore, the following two expression are equivalent:\n\nB = view(A, I_1, I_2, ..., I_n)\nB = @view A[I_1, I_2, ..., I_n]\n\nThe type that represents a view is the SubArray type. It is rarely necessary to directly interact with this type or its constructors, as the view function and macros are more than sufficient for creating views and there exist convenience functions for retrieving additional information. For example, the array wrapped by a view can be retrieved with the parent function:\n\nparent(b)\n\n2√ó3 Matrix{Int64}:\n 2  6  10\n 2  4   6\n\n\nThe indices of the parent array that correspond to the view can be retrieved with the parentindices function:\n\nparentindices(b)\n\n(1:1, Base.Slice(Base.OneTo(3)))\n\n\nThe SubArray type is implemented very efficiently. For example, index substitution does not cause any runtime overhead. Still, there are cases when views are actually less performant than copies of subarrays. Depending on the index pattern of the subarray, its elements can be scattered in memory. The irregular access patterns required to loop through such an array can result in memory access times dominating the runtime of an algorithm, in particular if repeated access is required. If the data is copied beforehand, the resulting array will be stored in a contiguous chunk of memory, allowing for CPU vectorization, more efficient memory access and caching.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "content/arrays.html#looping-mapping-broadcasting",
    "href": "content/arrays.html#looping-mapping-broadcasting",
    "title": "4¬† Working with Arrays",
    "section": "4.3 Looping, mapping, broadcasting",
    "text": "4.3 Looping, mapping, broadcasting\nIn this section, we discuss how to iterate over arrays, in particular how to write generic code that applies to different array types with different indexing, and how and when to use maps and broadcasts instead of loops.\n\n4.3.1 Loops\nAlbeit Julia supports a variety of options for looping through arrays, only two of them lead to generic code. If the code in the loop only needs the values of the array elements, we can use the following pattern:\n\nfor a in A\n    # Code that operates on a ...\nend\n\nIf the index is needed in addition to the value, we can use the following pattern instead:\n\nfor i in eachindex(A)\n    # Code that operates on i and/or A[i] ...\nend\n\nWith these looping patterns, Julia automatically picks the most efficient way of looping through the array. If the array A supports linear indexing, i will be an integer, otherwise it will be a CartesianIndex. If more than one array is indexed, the different arrays may have different default iterators. In this case, we can apply eachindex to all arrays as in eachindex(A,B) so that it can pick the most efficient iterator that is applicable to all arrays.\nIt is also possible to loop through a single dimension of an n-dimensional array. To this end, the axes function can be used as follows:\n\nfor j in axes(A, 2)\n    # Code that operates on j and/or A[:,j] ...\nend\n\nIt is also possible to loop through an array in a more classical fashion specifying the start and stop indices, e.g.:\n\nfor i in 1:length(A)\n    # Code that operates on i and/or A[i] ...\nend\nfor j in 1:size(A,2)\n    # Code that operates on j and/or A[:,j] ...\nend\n\nThe first example uses linear indexing whereas the second example uses cartesian indexing.\n\nThis indexing pattern is not recommended as it is only applicable to arrays whose index range starts at 1. However, as we will discuss in a moment, Julia also supports arrays with custom indexing, e.g., starting from 0 or some negative number. The above loop will not work with such arrays and thus does not constitute generic code.\n\nThe way data is organized in memory suggests how to loop through multi-dimensional arrays. As Julia uses column-major ordering, nested loops should be ordered accordingly, e.g.:\n\nfor j in axes(A, 2)\n    for i in axes(A, 1)\n        # Code that operates on (i,j) and/or A[i,j] ...\n    end\nend\n\nHowever, if we use the default loop patterns for a in A ... end or for i in eachindex(A) ... end, we do not need to worry about the correct nesting of our loops because Julia automatically takes care of looping through the array in an optimal way.\n\n\n4.3.2 Maps\nThe map(f, c...) function was already introduced in Chapter 1 in the context of anonymous functions. It applies some function f to each element of a collection c, such as a tuple or an array, returning a new collection of the same type that holds the return values of f:\n\ny = map(x -&gt; x^2, 1:3)\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\nThere also exists an inplace version, that takes the destination as the second argument:\n\nmap!(x -&gt; x^3, y, 1:3)\n\n3-element Vector{Int64}:\n  1\n  8\n 27\n\n\nWhen map is applied to two or more vectors (or other one-dimensional collections), it stops evaluating the function when it reaches the last element of one of the vectors. Thus the return vector has the same length as the smallest input vector:\n\nmap(+, 5:-1:1, 1:3)\n\n3-element Vector{Int64}:\n 6\n 6\n 6\n\n\nWhen map is applied to two or more multi-dimensional arrays with the same number of dimensions, the axes of all arrays have to match:\n\nmap(+, ones(2,2), zeros(1,2))\n\nLoadError: DimensionMismatch: dimensions must match: a has dims (Base.OneTo(2), Base.OneTo(2)), b has dims (Base.OneTo(1), Base.OneTo(2)), mismatch at 1\n\n\nThe broadcast function discussed in the next section is also applicable to arrays whose sizes do not match.\n\nNote that in simple cases, when map is applied to a single array, its result is equivalent to using vectorization as discussed earlier in this chapter. For example, map(x -&gt; x^2, 1:3) is equivalent to\n\n(x -&gt; x^2).(1:3)\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\nHowever, there is an important implementational difference when the argument is some generic iterable like in this example. While map will just iterate through the collection, broadcasting with the dot syntax will first call collect on the iterable to convert it into an array. If the iterable has a sufficiently large number of elements, this can require non-negligible amounts of memory and consequently time for allocation.\nAlso note that broadcasting will always generate an array, independently of the type of the arguments, while map will generate an output of the same type as the input.\n\nJulia features a few more functions similar to map with some additional functionality. The mapreduce(f, op, c...) function first applies a function f to each element in c, just like map, but then it reduces the results with some binary operator op, e.g., +:\n\nmapreduce(x -&gt; x^2, +, 1:5)\n\n55\n\n\nThe functions mapfoldl and mapfoldr work like mapreduce but with guaranteed left and right associativity, respectively. The function mapslices applies a function only to specific slices of an array. For more details, we refer to the Julia Manual or ?mapslices.",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "content/arrays.html#array-libraries",
    "href": "content/arrays.html#array-libraries",
    "title": "4¬† Working with Arrays",
    "section": "4.4 Array libraries",
    "text": "4.4 Array libraries\n\n4.4.1 Offset arrays\n\n\n4.4.2 Static arrays\n\n\n4.4.3 Continuum arrays\n\n\n4.4.4 Linear operators",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "content/arrays.html#summary",
    "href": "content/arrays.html#summary",
    "title": "4¬† Working with Arrays",
    "section": "4.5 Summary",
    "text": "4.5 Summary",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "content/arrays.html#references",
    "href": "content/arrays.html#references",
    "title": "4¬† Working with Arrays",
    "section": "4.6 References",
    "text": "4.6 References\n\nThe Julia Manual: Single- and multi-dimensional Arrays\nMultidimensional algorithms and iteration by Tim Holy",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "content/design-patterns.html",
    "href": "content/design-patterns.html",
    "title": "5¬† Design Patterns",
    "section": "",
    "text": "5.1 Composition",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Design Patterns</span>"
    ]
  },
  {
    "objectID": "content/design-patterns.html#conversion-promotion-similar",
    "href": "content/design-patterns.html#conversion-promotion-similar",
    "title": "5¬† Design Patterns",
    "section": "5.2 Conversion, Promotion, Similar",
    "text": "5.2 Conversion, Promotion, Similar",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Design Patterns</span>"
    ]
  },
  {
    "objectID": "content/design-patterns.html#interfaces",
    "href": "content/design-patterns.html#interfaces",
    "title": "5¬† Design Patterns",
    "section": "5.3 Interfaces",
    "text": "5.3 Interfaces",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Design Patterns</span>"
    ]
  },
  {
    "objectID": "content/design-patterns.html#domain-specific-languages",
    "href": "content/design-patterns.html#domain-specific-languages",
    "title": "5¬† Design Patterns",
    "section": "5.4 Domain-specific Languages",
    "text": "5.4 Domain-specific Languages",
    "crumbs": [
      "Part 1: Programming in Julia",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Design Patterns</span>"
    ]
  },
  {
    "objectID": "content/package-development.html",
    "href": "content/package-development.html",
    "title": "6¬† Package Development",
    "section": "",
    "text": "6.1 Packages",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Package Development</span>"
    ]
  },
  {
    "objectID": "content/package-development.html#modules",
    "href": "content/package-development.html#modules",
    "title": "6¬† Package Development",
    "section": "6.2 Modules",
    "text": "6.2 Modules",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Package Development</span>"
    ]
  },
  {
    "objectID": "content/package-development.html#dependency-management",
    "href": "content/package-development.html#dependency-management",
    "title": "6¬† Package Development",
    "section": "6.3 Dependency management",
    "text": "6.3 Dependency management",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Package Development</span>"
    ]
  },
  {
    "objectID": "content/package-development.html#documentation",
    "href": "content/package-development.html#documentation",
    "title": "6¬† Package Development",
    "section": "6.4 Documentation",
    "text": "6.4 Documentation",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Package Development</span>"
    ]
  },
  {
    "objectID": "content/package-development.html#tests",
    "href": "content/package-development.html#tests",
    "title": "6¬† Package Development",
    "section": "6.5 Tests",
    "text": "6.5 Tests",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Package Development</span>"
    ]
  },
  {
    "objectID": "content/package-development.html#style-guides",
    "href": "content/package-development.html#style-guides",
    "title": "6¬† Package Development",
    "section": "6.6 Style guides",
    "text": "6.6 Style guides",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Package Development</span>"
    ]
  },
  {
    "objectID": "content/package-development.html#package-templates",
    "href": "content/package-development.html#package-templates",
    "title": "6¬† Package Development",
    "section": "6.7 Package templates",
    "text": "6.7 Package templates",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Package Development</span>"
    ]
  },
  {
    "objectID": "content/git-and-github.html",
    "href": "content/git-and-github.html",
    "title": "7¬† Git and GitHub",
    "section": "",
    "text": "7.1 Version control",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "content/git-and-github.html#basic-git-usage",
    "href": "content/git-and-github.html#basic-git-usage",
    "title": "7¬† Git and GitHub",
    "section": "7.2 Basic git usage",
    "text": "7.2 Basic git usage",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "content/git-and-github.html#github-repositories",
    "href": "content/git-and-github.html#github-repositories",
    "title": "7¬† Git and GitHub",
    "section": "7.3 GitHub repositories",
    "text": "7.3 GitHub repositories",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "content/git-and-github.html#github-workflows",
    "href": "content/git-and-github.html#github-workflows",
    "title": "7¬† Git and GitHub",
    "section": "7.4 GitHub workflows",
    "text": "7.4 GitHub workflows",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "content/git-and-github.html#good-enough-practices",
    "href": "content/git-and-github.html#good-enough-practices",
    "title": "7¬† Git and GitHub",
    "section": "7.5 Good enough practices",
    "text": "7.5 Good enough practices",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "content/software-sustainability.html",
    "href": "content/software-sustainability.html",
    "title": "8¬† Software Sustainability",
    "section": "",
    "text": "8.1 Reusability",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Software Sustainability</span>"
    ]
  },
  {
    "objectID": "content/software-sustainability.html#robustness",
    "href": "content/software-sustainability.html#robustness",
    "title": "8¬† Software Sustainability",
    "section": "8.2 Robustness",
    "text": "8.2 Robustness",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Software Sustainability</span>"
    ]
  },
  {
    "objectID": "content/software-sustainability.html#maintainability",
    "href": "content/software-sustainability.html#maintainability",
    "title": "8¬† Software Sustainability",
    "section": "8.3 Maintainability",
    "text": "8.3 Maintainability",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Software Sustainability</span>"
    ]
  },
  {
    "objectID": "content/software-sustainability.html#licenses",
    "href": "content/software-sustainability.html#licenses",
    "title": "8¬† Software Sustainability",
    "section": "8.4 Licenses",
    "text": "8.4 Licenses",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Software Sustainability</span>"
    ]
  },
  {
    "objectID": "content/test-driven-development.html",
    "href": "content/test-driven-development.html",
    "title": "9¬† Test Driven Development",
    "section": "",
    "text": "9.1 In the beginning there was the Test",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Test Driven Development</span>"
    ]
  },
  {
    "objectID": "content/test-driven-development.html#unit-tests",
    "href": "content/test-driven-development.html#unit-tests",
    "title": "9¬† Test Driven Development",
    "section": "9.2 Unit Tests",
    "text": "9.2 Unit Tests",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Test Driven Development</span>"
    ]
  },
  {
    "objectID": "content/test-driven-development.html#integration-tests",
    "href": "content/test-driven-development.html#integration-tests",
    "title": "9¬† Test Driven Development",
    "section": "9.3 Integration Tests",
    "text": "9.3 Integration Tests",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Test Driven Development</span>"
    ]
  },
  {
    "objectID": "content/test-driven-development.html#testing-interfaces",
    "href": "content/test-driven-development.html#testing-interfaces",
    "title": "9¬† Test Driven Development",
    "section": "9.4 Testing Interfaces",
    "text": "9.4 Testing Interfaces",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Test Driven Development</span>"
    ]
  },
  {
    "objectID": "content/test-driven-development.html#manufactured-solutions",
    "href": "content/test-driven-development.html#manufactured-solutions",
    "title": "9¬† Test Driven Development",
    "section": "9.5 Manufactured Solutions",
    "text": "9.5 Manufactured Solutions",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Test Driven Development</span>"
    ]
  },
  {
    "objectID": "content/performance-and-introspection.html",
    "href": "content/performance-and-introspection.html",
    "title": "10¬† Performance & Introspection",
    "section": "",
    "text": "10.1 Performance Tips",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Performance & Introspection</span>"
    ]
  },
  {
    "objectID": "content/performance-and-introspection.html#type-stability",
    "href": "content/performance-and-introspection.html#type-stability",
    "title": "10¬† Performance & Introspection",
    "section": "10.2 Type Stability",
    "text": "10.2 Type Stability",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Performance & Introspection</span>"
    ]
  },
  {
    "objectID": "content/performance-and-introspection.html#code-introspection",
    "href": "content/performance-and-introspection.html#code-introspection",
    "title": "10¬† Performance & Introspection",
    "section": "10.3 Code Introspection",
    "text": "10.3 Code Introspection",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Performance & Introspection</span>"
    ]
  },
  {
    "objectID": "content/performance-and-introspection.html#profiling",
    "href": "content/performance-and-introspection.html#profiling",
    "title": "10¬† Performance & Introspection",
    "section": "10.4 Profiling",
    "text": "10.4 Profiling",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Performance & Introspection</span>"
    ]
  },
  {
    "objectID": "content/performance-and-introspection.html#benchmarking",
    "href": "content/performance-and-introspection.html#benchmarking",
    "title": "10¬† Performance & Introspection",
    "section": "10.5 Benchmarking",
    "text": "10.5 Benchmarking",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Performance & Introspection</span>"
    ]
  },
  {
    "objectID": "content/performance-and-introspection.html#debugging",
    "href": "content/performance-and-introspection.html#debugging",
    "title": "10¬† Performance & Introspection",
    "section": "10.6 Debugging",
    "text": "10.6 Debugging",
    "crumbs": [
      "Part 2: Research Software Engineering",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Performance & Introspection</span>"
    ]
  },
  {
    "objectID": "content/data.html",
    "href": "content/data.html",
    "title": "11¬† Working with Data",
    "section": "",
    "text": "11.1 Reading and Writing CSV",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#reading-and-writing-hdf5",
    "href": "content/data.html#reading-and-writing-hdf5",
    "title": "11¬† Working with Data",
    "section": "11.2 Reading and Writing HDF5",
    "text": "11.2 Reading and Writing HDF5",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#reading-and-writing-config-files",
    "href": "content/data.html#reading-and-writing-config-files",
    "title": "11¬† Working with Data",
    "section": "11.3 Reading and Writing Config Files",
    "text": "11.3 Reading and Writing Config Files",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#manipulating-tabulated-data-with-dataframes.jl",
    "href": "content/data.html#manipulating-tabulated-data-with-dataframes.jl",
    "title": "11¬† Working with Data",
    "section": "11.4 Manipulating Tabulated Data with DataFrames.jl",
    "text": "11.4 Manipulating Tabulated Data with DataFrames.jl",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#basic-plotting-with-makie",
    "href": "content/data.html#basic-plotting-with-makie",
    "title": "11¬† Working with Data",
    "section": "11.5 Basic Plotting with Makie",
    "text": "11.5 Basic Plotting with Makie",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#augmented-data",
    "href": "content/data.html#augmented-data",
    "title": "11¬† Working with Data",
    "section": "11.6 Augmented Data",
    "text": "11.6 Augmented Data",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#quadruple-and-arbitrary-precision",
    "href": "content/data.html#quadruple-and-arbitrary-precision",
    "title": "11¬† Working with Data",
    "section": "11.7 Quadruple and Arbitrary Precision",
    "text": "11.7 Quadruple and Arbitrary Precision",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#uncertainties-measurements.jl",
    "href": "content/data.html#uncertainties-measurements.jl",
    "title": "11¬† Working with Data",
    "section": "11.8 Uncertainties (Measurements.jl)",
    "text": "11.8 Uncertainties (Measurements.jl)",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/data.html#physical-units-unitful.jl",
    "href": "content/data.html#physical-units-unitful.jl",
    "title": "11¬† Working with Data",
    "section": "11.9 Physical Units (Unitful.jl)",
    "text": "11.9 Physical Units (Unitful.jl)",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Working with Data</span>"
    ]
  },
  {
    "objectID": "content/differentiable-programming.html",
    "href": "content/differentiable-programming.html",
    "title": "12¬† Differentiable Programming",
    "section": "",
    "text": "12.1 Automatic Differentiation",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Differentiable Programming</span>"
    ]
  },
  {
    "objectID": "content/differentiable-programming.html#forwarddiff",
    "href": "content/differentiable-programming.html#forwarddiff",
    "title": "12¬† Differentiable Programming",
    "section": "12.2 ForwardDiff",
    "text": "12.2 ForwardDiff",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Differentiable Programming</span>"
    ]
  },
  {
    "objectID": "content/differentiable-programming.html#enzyme",
    "href": "content/differentiable-programming.html#enzyme",
    "title": "12¬† Differentiable Programming",
    "section": "12.3 Enzyme",
    "text": "12.3 Enzyme",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Differentiable Programming</span>"
    ]
  },
  {
    "objectID": "content/linear-and-nonlinear-equations.html",
    "href": "content/linear-and-nonlinear-equations.html",
    "title": "13¬† Linear and Nonlinear Equations",
    "section": "",
    "text": "13.1 Linear Systems",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Linear and Nonlinear Equations</span>"
    ]
  },
  {
    "objectID": "content/linear-and-nonlinear-equations.html#nonlinear-systems",
    "href": "content/linear-and-nonlinear-equations.html#nonlinear-systems",
    "title": "13¬† Linear and Nonlinear Equations",
    "section": "13.2 Nonlinear Systems",
    "text": "13.2 Nonlinear Systems",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Linear and Nonlinear Equations</span>"
    ]
  },
  {
    "objectID": "content/linear-and-nonlinear-equations.html#optimization",
    "href": "content/linear-and-nonlinear-equations.html#optimization",
    "title": "13¬† Linear and Nonlinear Equations",
    "section": "13.3 Optimization",
    "text": "13.3 Optimization",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Linear and Nonlinear Equations</span>"
    ]
  },
  {
    "objectID": "content/differential-equations.html",
    "href": "content/differential-equations.html",
    "title": "14¬† Differential Equations",
    "section": "",
    "text": "14.1 Ordinary Differential Equations",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Differential Equations</span>"
    ]
  },
  {
    "objectID": "content/differential-equations.html#partial-differential-equations",
    "href": "content/differential-equations.html#partial-differential-equations",
    "title": "14¬† Differential Equations",
    "section": "14.2 Partial Differential Equations",
    "text": "14.2 Partial Differential Equations",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Differential Equations</span>"
    ]
  },
  {
    "objectID": "content/differential-equations.html#finite-elements-with-gridap",
    "href": "content/differential-equations.html#finite-elements-with-gridap",
    "title": "14¬† Differential Equations",
    "section": "14.3 Finite Elements with Gridap",
    "text": "14.3 Finite Elements with Gridap",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Differential Equations</span>"
    ]
  },
  {
    "objectID": "content/machine-learning.html",
    "href": "content/machine-learning.html",
    "title": "15¬† Machine Learning",
    "section": "",
    "text": "15.1 Deep Learning Frameworks",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Machine Learning</span>"
    ]
  },
  {
    "objectID": "content/machine-learning.html#manifold-learning",
    "href": "content/machine-learning.html#manifold-learning",
    "title": "15¬† Machine Learning",
    "section": "15.2 Manifold Learning",
    "text": "15.2 Manifold Learning",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Machine Learning</span>"
    ]
  },
  {
    "objectID": "content/machine-learning.html#physics-informed-neural-networks",
    "href": "content/machine-learning.html#physics-informed-neural-networks",
    "title": "15¬† Machine Learning",
    "section": "15.3 Physics Informed Neural Networks",
    "text": "15.3 Physics Informed Neural Networks",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Machine Learning</span>"
    ]
  },
  {
    "objectID": "content/machine-learning.html#neuralodes-and-neuralpdes",
    "href": "content/machine-learning.html#neuralodes-and-neuralpdes",
    "title": "15¬† Machine Learning",
    "section": "15.4 NeuralODEs and NeuralPDEs",
    "text": "15.4 NeuralODEs and NeuralPDEs",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Machine Learning</span>"
    ]
  },
  {
    "objectID": "content/machine-learning.html#integration-with-classical-numerical-algorithms",
    "href": "content/machine-learning.html#integration-with-classical-numerical-algorithms",
    "title": "15¬† Machine Learning",
    "section": "15.5 Integration with Classical Numerical Algorithms",
    "text": "15.5 Integration with Classical Numerical Algorithms",
    "crumbs": [
      "Part 3: Useful Libraries and Solutions to Common Problems",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Machine Learning</span>"
    ]
  },
  {
    "objectID": "content/parallel-programming.html",
    "href": "content/parallel-programming.html",
    "title": "16¬† Parallel Programming Paradigms",
    "section": "",
    "text": "16.1 Threads",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Parallel Programming Paradigms</span>"
    ]
  },
  {
    "objectID": "content/parallel-programming.html#tasks",
    "href": "content/parallel-programming.html#tasks",
    "title": "16¬† Parallel Programming Paradigms",
    "section": "16.2 Tasks",
    "text": "16.2 Tasks",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Parallel Programming Paradigms</span>"
    ]
  },
  {
    "objectID": "content/parallel-programming.html#distributed",
    "href": "content/parallel-programming.html#distributed",
    "title": "16¬† Parallel Programming Paradigms",
    "section": "16.3 Distributed",
    "text": "16.3 Distributed",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Parallel Programming Paradigms</span>"
    ]
  },
  {
    "objectID": "content/parallel-programming.html#mpi",
    "href": "content/parallel-programming.html#mpi",
    "title": "16¬† Parallel Programming Paradigms",
    "section": "16.4 MPI",
    "text": "16.4 MPI",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Parallel Programming Paradigms</span>"
    ]
  },
  {
    "objectID": "content/parallel-arrays.html",
    "href": "content/parallel-arrays.html",
    "title": "17¬† Parallel Arrays",
    "section": "",
    "text": "17.1 MPI Arrays",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Parallel Arrays</span>"
    ]
  },
  {
    "objectID": "content/parallel-arrays.html#mpihaloarrays.jl",
    "href": "content/parallel-arrays.html#mpihaloarrays.jl",
    "title": "17¬† Parallel Arrays",
    "section": "17.2 MPIHaloArrays.jl",
    "text": "17.2 MPIHaloArrays.jl",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Parallel Arrays</span>"
    ]
  },
  {
    "objectID": "content/parallel-arrays.html#implicitglobalgrid.jl",
    "href": "content/parallel-arrays.html#implicitglobalgrid.jl",
    "title": "17¬† Parallel Arrays",
    "section": "17.3 ImplicitGlobalGrid.jl",
    "text": "17.3 ImplicitGlobalGrid.jl",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Parallel Arrays</span>"
    ]
  },
  {
    "objectID": "content/parallel-arrays.html#pencil-arrays",
    "href": "content/parallel-arrays.html#pencil-arrays",
    "title": "17¬† Parallel Arrays",
    "section": "17.4 Pencil Arrays",
    "text": "17.4 Pencil Arrays",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Parallel Arrays</span>"
    ]
  },
  {
    "objectID": "content/parallel-arrays.html#partitioned-arrays",
    "href": "content/parallel-arrays.html#partitioned-arrays",
    "title": "17¬† Parallel Arrays",
    "section": "17.5 Partitioned Arrays",
    "text": "17.5 Partitioned Arrays",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Parallel Arrays</span>"
    ]
  },
  {
    "objectID": "content/parallel-gpu.html",
    "href": "content/parallel-gpu.html",
    "title": "18¬† GPU Programming",
    "section": "",
    "text": "18.1 GPU Arrays",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>GPU Programming</span>"
    ]
  },
  {
    "objectID": "content/parallel-gpu.html#kernel-abstractions",
    "href": "content/parallel-gpu.html#kernel-abstractions",
    "title": "18¬† GPU Programming",
    "section": "18.2 Kernel Abstractions",
    "text": "18.2 Kernel Abstractions",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>GPU Programming</span>"
    ]
  },
  {
    "objectID": "content/parallel-gpu.html#parallel-stencil",
    "href": "content/parallel-gpu.html#parallel-stencil",
    "title": "18¬† GPU Programming",
    "section": "18.3 Parallel Stencil",
    "text": "18.3 Parallel Stencil",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>GPU Programming</span>"
    ]
  },
  {
    "objectID": "content/parallel-gpu.html#multiple-gpus",
    "href": "content/parallel-gpu.html#multiple-gpus",
    "title": "18¬† GPU Programming",
    "section": "18.4 Multiple GPUs",
    "text": "18.4 Multiple GPUs",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>GPU Programming</span>"
    ]
  },
  {
    "objectID": "content/parallel-hybrid.html",
    "href": "content/parallel-hybrid.html",
    "title": "19¬† Hybrid Parallel Programming",
    "section": "",
    "text": "19.1 Threads and GPUs",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Hybrid Parallel Programming</span>"
    ]
  },
  {
    "objectID": "content/parallel-hybrid.html#mpi-and-threads",
    "href": "content/parallel-hybrid.html#mpi-and-threads",
    "title": "19¬† Hybrid Parallel Programming",
    "section": "19.2 MPI and Threads",
    "text": "19.2 MPI and Threads",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Hybrid Parallel Programming</span>"
    ]
  },
  {
    "objectID": "content/parallel-hybrid.html#mpi-threads-and-gpus",
    "href": "content/parallel-hybrid.html#mpi-threads-and-gpus",
    "title": "19¬† Hybrid Parallel Programming",
    "section": "19.3 MPI, Threads and GPUs",
    "text": "19.3 MPI, Threads and GPUs",
    "crumbs": [
      "Part 4: Parallel and GPU Programming",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Hybrid Parallel Programming</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. ‚ÄúLiterate Programming.‚Äù Comput. J. 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Summary"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. ‚ÄúLiterate Programming.‚Äù Comput.\nJ. 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]