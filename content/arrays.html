<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-99.9.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Modern Scientific Computing with Julia – 4&nbsp; Working with Arrays</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../content/design-patterns.html" rel="next">
<link href="../content/methods-multiple-dispatch.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/ansicolors/ansicolor.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/juliamonofont/juliamono.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../resources/jsc.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/part1.html">Part 1: Programming in Julia</a></li><li class="breadcrumb-item"><a href="../content/arrays.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Working with Arrays</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Modern Scientific Computing with Julia</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/michakraus/JuliaMSC" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 1: Programming in Julia</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/julia-language.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Basics of the Julia Language</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/type-system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Julia’s Type System</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/methods-multiple-dispatch.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods &amp; Multiple Dispatch</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/arrays.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Working with Arrays</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/design-patterns.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Design Patterns</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 2: Research Software Engineering</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/package-development.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Package Development</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/git-and-github.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Git and GitHub</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/software-sustainability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Software Sustainability</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/test-driven-development.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Test Driven Development</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/performance-and-introspection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Performance &amp; Introspection</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 3: Useful Libraries and Solutions to Common Problems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Working with Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/differentiable-programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Differentiable Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/linear-and-nonlinear-equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Linear and Nonlinear Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/differential-equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/machine-learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Machine Learning</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 4: Parallel and GPU Programming</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Parallel Programming Paradigms</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-arrays.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Parallel Arrays</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-gpu.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">GPU Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-hybrid.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Hybrid Parallel Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-case-studies.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Case Studies</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Summary</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#vectors-matrices-arrays" id="toc-vectors-matrices-arrays" class="nav-link active" data-scroll-target="#vectors-matrices-arrays"><span class="header-section-number">4.1</span> Vectors, matrices, arrays</a>
  <ul class="collapse">
  <li><a href="#array-literals" id="toc-array-literals" class="nav-link" data-scroll-target="#array-literals"><span class="header-section-number">4.1.1</span> Array literals</a></li>
  <li><a href="#convenience-constructors" id="toc-convenience-constructors" class="nav-link" data-scroll-target="#convenience-constructors"><span class="header-section-number">4.1.2</span> Convenience constructors</a></li>
  <li><a href="#comprehensions-and-generators" id="toc-comprehensions-and-generators" class="nav-link" data-scroll-target="#comprehensions-and-generators"><span class="header-section-number">4.1.3</span> Comprehensions and generators</a></li>
  <li><a href="#basic-linear-algebra" id="toc-basic-linear-algebra" class="nav-link" data-scroll-target="#basic-linear-algebra"><span class="header-section-number">4.1.4</span> Basic linear algebra</a></li>
  <li><a href="#element-wise-operations-and-vectorization" id="toc-element-wise-operations-and-vectorization" class="nav-link" data-scroll-target="#element-wise-operations-and-vectorization"><span class="header-section-number">4.1.5</span> Element-wise operations and vectorization</a></li>
  <li><a href="#the-array-type" id="toc-the-array-type" class="nav-link" data-scroll-target="#the-array-type"><span class="header-section-number">4.1.6</span> The array type</a></li>
  <li><a href="#arrays-as-fields-in-composite-types" id="toc-arrays-as-fields-in-composite-types" class="nav-link" data-scroll-target="#arrays-as-fields-in-composite-types"><span class="header-section-number">4.1.7</span> Arrays as fields in composite types</a></li>
  </ul></li>
  <li><a href="#indexing" id="toc-indexing" class="nav-link" data-scroll-target="#indexing"><span class="header-section-number">4.2</span> Indexing</a>
  <ul class="collapse">
  <li><a href="#basic-indexing" id="toc-basic-indexing" class="nav-link" data-scroll-target="#basic-indexing"><span class="header-section-number">4.2.1</span> Basic indexing</a></li>
  <li><a href="#cartesian-indexing" id="toc-cartesian-indexing" class="nav-link" data-scroll-target="#cartesian-indexing"><span class="header-section-number">4.2.2</span> Cartesian indexing</a></li>
  <li><a href="#linear-indexing" id="toc-linear-indexing" class="nav-link" data-scroll-target="#linear-indexing"><span class="header-section-number">4.2.3</span> Linear indexing</a></li>
  <li><a href="#value-assignment" id="toc-value-assignment" class="nav-link" data-scroll-target="#value-assignment"><span class="header-section-number">4.2.4</span> Value assignment</a></li>
  <li><a href="#views" id="toc-views" class="nav-link" data-scroll-target="#views"><span class="header-section-number">4.2.5</span> Views</a></li>
  </ul></li>
  <li><a href="#looping-mapping-broadcasting" id="toc-looping-mapping-broadcasting" class="nav-link" data-scroll-target="#looping-mapping-broadcasting"><span class="header-section-number">4.3</span> Looping, mapping, broadcasting</a>
  <ul class="collapse">
  <li><a href="#loops" id="toc-loops" class="nav-link" data-scroll-target="#loops"><span class="header-section-number">4.3.1</span> Loops</a></li>
  <li><a href="#maps" id="toc-maps" class="nav-link" data-scroll-target="#maps"><span class="header-section-number">4.3.2</span> Maps</a></li>
  </ul></li>
  <li><a href="#array-libraries" id="toc-array-libraries" class="nav-link" data-scroll-target="#array-libraries"><span class="header-section-number">4.4</span> Array libraries</a>
  <ul class="collapse">
  <li><a href="#offset-arrays" id="toc-offset-arrays" class="nav-link" data-scroll-target="#offset-arrays"><span class="header-section-number">4.4.1</span> Offset arrays</a></li>
  <li><a href="#static-arrays" id="toc-static-arrays" class="nav-link" data-scroll-target="#static-arrays"><span class="header-section-number">4.4.2</span> Static arrays</a></li>
  <li><a href="#continuum-arrays" id="toc-continuum-arrays" class="nav-link" data-scroll-target="#continuum-arrays"><span class="header-section-number">4.4.3</span> Continuum arrays</a></li>
  <li><a href="#linear-operators" id="toc-linear-operators" class="nav-link" data-scroll-target="#linear-operators"><span class="header-section-number">4.4.4</span> Linear operators</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">4.5</span> Summary</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">4.6</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/part1.html">Part 1: Programming in Julia</a></li><li class="breadcrumb-item"><a href="../content/arrays.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Working with Arrays</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Working with Arrays</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Arrays play a fundamental role in scientific computing. They represent vectors, matrices, and higher-dimensional grids of data. Thus the quality of support for arrays is decisive for the suitability of a programming language for scientific computing. In Julia, arrays are first-class citizens. Not only does Julia provide a feature-comprehensive and very flexible implementation of standard n-dimensional arrays, it’s abstract array interface also makes it very easy to implement custom array types.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Vectors, matrices, arrays</li>
<li>Indexing</li>
<li>Looping, mapping, broadcasting</li>
<li>Abstract array interface</li>
<li>Custom array types</li>
<li>Lazy arrays</li>
<li>Array libraries</li>
</ul>
<p>Although we already mentioned arrays a few times, in particular in <span class="PItalics" data-custom-style="PItalics">Chapter 1</span>, so far we avoided introducing them. We will now rectify this omission.</p>
<section id="vectors-matrices-arrays" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="vectors-matrices-arrays"><span class="header-section-number">4.1</span> Vectors, matrices, arrays</h2>
<p>An array is a collection of data that is organized in an n-dimensional grid. The data at each grid point is often given by numbers, such as <code>Float64</code> or <code>Int64</code>, but Julia arrays can hold any data type. The simplest instances of an array are the one-dimensional kind known as vector and the two-dimensional kind known as matrix. These are the typical objects that are manipulated in linear algebra. However, in scientific computing we often also need higher-dimensional arrays, for example to represent data on a three- or higher-dimensional mesh. In the following, we will discuss the various ways to create arrays before discussing Julia’s array type in a little more detail.</p>
<section id="array-literals" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="array-literals"><span class="header-section-number">4.1.1</span> Array literals</h3>
<p>In Julia, arrays can be generated much like tuples, but replacing the brackets <code>(,)</code> with square brackets <code>[,]</code>:</p>
<div id="5b551a93" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">0.0</span>, <span class="fl">23.0</span>, <span class="fl">42.0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre class=""><code class=" ansi">3-element Vector{Float64}:
  0.0
 23.0
 42.0</code></pre>
</div>
</div>
<p>This creates a <code>Vector</code> whose elements are all of type <code>Float64</code> as indicated in the output. An array can also have elements of different types as in the following example:</p>
<div id="4bafa46b" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">0.0</span>, <span class="st">"hello"</span>, <span class="fl">6</span><span class="op">*</span><span class="fl">7</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre class=""><code class=" ansi">3-element Vector{Any}:
  0.0
   "hello"
 42</code></pre>
</div>
</div>
<p>This creates a vector with elements of type <code>Any</code>. When an array is initialized with values of different types, Julia tries to promote all values to a common type. If this is not possible due to a lack of appropriate promotion rules, the element type of the array is determined to be <code>Any</code>. The topic of promotion will be discussed in more detail in <span class="PItalics" data-custom-style="PItalics">Chapter 5</span>.</p>
<div data-custom-style="PCallout">
<p>Julia arrays are largely implemented in Julia itself. High performance is achieved through the specialization of code to the specific element type by the compiler. Note, however, that the generation of high-performance code is only possible for arrays with concrete element types such as <code>Float64</code> or <code>Int64</code>, but not for arrays with abstract types such as <code>Real</code> or <code>Any</code>.</p>
</div>
<p>In the last example, we initialize the array with a <code>Float64</code>, a <code>String</code>, and an <code>Integer</code>. While <code>Float64</code> and <code>Integer</code> can be promoted to <code>Float64</code>, numbers and strings cannot be promoted to a common type, thus the element type of the array is <code>Any</code>. The situation is slightly different if we initialize the array with values of different number types:</p>
<div id="a8ea511b" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">0.0</span>, <span class="fl">460</span><span class="op">//</span><span class="fl">20</span>, <span class="fl">6</span><span class="op">*</span><span class="fl">7</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre class=""><code class=" ansi">3-element Vector{Float64}:
  0.0
 23.0
 42.0</code></pre>
</div>
</div>
<p>Here, we initialize the array with a <code>Float64</code>, a <code>Rational</code>, and an <code>Integer</code>, all of which can be promoted to <code>Float64</code>.</p>
<div data-custom-style="PCallout">
<p>Note that promotion usually applies conversion to a type that can faithfully represent all of the original values but not always. A typical example is the promotion of a <code>Rational</code> and some <code>AbstractFloat</code>, where truncation can happen as in the following example:</p>
<div id="f975526d" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">1.0f0</span>, <span class="fl">2</span><span class="op">//</span><span class="fl">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre class=""><code class=" ansi">2-element Vector{Float32}:
 1.0
 0.6666667</code></pre>
</div>
</div>
</div>
<p>It is also possible to specify the element type explicitly:</p>
<div id="2a929ea1" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Rational</span>[<span class="fl">1.0f0</span>, <span class="fl">2</span><span class="op">//</span><span class="fl">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre class=""><code class=" ansi">2-element Vector{Rational}:
  1
 2//3</code></pre>
</div>
</div>
<p>If an empty array is constructed, it is of type <code>Any</code> by default.</p>
<div id="1d318cf5" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>[]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre class=""><code class=" ansi">Any[]</code></pre>
</div>
</div>
<p>Arrays with more dimensions than a vector, such as a matrix, can be generated with different literals. The simplest and most visual way to create a matrix is as follows:</p>
<div id="f2519548" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a> <span class="fl">3</span> <span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre class=""><code class=" ansi">2×2 Matrix{Int64}:
 1  2
 3  4</code></pre>
</div>
</div>
<p>It is also possible to concatenate two or more vectors, higher-dimensional arrays or scalars. Concatenation is denoted by newlines or single semicolons for vertical concatenation, and spaces, tabs or double semicolons for horizontal concatenation:</p>
<div id="904dc1b1" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>[[<span class="fl">1</span>,<span class="fl">2</span>] [<span class="fl">3</span>,<span class="fl">4</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre class=""><code class=" ansi">2×2 Matrix{Int64}:
 1  3
 2  4</code></pre>
</div>
</div>
<div id="a1d1dad9" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>[[<span class="fl">1</span>,<span class="fl">2</span>];; [<span class="fl">3</span>,<span class="fl">4</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre class=""><code class=" ansi">2×2 Matrix{Int64}:
 1  3
 2  4</code></pre>
</div>
</div>
<div id="1f5214bb" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>[[<span class="fl">1</span>,<span class="fl">2</span>]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a> [<span class="fl">3</span>,<span class="fl">4</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre class=""><code class=" ansi">4-element Vector{Int64}:
 1
 2
 3
 4</code></pre>
</div>
</div>
<div id="12a69d49" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">1</span>; <span class="fl">2</span>; <span class="fl">3</span>; <span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre class=""><code class=" ansi">4-element Vector{Int64}:
 1
 2
 3
 4</code></pre>
</div>
</div>
<div id="0e3e1b3d" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">1</span>;; <span class="fl">2</span>;; <span class="fl">3</span>;; <span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre class=""><code class=" ansi">1×4 Matrix{Int64}:
 1  2  3  4</code></pre>
</div>
</div>
<div id="68bd1300" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">1</span>  <span class="fl">2</span>  <span class="fl">3</span>  <span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre class=""><code class=" ansi">1×4 Matrix{Int64}:
 1  2  3  4</code></pre>
</div>
</div>
<p>The semicolon notation is the most versatile as it applies to arbitrary-dimensional arrays. A single <code>;</code> concatenates the first dimension, two <code>;;</code> concatenates the second dimension, and so on.</p>
</section>
<section id="convenience-constructors" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="convenience-constructors"><span class="header-section-number">4.1.2</span> Convenience constructors</h3>
<p>Julia provides several functions that simplify the generation of arrays, e.g., with typical initial values, such as zeros, ones, or other scalars, random numbers, ranges, or concatenations of existing arrays.</p>
<p>The functions <code>zeros(dims...)</code> and <code>ones(dims...)</code> generate arrays that are pre-filled with the respective values:</p>
<div id="9d618d9f" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zeros</span>(<span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre class=""><code class=" ansi">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre>
</div>
</div>
<div id="ef556bc9" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ones</span>(<span class="fl">2</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre class=""><code class=" ansi">2×2 Matrix{Float64}:
 1.0  1.0
 1.0  1.0</code></pre>
</div>
</div>
<p>They can be called with an arbitrary number of lengths per dimension and they also allow to specify a number type <code>T</code> as the first argument in <code>zeros(T, dims...)</code> and <code>ones(T, dims...)</code>:</p>
<div id="7d96e5ab" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ones</span>(<span class="dt">Int</span>, <span class="fl">2</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre class=""><code class=" ansi">2×2 Matrix{Int64}:
 1  1
 1  1</code></pre>
</div>
</div>
<p>Similarly, <code>fill(x, dims...)</code> can be used to generate any array with dimensions <code>dims</code> that has <code>x</code> set to all its values:</p>
<div id="1d9e67a7" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fill</span>(<span class="cn">π</span>, <span class="fl">2</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre class=""><code class=" ansi">2×2 Matrix{Irrational{:π}}:
 π  π
 π  π</code></pre>
</div>
</div>
<p>The functions <code>rand(T, dims...)</code> and <code>randn(T, dims...)</code> provide arras prefilled with uniformly distributed or normally distributed random values, respectively:</p>
<div id="5e82a927" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rand</span>(<span class="dt">Float32</span>, <span class="fl">2</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre class=""><code class=" ansi">2×2 Matrix{Float32}:
 0.993133  0.437135
 0.64229   0.890833</code></pre>
</div>
</div>
<p>As with <code>zeros</code> and <code>ones</code>, the type parameter <code>T</code> can be omitted:</p>
<div id="defa16fc" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">randn</span>(<span class="fl">2</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre class=""><code class=" ansi">2×2 Matrix{Float64}:
 1.15147  -1.37344
 0.5068    0.781393</code></pre>
</div>
</div>
<p>If an array shall be initialized not with constant or random values but with a range of values, the function <code>range(start, stop, n)</code> can be used:</p>
<div id="11d1c1e0" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(<span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">11</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre class=""><code class=" ansi">1.0:0.1:2.0</code></pre>
</div>
</div>
<p>This command does not actually construct an array but a generator for an array. To obtain the corresponding array, we need to apply the <code>collect</code> function or enclose the expression followed by <code>;</code> in square brackets:</p>
<div id="09e8563a" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">collect</span>(<span class="fu">range</span>(<span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre class=""><code class=" ansi">3-element Vector{Float64}:
 1.0
 1.5
 2.0</code></pre>
</div>
</div>
<div id="ef31674c" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>[<span class="fu">range</span>(<span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>);]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre class=""><code class=" ansi">3-element Vector{Float64}:
 1.0
 1.5
 2.0</code></pre>
</div>
</div>
<p>New arrays can also be created from existing ones by concatenation via <code>cat(A...; dims)</code>, <code>hcat(A...)</code>, and <code>vcat(A...)</code>, where <code>A</code> is a list of arrays and <code>dims</code> are the dimensions along which to concatenate:</p>
<div id="335301b7" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="fu">ones</span>(<span class="fl">2</span>, <span class="fl">2</span>), <span class="fu">zeros</span>(<span class="fl">2</span>, <span class="fl">2</span>); dims<span class="op">=</span><span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre class=""><code class=" ansi">4×2 Matrix{Float64}:
 1.0  1.0
 1.0  1.0
 0.0  0.0
 0.0  0.0</code></pre>
</div>
</div>
<div id="a9ced02a" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="fu">ones</span>(<span class="fl">2</span>, <span class="fl">2</span>), <span class="fu">zeros</span>(<span class="fl">2</span>, <span class="fl">2</span>); dims<span class="op">=</span><span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre class=""><code class=" ansi">2×4 Matrix{Float64}:
 1.0  1.0  0.0  0.0
 1.0  1.0  0.0  0.0</code></pre>
</div>
</div>
<div id="bd617235" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="fu">ones</span>(<span class="fl">2</span>, <span class="fl">2</span>), <span class="fu">fill</span>(<span class="fl">2.0</span>, <span class="fl">2</span>, <span class="fl">2</span>); dims<span class="op">=</span>(<span class="fl">1</span>,<span class="fl">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre class=""><code class=" ansi">4×4 Matrix{Float64}:
 1.0  1.0  0.0  0.0
 1.0  1.0  0.0  0.0
 0.0  0.0  2.0  2.0
 0.0  0.0  2.0  2.0</code></pre>
</div>
</div>
<p>The command <code>vcat(A...)</code> is the same as <code>cat(A...; dims=1)</code> or <code>[a; b; c]</code> if <code>A = (a,b,c)</code>. Similarly, <code>hcat(A...)</code> is the same as <code>cat(A...; dims=2)</code> or <code>[a b c]</code> or <code>[a;; b;; c]</code>.</p>
<p>Julia also supports zero-dimensional array, which can be created by omitting the dimensional arguments to <code>zeros</code>, <code>ones</code> or <code>fill</code>:</p>
<div id="2ce66302" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zeros</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre class=""><code class=" ansi">0-dimensional Array{Float64, 0}:
0.0</code></pre>
</div>
</div>
<div id="f4c8739b" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fill</span>(<span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre class=""><code class=" ansi">0-dimensional Array{Int64, 0}:
3</code></pre>
</div>
</div>
<p>Next, we will see how to generate arrays whose values are initialized by evaluating a formula or a function.</p>
</section>
<section id="comprehensions-and-generators" class="level3" data-number="4.1.3">
<h3 data-number="4.1.3" class="anchored" data-anchor-id="comprehensions-and-generators"><span class="header-section-number">4.1.3</span> Comprehensions and generators</h3>
<p>Comprehensions allow for the initialization of arrays with the result of arbitrarily complex expressions that are evaluated on a range of values for each of their arguments. Two simple examples of a one- and a two-dimensional array are the following:</p>
<div id="59134b80" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>[ x<span class="op">^</span><span class="fl">2</span> for x <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span> ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 1
 4
 9</code></pre>
</div>
</div>
<div id="d403facd" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>[ <span class="fu">cos</span>(<span class="cn">π</span><span class="op">*</span>x) <span class="op">*</span> <span class="fu">sin</span>(<span class="cn">π</span><span class="op">*</span>y) for x <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="fl">1</span><span class="op">//</span><span class="fl">2</span><span class="op">:</span><span class="fl">1</span>, y <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="fl">1</span><span class="op">//</span><span class="fl">2</span><span class="op">:</span><span class="fl">2</span> ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre class=""><code class=" ansi">3×5 Matrix{Float64}:
  0.0   1.0           1.22465e-16  -1.0          -2.44929e-16
  0.0   6.12323e-17   7.4988e-33   -6.12323e-17  -1.49976e-32
 -0.0  -1.0          -1.22465e-16   1.0           2.44929e-16</code></pre>
</div>
</div>
<p>The dimension and size of the resulting array depend on the number of arguments and elements in the respective ranges. The element type depends on the result of the expression. Should the expression return values of different types depending on its input values, Julia tries to promote them to a common type in the same way as with array literals. Similarly, the element type can also be specified explicitly:</p>
<div id="fcaab859" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Float32</span>[ x<span class="op">^</span><span class="fl">2</span> for x <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span> ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre class=""><code class=" ansi">3-element Vector{Float32}:
 1.0
 4.0
 9.0</code></pre>
</div>
</div>
<p>If the square brackets are replaced with normal brackets, a comprehension returns a generator, similar to the range command in the previous section:</p>
<div id="00f39295" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>(x<span class="op">^</span><span class="fl">2</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre class=""><code class=" ansi">Base.Generator{UnitRange{Int64}, var"#15#16"}(var"#15#16"(), 1:3)</code></pre>
</div>
</div>
<p>Generators are objects that do not precompute their return values but can be evaluated on demand. When we enclose a generator in square brackets or pass it to <code>collect</code>, it is evaluated on all specified values for its arguments and the result is written into an array of the appropriate dimension.</p>
</section>
<section id="basic-linear-algebra" class="level3" data-number="4.1.4">
<h3 data-number="4.1.4" class="anchored" data-anchor-id="basic-linear-algebra"><span class="header-section-number">4.1.4</span> Basic linear algebra</h3>
<p>Julia comes with a comprehensive library of linear algebra operations. While some are defined in <code>Base</code>, most are contained in the <code>LinearAlgebra</code> module of the standard library.</p>
<p>Let us also define some example vectors <code>x</code> and <code>y</code> and a matrix <code>A</code> that we will use repeatedly in the examples:</p>
<div id="1eb33455" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [<span class="fl">3</span>, <span class="fl">2</span>, <span class="fl">1</span>]; y <span class="op">=</span> [<span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>]; A <span class="op">=</span> [<span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span>; <span class="fl">2</span> <span class="fl">1</span> <span class="fl">0</span>; <span class="fl">3</span> <span class="fl">0</span> <span class="fl">1</span>];</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The standard multiplication operator <code>*</code> denotes vector-vector, matrix-vector, matrix-matrix, etc., multiplication:</p>
<div id="42a8140f" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">*</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 10
  8
 10</code></pre>
</div>
</div>
<p>If the size of the arrays does not match, this operation will not be successful:</p>
<div id="41303c37" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">*</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching *(::Vector{Int64}, ::Vector{Int64})

Closest candidates are:
  *(::Any, ::Any, <span class="ansi-red-intense-fg">::Any</span>, <span class="ansi-red-intense-fg">::Any...</span>)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-black-intense-fg">Base</span> <span class="ansi-black-intense-fg ansi-underline">operators.jl:587</span>
  *(<span class="ansi-red-intense-fg">::SparseArrays.CHOLMOD.Sparse</span>, ::VecOrMat)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">SparseArrays</span> <span class="ansi-black-intense-fg">/Applications/Julia-1.10.app/Contents/Resources/julia/share/julia/stdlib/v1.10/SparseArrays/src/solvers/</span><span class="ansi-black-intense-fg ansi-underline">cholmod.jl:1218</span>
  *(<span class="ansi-red-intense-fg">::LinearAlgebra.UniformScaling</span>, ::AbstractVecOrMat)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-cyan-fg">LinearAlgebra</span> <span class="ansi-black-intense-fg">/Applications/Julia-1.10.app/Contents/Resources/julia/share/julia/stdlib/v1.10/LinearAlgebra/src/</span><span class="ansi-black-intense-fg ansi-underline">uniformscaling.jl:262</span>
  ...</code></pre>
</div>
</div>
<p>Thus, to compute the scalar product of two vectors, the left vector needs to be transposed, which can be achieved by appending the adjoint operator <code>'</code> to the vector:</p>
<div id="62d94ac4" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>x<span class="op">'</span> <span class="op">*</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre class=""><code class=" ansi">10</code></pre>
</div>
</div>
<p>This is not the same as taking the adjoint of the right vector:</p>
<div id="ad33e287" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">*</span> y<span class="op">'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre class=""><code class=" ansi">3×3 Matrix{Int64}:
 3  6  9
 2  4  6
 1  2  3</code></pre>
</div>
</div>
<div data-custom-style="PCallout">
<p>Note that the adjoint operator does not only transpose the array but also applies complex conjugation in the case of complex-valued arrays. For real-valued arrays, this does not make a difference. However, if strict transposition is desired, the <code>transpose</code> command can be used instead of the adjoint operator or the <code>adjoint</code> command.</p>
</div>
<p>The following examples require to load the <code>LinearAlgebra</code> module:</p>
<div id="3dfb9aab" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The scalar product can also be computed with the <code>⋅</code> operator (typed <code>\cdot</code> followed by <code>&lt;tab&gt;</code>):</p>
<div id="e55290db" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">⋅</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre class=""><code class=" ansi">10</code></pre>
</div>
</div>
<p>Similarly, the cross product of two vectors can be computed with <code>×</code> (types <code>\times</code> followed by <code>&lt;tab&gt;</code>):</p>
<div id="05f014fe" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">×</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
  4
 -8
  4</code></pre>
</div>
</div>
<p>The <code>LinearAlgebra</code> module includes many standard operations such as <code>det</code>, <code>tr</code>, <code>inv</code>, <code>eigvals</code>, and <code>eigvecs</code> for the determinant of a matrix, its trace, its inverse, its eigenvalues and eigenvectors, respectively. It allows to solve linear systems with the <code>\</code> operator:</p>
<div id="084711e7" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">\</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre class=""><code class=" ansi">3-element Vector{Float64}:
  0.3333333333333333
  1.3333333333333335
 -1.1102230246251565e-16</code></pre>
</div>
</div>
<p>The <code>LinearAlgebra</code> module also provides special matrix types, such as the identity matrix, symmetric and Hermitian matrices, and contains a broad selection of methods for matrix factorization and the solution of linear systems. Many of the operations are also provided as in-place variants. For a detailed overview of the available methods, please see the section on the Linear Algebra module of the Standard Library in the Julia manual.</p>
</section>
<section id="element-wise-operations-and-vectorization" class="level3" data-number="4.1.5">
<h3 data-number="4.1.5" class="anchored" data-anchor-id="element-wise-operations-and-vectorization"><span class="header-section-number">4.1.5</span> Element-wise operations and vectorization</h3>
<p>All of the above operations acted on vectors and matrices as a whole. If instead an operation should be applied element-wise, the dot syntax can be used, e.g.:</p>
<div id="99216478" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">.*</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 3
 4
 3</code></pre>
</div>
</div>
<p>This is often referred to as vectorization or broadcasting, a topic that we will discuss in more detail later in this chapter. The dot syntax can be applied to arithmetic operators, such as <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, and <code>^</code>, to comparison operators, such as <code>==</code>, <code>!=</code>, <code>≈</code>, and <code>≉</code>, as well as to general scalar operations, such as <code>cos</code>, <code>sin</code>, <code>exp</code>, or <code>abs</code>:</p>
<div id="6f55271b" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cos</span>.(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="44">
<pre class=""><code class=" ansi">3×3 Matrix{Float64}:
  0.540302  -0.416147  -0.989992
 -0.416147   0.540302   1.0
 -0.989992   1.0        0.540302</code></pre>
</div>
</div>
<p>If a composition of operations shall be applied, they can be fused by using several <code>.</code> operations:</p>
<div id="b66d40d8" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">acos</span>.(<span class="fu">cos</span>.(A <span class="op">./</span> <span class="fl">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre class=""><code class=" ansi">3×3 Matrix{Float64}:
 0.5  1.0  1.5
 1.0  0.5  0.0
 1.5  0.0  0.5</code></pre>
</div>
</div>
<p>If a composition is more complicated or has many elements, it is often easier to precede the corresponding expression with the <code>@.</code> macro, which applies broadcasting to every function call in the expression, instead of applying the dot syntax to each single function call manually:</p>
<div id="6fd54625" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>@. <span class="fu">acos</span>(<span class="fu">cos</span>(A <span class="op">/</span> <span class="fl">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre class=""><code class=" ansi">3×3 Matrix{Float64}:
 0.5  1.0  1.5
 1.0  0.5  0.0
 1.5  0.0  0.5</code></pre>
</div>
</div>
<p>In the next section, we will have a brief look at Julia’s standard <code>Array</code> type.</p>
</section>
<section id="the-array-type" class="level3" data-number="4.1.6">
<h3 data-number="4.1.6" class="anchored" data-anchor-id="the-array-type"><span class="header-section-number">4.1.6</span> The array type</h3>
<p>In the examples above, we have seen many objects whose types were indicated as <code>Vector</code> or <code>Matrix</code>. These are not actual types but merely aliases to the generic array type <code>Array{T,N}</code> with the dimension type parameter <code>N</code> set to <code>1</code> or <code>2</code>, respectively:</p>
<div id="8f7de157" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Vector</span>{T} <span class="op">=</span> <span class="dt">Array</span>{T,<span class="fl">1</span>}</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Matrix</span>{T} <span class="op">=</span> <span class="dt">Array</span>{T,<span class="fl">2</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The other type parameter, <code>T</code>, denotes the element type. Thus, a <code>Vector{Int64}</code> is an <code>Array{Int64,1}</code> and a <code>Matrix{Float64}</code> is an <code>Array{Float64,2}</code> as Julia is not too shy to tell us:</p>
<div id="aa90eb45" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Vector</span>{<span class="dt">Int64</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre class="ansi"><code class="ansi ansi">Vector{Int64}<span class="ansi-black-intense-fg"> (alias for </span><span class="ansi-black-intense-fg">Array{Int64, 1}</span><span class="ansi-black-intense-fg">)</span></code></pre>
</div>
</div>
<div id="fa0f74bf" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Matrix</span>{<span class="dt">Float64</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre class="ansi"><code class="ansi ansi">Matrix{Float64}<span class="ansi-black-intense-fg"> (alias for </span><span class="ansi-black-intense-fg">Array{Float64, 2}</span><span class="ansi-black-intense-fg">)</span></code></pre>
</div>
</div>
<p>Aside from literals and all the convenience constructors we have seen, we can also create uninitialized arrays using the default constructor, <code>Array{T}(undef, dims...)</code>, where the first argument <code>undef</code> refers to the <code>UndefInitializer</code> and <code>dims</code> correspond to the size of each dimension:</p>
<div id="a4a93d7f" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{Int64}</span>(<span class="cn">undef</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="49">
<pre class=""><code class=" ansi">2-element Vector{Int64}:
 4496736976
 5206595632</code></pre>
</div>
</div>
<div id="997b0e08" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="fu">Array</span><span class="dt">{Float64,2}</span>(<span class="cn">undef</span>, <span class="fl">2</span>, <span class="fl">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre class=""><code class=" ansi">2×4 Matrix{Float64}:
 5.0e-324  NaN         2.5e-323    3.5e-323
 1.0e-323    2.0e-323  3.0e-323  NaN</code></pre>
</div>
</div>
<p>Julia provides several functions to retrieve information about an array, for example, <code>ndims</code> for the number of dimensions, <code>length</code> for the number of elements, and <code>size</code> for the sizes of each dimension:</p>
<div id="be407a83" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ndims</span>(w)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<pre class=""><code class=" ansi">2</code></pre>
</div>
</div>
<div id="ef91a3c3" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(w)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<pre class=""><code class=" ansi">8</code></pre>
</div>
</div>
<div id="57f70a79" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">size</span>(w)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<pre class=""><code class=" ansi">(2, 4)</code></pre>
</div>
</div>
<div id="6ea0a72a" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">size</span>(w, <span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre class=""><code class=" ansi">2</code></pre>
</div>
</div>
<p>The <code>axes</code> function returns the index ranges for each dimension:</p>
<div id="fb4a3edc" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">axes</span>(w)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="55">
<pre class=""><code class=" ansi">(Base.OneTo(2), Base.OneTo(4))</code></pre>
</div>
</div>
<div id="711a6fe3" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">axes</span>(w, <span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<pre class=""><code class=" ansi">Base.OneTo(2)</code></pre>
</div>
</div>
<p>We will use the <code>axes</code> function later on when discussing how to iterate over arrays. Another useful function is <code>eltype</code> which returns the type of an array’s elements:</p>
<div id="ac28566d" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eltype</span>(w)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre class=""><code class=" ansi">Float64</code></pre>
</div>
</div>
<p>As the <code>Array</code> type is parametric, with the element type and dimension as type parameters, it is concrete only when all its type parameters are specified. This is of particular importance when arrays serve as fields in composite types.</p>
</section>
<section id="arrays-as-fields-in-composite-types" class="level3" data-number="4.1.7">
<h3 data-number="4.1.7" class="anchored" data-anchor-id="arrays-as-fields-in-composite-types"><span class="header-section-number">4.1.7</span> Arrays as fields in composite types</h3>
<p>When directly accessing fields of a composite type in a performance-critical part of the code, most prominently from within a loop, it is crucial for the types of those fields to be fully specified. For a scalar number, it suffices to provide the number type, but for arrays both the element type and the dimension have to be specified:</p>
<div id="b1f1e4ad" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyTypedType</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    x<span class="op">::</span><span class="dt">Float64</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">::</span><span class="dt">Vector{Float64}</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let us define a simple function that operates on this type by multiplying the scalar <code>x</code> with each element of <code>A</code> and summing the result:</p>
<div id="42599c44" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">scaledsum</span>(m)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="fu">zero</span>(m.x)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> m.A</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        s <span class="op">+=</span> m.x <span class="op">*</span> a</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="59">
<pre class=""><code class=" ansi">scaledsum (generic function with 1 method)</code></pre>
</div>
</div>
<p>Now check the runtime and allocations with the <code>@btime</code> macro from the BenchmarkTools.jl package:</p>
<div id="cd87f643" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fu">MyTypedType</span>(<span class="fl">3.0</span>, <span class="fu">rand</span>(<span class="fl">100</span>))</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">scaledsum</span>(m);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">  32.737 ns (0 allocations: 0 bytes)</code></pre>
</div>
</div>
<p>Everything seems fine: the runtime is very short and there are no allocations. This changes if we do not specify concrete types for the fields in our type:</p>
<div id="b1b55ff6" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyUntypedType</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    x<span class="op">::</span><span class="dt">Real</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">::</span><span class="dt">Vector</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fu">MyUntypedType</span>(<span class="fl">3.0</span>, <span class="fu">rand</span>(<span class="fl">100</span>))</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">scaledsum</span>(m);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">  9.375 μs (300 allocations: 4.69 KiB)</code></pre>
</div>
</div>
<p>The runtime increases by a large factor and we observe a similarly large number of allocations for temporary data structures. With the types not specified, Julia needs to create boilerplate code that wraps the fields of our composite type and prevents the generation of optimized and efficient code.</p>
<p>Even though <code>MyTypedType</code> prevents these issues, in practice, its implementation is not ideal as it specifies <code>x</code> as well as the elements of <code>A</code> to be of type <code>Float64</code>. This is very specific, limiting the reusability of this type. For example, we cannot use it for solving a problem on GPUs that only support <code>Float32</code> values. This problem can easily be avoided by adding a type parameter similar to the <code>Array</code> type:</p>
<div id="ddfba28d" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyType{T}</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    x<span class="op">::</span><span class="dt">T</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">::</span><span class="dt">Vector{T}</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With this, we get both efficient and general code:</p>
<div id="c6297e86" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fu">MyType</span>(<span class="fl">3.0f0</span>, <span class="fu">rand</span>(<span class="dt">Float32</span>, <span class="fl">100</span>))</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">scaledsum</span>(m);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">  12.012 ns (0 allocations: 0 bytes)</code></pre>
</div>
</div>
<p>Note that for simple types like this, the default constructor is able to figure out the type parameters and there is no need to provide custom constructors. This may be different in more complex composite types.</p>
<p>While the definition of <code>MyType{T}</code> is a typical design pattern in Julia, it can be overkill in some situations. There is no strict need to specify all the types of a composite type’s fields if they are never directly accessed in computation-heavy code. The fields could be passed individually to computational functions instead. This is often referred to as a function call barrier. When a function is called, Julia generates and compiles optimized code for the specific types of the arguments, but only if they can be uniquely determined. If we pass an instance of <code>MyUntypedType</code> Julia cannot uniquely determine the types of its fields. However, if we pass its fields <code>x</code> and <code>A</code> individually to a function, Julia can figure out their types and generate efficient code.</p>
<p>To this end, we need to implement a second <code>scaledsum</code> method, that takes a scalar and an array instead of a composite type that holds these two values:</p>
<div id="c23f7b22" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">scaledsum</span>(x, A)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="fu">zero</span>(x)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> A</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>        s <span class="op">+=</span> x <span class="op">*</span> a</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre class=""><code class=" ansi">scaledsum (generic function with 2 methods)</code></pre>
</div>
</div>
<p>If we call this on the fields of <code>MyUntypedType</code> instead of a <code>MyUntypedType</code> value directly, we still obtain good performance without unnecessary allocations:</p>
<div id="fcd34b48" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fu">MyUntypedType</span>(<span class="fl">3.0</span>, <span class="fu">rand</span>(<span class="fl">100</span>))</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">scaledsum</span>(m.x, m.A);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">  43.180 ns (0 allocations: 0 bytes)</code></pre>
</div>
</div>
<p>Note, however, that there is still some overhead for extracting the field values from the object:</p>
<div id="a36f3aef" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fu">MyUntypedType</span>(<span class="fl">3.0</span>, <span class="fu">rand</span>(<span class="fl">100</span>))</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> m.x</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> m.A</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">scaledsum</span>(x, A);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">  11.678 ns (0 allocations: 0 bytes)</code></pre>
</div>
</div>
<p>Which of the two approaches is more appropriate depends very much on the problem at hand. If a function operates on many fields of a complex composite type, passing all the fields individually seems unpractical and will often result in code that is hard to read. On the other hand, composite types with a substantial number of fields, which may be of parametric types themselves, can easily require a large number of type parameters making the type hard to understand and its handling unnecessarily complicated.</p>
<p>This concludes the section on how arrays are created and handled. Next, we discuss the various ways of indexing arrays, looping over their elements, and applying maps to the elements of an array.</p>
</section>
</section>
<section id="indexing" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="indexing"><span class="header-section-number">4.2</span> Indexing</h2>
<p>In this section, we will discuss the different ways of indexing arrays, cartesian indexing and linear indexing, how to assign values, and how to generate views instead of copies when accessing array elements.</p>
<section id="basic-indexing" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="basic-indexing"><span class="header-section-number">4.2.1</span> Basic indexing</h3>
<p>Basic array indexing works the same way as for tuples and other collections using square bracket notation:</p>
<div id="8fbe2607" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fu">collect</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">10</span>)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>a[<span class="fl">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="67">
<pre class=""><code class=" ansi">3</code></pre>
</div>
</div>
<p>Index ranges are specified the same as standard ranges:</p>
<div id="4e9fa22f" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>a[<span class="fl">4</span><span class="op">:</span><span class="fl">6</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 4
 5
 6</code></pre>
</div>
</div>
<div id="5289de5e" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>a[<span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">:</span><span class="fl">9</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 1
 4
 7</code></pre>
</div>
</div>
<p>Julia supports two keywords for denoting the first and last element of an array, namely <code>begin</code> and <code>end</code>:</p>
<div id="8f2263df" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>a[begin], a[<span class="kw">end</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre class=""><code class=" ansi">(1, 10)</code></pre>
</div>
</div>
<p>The <code>begin</code> and <code>end</code> keywords also allow for index arithmetics:</p>
<div id="aec62fe8" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>a[begin<span class="op">+</span><span class="fl">2</span>], a[<span class="kw">end</span><span class="op">-</span><span class="fl">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre class=""><code class=" ansi">(3, 8)</code></pre>
</div>
</div>
<p>A zero-dimensional array is indexed by empty square brackets:</p>
<div id="6a894d0d" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">fill</span>(<span class="cn">π</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>z[]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre class=""><code class=" ansi">π = 3.1415926535897...</code></pre>
</div>
</div>
<p>Note that in this example <code>c</code> refers to the array object and <code>c[]</code> to the value of its only element. We can also use logical expressions to index an array:</p>
<div id="6e091fef" class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>a[a <span class="op">.%</span> <span class="fl">3</span> <span class="op">.==</span> <span class="fl">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 3
 6
 9</code></pre>
</div>
</div>
<p>Here, the index corresponds to a bit mask, which is an array of the same size as <code>a</code> that contains either <code>true</code> for those indices whose values should be returned, or <code>false</code> for those values that should be omitted.</p>
</section>
<section id="cartesian-indexing" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="cartesian-indexing"><span class="header-section-number">4.2.2</span> Cartesian indexing</h3>
<p>These were just the most basic examples of indexing a vector. In general, an n-dimensional array <code>A</code> is indexed using <span class="PKeyword" data-custom-style="PKeyword">cartesian indexing</span> via:</p>
<div id="23dba229" class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>A[I_1, I_2, <span class="op">...</span>, I_n]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We have to provide a separate set of indices <code>I_k</code> for each dimension. Each <code>I_k</code> can be any type of supported indices, e.g., a scalar integer, an array of integers or booleans, a range, a <code>CartesianIndex{N}</code>, an array thereof, a colon <code>:</code>, representing all indices of the respective dimension, or the aforementioned keywords <code>begin</code> and <code>end</code>. Let us consider some examples:</p>
<div id="1655a898" class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fu">reshape</span>(a, (<span class="fl">2</span>,<span class="fl">5</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">
<pre class=""><code class=" ansi">2×5 Matrix{Int64}:
 1  3  5  7   9
 2  4  6  8  10</code></pre>
</div>
</div>
<div id="a98f4eac" class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>b[<span class="op">:</span>, <span class="fl">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre class=""><code class=" ansi">2-element Vector{Int64}:
 5
 6</code></pre>
</div>
</div>
<div id="32febe36" class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>b[<span class="fl">1</span><span class="op">:</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">:</span><span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<pre class=""><code class=" ansi">1×3 Matrix{Int64}:
 3  5  7</code></pre>
</div>
</div>
<div id="5ca08e53" class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>b[<span class="fl">2</span>, [<span class="fl">2</span>,<span class="fl">4</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<pre class=""><code class=" ansi">2-element Vector{Int64}:
 4
 8</code></pre>
</div>
</div>
<div id="a61e88c7" class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>b[[<span class="fl">2</span>], [<span class="fl">2</span>,<span class="fl">4</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">
<pre class=""><code class=" ansi">1×2 Matrix{Int64}:
 4  8</code></pre>
</div>
</div>
<div id="abea6ed2" class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>b[(<span class="fl">1</span>, <span class="fl">2</span><span class="op">:</span><span class="fl">4</span>)<span class="op">...</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="79">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 3
 5
 7</code></pre>
</div>
</div>
<p>In the last example, we used tuple unpacking. This can be useful if indices are provided programmatically. The same is true for the <code>CartesianIndex{N}</code> object. It represents a multidimensional index containing <code>N</code> scalar indices and behaves similarly to an <code>N</code>-tuple. It can be used to index any number of dimensions in an array. As an example, let us consider a three-dimensional array:</p>
<div id="4147b319" class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">reshape</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">27</span>, (<span class="fl">3</span>,<span class="fl">3</span>,<span class="fl">3</span>)));</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can use a <code>CartesianIndex</code> to index each dimension individually, like with scalar indices:</p>
<div id="fb3bc721" class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>c[<span class="fu">CartesianIndex</span>(<span class="fl">1</span>), <span class="fu">CartesianIndex</span>(<span class="fl">2</span>), <span class="fu">CartesianIndex</span>(<span class="fl">3</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">
<pre class=""><code class=" ansi">22</code></pre>
</div>
</div>
<p>We can also use a <code>CartesianIndex</code> to index all dimensions at once:</p>
<div id="ef21c1a2" class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>c[<span class="fu">CartesianIndex</span>(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="82">
<pre class=""><code class=" ansi">22</code></pre>
</div>
</div>
<p>But we can also use cartesian indices to index any subset of dimensions:</p>
<div id="499ecbf6" class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>c[<span class="fl">1</span>, <span class="fu">CartesianIndex</span>(<span class="fl">2</span>,<span class="fl">3</span>)] <span class="op">==</span> c[<span class="fu">CartesianIndex</span>(<span class="fl">1</span>,<span class="fl">2</span>), <span class="fl">3</span>] <span class="op">==</span> <span class="fl">22</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="83">
<pre class=""><code class=" ansi">true</code></pre>
</div>
</div>
<p>As we will see in the next section on <span class="PItalics" data-custom-style="PItalics">looping and mapping</span>, Julia uses <code>CartesianIndex</code> internally when iterating over arrays, but it can also be beneficial to use <code>CartesianIndex</code> programmatically. For example, we can use an array of <code>CartesianIndex</code> to index another array, e.g., to extract the diagonal elements of an array:</p>
<div id="83f47bcb" class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>c[[<span class="fu">CartesianIndex</span>(i,i,i) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="84">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
  1
 14
 27</code></pre>
</div>
</div>
<p>In all of the examples, we have seen so far, we provided separate indices for each dimension, which is referred to as cartesian indexing.</p>
<div data-custom-style="PCallout">
<p>Note that arrays can be indexed with more indices than they have dimensions, but the index in the additional dimensions can only take the value <code>1</code>:</p>
<div id="2d49dc21" class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>c[<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">1</span>,<span class="fl">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="85">
<pre class=""><code class=" ansi">22</code></pre>
</div>
</div>
<p>On the other hand, it is not allowed to omit indices, i.e., to specify only two indices of a three-dimensional array:</p>
<div id="55c192aa" class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>c[<span class="fl">1</span>,<span class="fl">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: BoundsError: attempt to access 3×3×3 Array{Int64, 3} at index [1, 2]</code></pre>
</div>
</div>
<p>There is only one exception: omitting trailing dimensions of length 1:</p>
<div id="188903e6" class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">reshape</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">6</span>, (<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">1</span>)))</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>d[<span class="fl">1</span>,<span class="fl">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="87">
<pre class=""><code class=" ansi">3</code></pre>
</div>
</div>
</div>
<p>Julia also supports an alternative way of indexing arrays: linear indexing. This is discussed in the next section.</p>
</section>
<section id="linear-indexing" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="linear-indexing"><span class="header-section-number">4.2.3</span> Linear indexing</h3>
<p>Multidimensional arrays can also be indexed by just one index. This is referred to as linear indexing. In memory, arrays are stored as a linear sequence of elements. Different programming languages use a different ordering for these elements. For example, C, C++ and Python use so-called row-major ordering, where matrices are stored row-by-row, whereas Fortran, Julia, Matlab and R use so-called column-major ordering, where matrices are stored column-by-column, and higher-dimensional arrays accordingly.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/memory-layout.png" class="img-fluid figure-img"></p>
<figcaption>Memory layout: row-major (top) vs.&nbsp;column-major (bottom).</figcaption>
</figure>
</div>
<p>With linear indexing, the index corresponds to the position of an element in memory when the array is viewed as a one-dimensional object, such as if the array had been reshaped into a vector:</p>
<div id="676f6821" class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">reshape</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">6</span>, (<span class="fl">2</span>,<span class="fl">3</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="88">
<pre class=""><code class=" ansi">2×3 Matrix{Int64}:
 1  3  5
 2  4  6</code></pre>
</div>
</div>
<div id="2020ccf2" class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>d[<span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="89">
<pre class=""><code class=" ansi">4</code></pre>
</div>
</div>
<p>At first glance, linear indexing may seem like another exception to the cartesian indexing rule that we have to provide an index for each dimension of an array, but it truly is a different way of indexing.</p>
<div data-custom-style="PCallout">
<p>Note that linear indexing takes precedence over the omission of trailing dimensions of length 1.</p>
</div>
<p>Linear indices can be converted into cartesian indices and vice versa using the <code>LinearIndices</code> and <code>CartesianIndices</code> objects as follows:</p>
<div id="547707d0" class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="fu">CartesianIndices</span>(d)[<span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="90">
<pre class=""><code class=" ansi">CartesianIndex(2, 2)</code></pre>
</div>
</div>
<div id="6a4e14c2" class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="fu">LinearIndices</span>(d)[<span class="fl">2</span>,<span class="fl">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="91">
<pre class=""><code class=" ansi">4</code></pre>
</div>
</div>
<p>We will come back to linear indexing when we discuss how to iterate over an array.</p>
</section>
<section id="value-assignment" class="level3" data-number="4.2.4">
<h3 data-number="4.2.4" class="anchored" data-anchor-id="value-assignment"><span class="header-section-number">4.2.4</span> Value assignment</h3>
<p>Values of an n-dimensional array <code>A</code> are set using the same cartesian indexing notation we have seen before:</p>
<div id="f2c78562" class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>A[I_1, I_2, <span class="op">...</span>, I_n] <span class="op">=</span> X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As before each <code>I_k</code> can be any type of supported indices, including the colon <code>:</code>, <code>begin</code> and <code>end</code> keywords. If a single element is selected, the value <code>X</code> on the right-hand side has to be a scalar value. If a subarray of <code>A</code> is selected by the indices <code>I_k</code>, the value <code>X</code> must be either an array whose size and dimension match that of the selected subarray or a vector whose length equals the number of elements of the subarray. The selected values of <code>A</code> are overwritten with the corresponding values of <code>X</code>, specifically the value <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code> is overwritten with the value <code>X[i_1, i_2, ..., i_n]</code>. Let us consider some examples:</p>
<div id="facbf549" class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">reshape</span>(<span class="fl">1.0</span><span class="op">:</span><span class="fl">6.0</span>, (<span class="fl">2</span>,<span class="fl">3</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="92">
<pre class=""><code class=" ansi">2×3 Matrix{Float64}:
 1.0  3.0  5.0
 2.0  4.0  6.0</code></pre>
</div>
</div>
<div id="8b825f16" class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>d[<span class="fl">2</span>, <span class="fl">3</span>] <span class="op">=</span> <span class="fl">36</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>d[<span class="op">:</span>, <span class="fl">1</span>] <span class="op">=</span> [<span class="op">-</span><span class="fl">1</span>., <span class="op">-</span><span class="fl">2</span>.]</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>d[<span class="fl">1</span>, <span class="fl">2</span><span class="op">:</span><span class="fl">3</span>] <span class="op">=</span> d[<span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fl">2</span>]<span class="op">.^</span><span class="fl">2</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">
<pre class=""><code class=" ansi">2×3 Matrix{Float64}:
 -1.0  9.0  16.0
 -2.0  4.0  36.0</code></pre>
</div>
</div>
<p>Should the elements of <code>X</code> have a different type than the elements of <code>A</code>, they are converted appropriately if possible.</p>
<div data-custom-style="PCallout">
<p>Note that Julia throws an error if the dimension of the left-hand side and right-hand side expressions do not match, even if the right-hand side value is a scalar:</p>
<div id="da3feb8d" class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>d[<span class="op">:</span>] <span class="op">=</span> <span class="fl">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: ArgumentError: indexed assignment with a single value to possibly many locations is not supported; perhaps use broadcasting `.=` instead?</code></pre>
</div>
</div>
</div>
<p>Similar to element-wise operation on arrays, the dot notation can be used to set values of an array element-wise. For example, the following expression sets all the selected elements of <code>A</code> to the scalar value <code>x</code>:</p>
<div id="b426da5d" class="cell" data-execution_count="97">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>A[I_1, I_2, <span class="op">...</span>, I_n] <span class="op">.=</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This works also without selecting specific elements (this is the correct version of the erroneous expression <code>d[:] = 1</code> shown above):</p>
<div id="acd119cb" class="cell" data-execution_count="98">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">.=</span> <span class="fl">1</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="95">
<pre class=""><code class=" ansi">2×3 Matrix{Float64}:
 1.0  1.0  1.0
 1.0  1.0  1.0</code></pre>
</div>
</div>
<p>The dot notation also allows for applying arithmetic operations element-wise and inplace using the <code>.+=</code>, <code>.-=</code>, <code>.*=</code>, <code>./=</code>, and <code>.^=</code> operators, which all have the obvious meaning, e.g.:</p>
<div id="dba34e10" class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">reshape</span>(<span class="fl">1.0</span><span class="op">:</span><span class="fl">6.0</span>, (<span class="fl">2</span>,<span class="fl">3</span>)))</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">.^=</span> <span class="fl">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="96">
<pre class=""><code class=" ansi">2×3 Matrix{Float64}:
 1.0   9.0  25.0
 4.0  16.0  36.0</code></pre>
</div>
</div>
<p>Vectorized assignments using the dot syntax are closely related to broadcasts, which will be discussed in the next section, but before that, we will conclude this section with another important aspect of accessing arrays.</p>
</section>
<section id="views" class="level3" data-number="4.2.5">
<h3 data-number="4.2.5" class="anchored" data-anchor-id="views"><span class="header-section-number">4.2.5</span> Views</h3>
<p>If we access an array via <span class="PKeyword" data-custom-style="PKeyword">slicing</span>, Julia will create a copy of the subarray we selected unless it is on the left-hand side of an assignment. To exemplify what that means, let us create an array, select a slice, and change some of its values:</p>
<div id="71fd553e" class="cell" data-execution_count="100">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">reshape</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">6</span>, (<span class="fl">2</span>,<span class="fl">3</span>)))</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a[<span class="fl">1</span>, <span class="op">:</span>]</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">.*=</span> <span class="fl">2</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="97">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
  2
  6
 10</code></pre>
</div>
</div>
<div id="1e6ca04a" class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="98">
<pre class=""><code class=" ansi">2×3 Matrix{Int64}:
 1  3  5
 2  4  6</code></pre>
</div>
</div>
<p>We see that <code>a</code> has not changed, because when we changed <code>b</code> we operated on a copy of the elements of <code>a</code>. While copying data is not always bad and can in fact be advantageous for performance (more on that below) it can just as well be very detrimental for performance if more time is spent on allocating and copying than on computing.</p>
<p>Copying can be avoided by using views. A view is a wrapper around an array that behaves like an array but does not store actual data. Instead, it references the data of the array it wraps and only translates the indices on which it is evaluated into the corresponding indices of the original array.</p>
<p>Julia provides several ways to create views. The easiest way to use views instead of copies is by writing the <code>@views</code> macro at the beginning of a code line:</p>
<div id="83fc8364" class="cell" data-execution_count="102">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@views</span> b <span class="op">=</span> a[<span class="fl">1</span><span class="op">:</span><span class="fl">1</span>, <span class="op">:</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="99">
<pre class=""><code class=" ansi">1×3 view(::Matrix{Int64}, 1:1, :) with eltype Int64:
 1  3  5</code></pre>
</div>
</div>
<p>If we change <code>b</code> now, we also change <code>a</code>:</p>
<div id="7a87de9e" class="cell" data-execution_count="103">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>b <span class="op">.*=</span> <span class="fl">2</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="100">
<pre class=""><code class=" ansi">1×3 view(::Matrix{Int64}, 1:1, :) with eltype Int64:
 2  6  10</code></pre>
</div>
</div>
<div id="3545d4d1" class="cell" data-execution_count="104">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="101">
<pre class=""><code class=" ansi">2×3 Matrix{Int64}:
 2  6  10
 2  4   6</code></pre>
</div>
</div>
<p>The <code>@views</code> macro creates views for all array slices in an expression. If we want to use views in more than just one line of code, we can encapsulate the respective code using <code>begin</code> and <code>end</code> or any other code block delimiter such as <code>for ... end</code> or <code>while ... end</code>:</p>
<div id="1de4872a" class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@views</span> <span class="cf">begin</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># code to use views ...</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>More granular control is facilitated by the <code>@view</code> macro, which acts only on the following array, for example in a function call:</p>
<div id="0f8502cf" class="cell" data-execution_count="106">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(x, y) <span class="op">=</span> x <span class="op">.+</span> y</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(b[<span class="fl">1</span>,<span class="op">:</span>], <span class="pp">@view</span> a[<span class="fl">1</span>,<span class="op">:</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="103">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
  4
 12
 20</code></pre>
</div>
</div>
<p>Here, a view is created only for the slice of <code>a</code> but not for the slice of <code>b</code> which is copied instead.</p>
<div data-custom-style="PCallout">
<p>Using the <code>@view</code> macro like this, a bit of care is needed. Consider the following expression that results in an error:</p>
<div id="d4a70a5d" class="cell" data-execution_count="107">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(<span class="pp">@view</span> a[<span class="fl">1</span>,<span class="op">:</span>], b[<span class="fl">1</span>,<span class="op">:</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: LoadError: ArgumentError: Invalid use of @view macro: argument must be a reference expression A[...].
in expression starting at In[104]:1</code></pre>
</div>
</div>
<p>This is due to the way Julia is parsing macros. Macro arguments can either be separated by spaces or by brackets like in a function call. If spaces are used, like in this example, Julia assumes that everything that follows belongs to the macro’s arguments. Here, the tuple <code>(a[1,:], b[1,:])</code> is passed instead of just <code>a[1,:]</code>, but the macro does not expect such a tuple as its argument. This can be avoided by using bracket syntax instead of space syntax:</p>
<div id="4ea319d1" class="cell" data-execution_count="108">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(<span class="pp">@view</span>(a[<span class="fl">1</span>,<span class="op">:</span>]), b[<span class="fl">1</span>,<span class="op">:</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="105">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
  4
 12
 20</code></pre>
</div>
</div>
</div>
<p>Lastly, views can also be created with the <code>view(A, I_1, I_2, ..., I_n)</code> function, which takes an array <code>A</code> as its first argument and any type of supported indices <code>I_k</code> for each of the array’s dimensions as consecutive arguments. Therefore, the following two expression are equivalent:</p>
<div id="77a5cd1c" class="cell" data-execution_count="109">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="fu">view</span>(A, I_1, I_2, <span class="op">...</span>, I_n)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="pp">@view</span> A[I_1, I_2, <span class="op">...</span>, I_n]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The type that represents a view is the <code>SubArray</code> type. It is rarely necessary to directly interact with this type or its constructors, as the <code>view</code> function and macros are more than sufficient for creating views and there exist convenience functions for retrieving additional information. For example, the array wrapped by a view can be retrieved with the <code>parent</code> function:</p>
<div id="c6a84b21" class="cell" data-execution_count="110">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parent</span>(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="106">
<pre class=""><code class=" ansi">2×3 Matrix{Int64}:
 2  6  10
 2  4   6</code></pre>
</div>
</div>
<p>The indices of the parent array that correspond to the view can be retrieved with the <code>parentindices</code> function:</p>
<div id="69835673" class="cell" data-execution_count="111">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parentindices</span>(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="107">
<pre class=""><code class=" ansi">(1:1, Base.Slice(Base.OneTo(3)))</code></pre>
</div>
</div>
<p>The <code>SubArray</code> type is implemented very efficiently. For example, index substitution does not cause any runtime overhead. Still, there are cases when views are actually less performant than copies of subarrays. Depending on the index pattern of the subarray, its elements can be scattered in memory. The irregular access patterns required to loop through such an array can result in memory access times dominating the runtime of an algorithm, in particular if repeated access is required. If the data is copied beforehand, the resulting array will be stored in a contiguous chunk of memory, allowing for CPU vectorization, more efficient memory access and caching.</p>
</section>
</section>
<section id="looping-mapping-broadcasting" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="looping-mapping-broadcasting"><span class="header-section-number">4.3</span> Looping, mapping, broadcasting</h2>
<p>In this section, we discuss how to iterate over arrays, in particular how to write generic code that applies to different array types with different indexing, and how and when to use maps and broadcasts instead of loops.</p>
<section id="loops" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="loops"><span class="header-section-number">4.3.1</span> Loops</h3>
<p>Albeit Julia supports a variety of options for looping through arrays, only two of them lead to generic code. If the code in the loop only needs the values of the array elements, we can use the following pattern:</p>
<div id="ddf692c2" class="cell" data-execution_count="112">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> A</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Code that operates on a ...</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If the index is needed in addition to the value, we can use the following pattern instead:</p>
<div id="460be504" class="cell" data-execution_count="113">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="fu">eachindex</span>(A)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Code that operates on i and/or A[i] ...</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With these looping patterns, Julia automatically picks the most efficient way of looping through the array. If the array <code>A</code> supports linear indexing, <code>i</code> will be an integer, otherwise it will be a <code>CartesianIndex</code>. If more than one array is indexed, the different arrays may have different default iterators. In this case, we can apply <code>eachindex</code> to all arrays as in <code>eachindex(A,B)</code> so that it can pick the most efficient iterator that is applicable to all arrays.</p>
<p>It is also possible to loop through a single dimension of an n-dimensional array. To this end, the <code>axes</code> function can be used as follows:</p>
<div id="b58b9b90" class="cell" data-execution_count="114">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="fu">axes</span>(A, <span class="fl">2</span>)</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Code that operates on j and/or A[:,j] ...</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It is also possible to loop through an array in a more classical fashion specifying the start and stop indices, e.g.:</p>
<div id="7c07d302" class="cell" data-execution_count="115">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(A)</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Code that operates on i and/or A[i] ...</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(A,<span class="fl">2</span>)</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Code that operates on j and/or A[:,j] ...</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first example uses linear indexing whereas the second example uses cartesian indexing.</p>
<div data-custom-style="PCallout">
<p>This indexing pattern is not recommended as it is only applicable to arrays whose index range starts at 1. However, as we will discuss in a moment, Julia also supports arrays with custom indexing, e.g., starting from 0 or some negative number. The above loop will not work with such arrays and thus does not constitute generic code.</p>
</div>
<p>The way data is organized in memory suggests how to loop through multi-dimensional arrays. As Julia uses column-major ordering, nested loops should be ordered accordingly, e.g.:</p>
<div id="9f5e5244" class="cell" data-execution_count="116">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="fu">axes</span>(A, <span class="fl">2</span>)</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fu">axes</span>(A, <span class="fl">1</span>)</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Code that operates on (i,j) and/or A[i,j] ...</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>However, if we use the default loop patterns <code>for a in A ... end</code> or <code>for i in eachindex(A) ... end</code>, we do not need to worry about the correct nesting of our loops because Julia automatically takes care of looping through the array in an optimal way.</p>
</section>
<section id="maps" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="maps"><span class="header-section-number">4.3.2</span> Maps</h3>
<p>The <code>map(f, c...)</code> function was already introduced in <span class="PItalics" data-custom-style="PItalics">Chapter 1</span> in the context of anonymous functions. It applies some function <code>f</code> to each element of a collection <code>c</code>, such as a tuple or an array, returning a new collection of the same type that holds the return values of <code>f</code>:</p>
<div id="b0508043" class="cell" data-execution_count="117">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fu">map</span>(x <span class="op">-&gt;</span> x<span class="op">^</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="113">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 1
 4
 9</code></pre>
</div>
</div>
<p>There also exists an inplace version, that takes the destination as the second argument:</p>
<div id="81a11b90" class="cell" data-execution_count="118">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map!</span>(x <span class="op">-&gt;</span> x<span class="op">^</span><span class="fl">3</span>, y, <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="114">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
  1
  8
 27</code></pre>
</div>
</div>
<p>When <code>map</code> is applied to two or more vectors (or other one-dimensional collections), it stops evaluating the function when it reaches the last element of one of the vectors. Thus the return vector has the same length as the smallest input vector:</p>
<div id="08107732" class="cell" data-execution_count="119">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(<span class="op">+</span>, <span class="fl">5</span><span class="op">:-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="115">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 6
 6
 6</code></pre>
</div>
</div>
<p>When <code>map</code> is applied to two or more multi-dimensional arrays with the same number of dimensions, the <code>axes</code> of all arrays have to match:</p>
<div id="521d9bab" class="cell" data-execution_count="120">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(<span class="op">+</span>, <span class="fu">ones</span>(<span class="fl">2</span>,<span class="fl">2</span>), <span class="fu">zeros</span>(<span class="fl">1</span>,<span class="fl">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: DimensionMismatch: dimensions must match: a has dims (Base.OneTo(2), Base.OneTo(2)), b has dims (Base.OneTo(1), Base.OneTo(2)), mismatch at 1</code></pre>
</div>
</div>
<p>The <code>broadcast</code> function discussed in the next section is also applicable to arrays whose sizes do not match.</p>
<div data-custom-style="PCallout">
<p>Note that in simple cases, when <code>map</code> is applied to a single array, its result is equivalent to using vectorization as discussed earlier in this chapter. For example, <code>map(x -&gt; x^2, 1:3)</code> is equivalent to</p>
<div id="a315b8bd" class="cell" data-execution_count="121">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>(x <span class="op">-&gt;</span> x<span class="op">^</span><span class="fl">2</span>).(<span class="fl">1</span><span class="op">:</span><span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="117">
<pre class=""><code class=" ansi">3-element Vector{Int64}:
 1
 4
 9</code></pre>
</div>
</div>
<p>However, there is an important implementational difference when the argument is some generic iterable like in this example. While <code>map</code> will just iterate through the collection, broadcasting with the dot syntax will first call <code>collect</code> on the iterable to convert it into an array. If the iterable has a sufficiently large number of elements, this can require non-negligible amounts of memory and consequently time for allocation.</p>
<p>Also note that broadcasting will always generate an array, independently of the type of the arguments, while <code>map</code> will generate an output of the same type as the input.</p>
</div>
<p>Julia features a few more functions similar to <code>map</code> with some additional functionality. The <code>mapreduce(f, op, c...)</code> function first applies a function <code>f</code> to each element in <code>c</code>, just like <code>map</code>, but then it reduces the results with some binary operator <code>op</code>, e.g., <code>+</code>:</p>
<div id="7b2f2ccf" class="cell" data-execution_count="122">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapreduce</span>(x <span class="op">-&gt;</span> x<span class="op">^</span><span class="fl">2</span>, <span class="op">+</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="118">
<pre class=""><code class=" ansi">55</code></pre>
</div>
</div>
<p>The functions <code>mapfoldl</code> and <code>mapfoldr</code> work like <code>mapreduce</code> but with guaranteed left and right associativity, respectively. The function <code>mapslices</code> applies a function only to specific slices of an array. For more details, we refer to the Julia Manual or <code>?mapslices</code>.</p>
</section>
</section>
<section id="array-libraries" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="array-libraries"><span class="header-section-number">4.4</span> Array libraries</h2>
<section id="offset-arrays" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="offset-arrays"><span class="header-section-number">4.4.1</span> Offset arrays</h3>
</section>
<section id="static-arrays" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="static-arrays"><span class="header-section-number">4.4.2</span> Static arrays</h3>
</section>
<section id="continuum-arrays" class="level3" data-number="4.4.3">
<h3 data-number="4.4.3" class="anchored" data-anchor-id="continuum-arrays"><span class="header-section-number">4.4.3</span> Continuum arrays</h3>
</section>
<section id="linear-operators" class="level3" data-number="4.4.4">
<h3 data-number="4.4.4" class="anchored" data-anchor-id="linear-operators"><span class="header-section-number">4.4.4</span> Linear operators</h3>
</section>
</section>
<section id="summary" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="summary"><span class="header-section-number">4.5</span> Summary</h2>
</section>
<section id="references" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="references"><span class="header-section-number">4.6</span> References</h2>
<ul>
<li><a href="https://docs.julialang.org/en/v1/manual/arrays/">The Julia Manual: Single- and multi-dimensional Arrays</a></li>
<li><a href="https://julialang.org/blog/2016/02/iteration/">Multidimensional algorithms and iteration</a> by Tim Holy</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../content/methods-multiple-dispatch.html" class="pagination-link" aria-label="Methods &amp; Multiple Dispatch">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods &amp; Multiple Dispatch</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../content/design-patterns.html" class="pagination-link" aria-label="Design Patterns">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Design Patterns</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>