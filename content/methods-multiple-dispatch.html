<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-99.9.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Modern Scientific Computing with Julia – 3&nbsp; Methods &amp; Multiple Dispatch</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../content/arrays.html" rel="next">
<link href="../content/type-system.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/ansicolors/ansicolor.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/juliamonofont/juliamono.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../resources/jsc.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/part1.html">Part 1: Programming in Julia</a></li><li class="breadcrumb-item"><a href="../content/methods-multiple-dispatch.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods &amp; Multiple Dispatch</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Modern Scientific Computing with Julia</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/michakraus/JuliaMSC" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 1: Programming in Julia</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/julia-language.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Basics of the Julia Language</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/type-system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Julia’s Type System</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/methods-multiple-dispatch.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods &amp; Multiple Dispatch</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/arrays.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Working with Arrays</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/design-patterns.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Design Patterns</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 2: Research Software Engineering</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/package-development.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Package Development</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/git-and-github.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Git and GitHub</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/software-sustainability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Software Sustainability</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/test-driven-development.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Test Driven Development</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/performance-and-introspection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Performance &amp; Introspection</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 3: Useful Libraries and Solutions to Common Problems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Working with Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/differentiable-programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Differentiable Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/linear-and-nonlinear-equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Linear and Nonlinear Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/differential-equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/machine-learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Machine Learning</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../content/part4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 4: Parallel and GPU Programming</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Parallel Programming Paradigms</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-arrays.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Parallel Arrays</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-gpu.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">GPU Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-hybrid.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Hybrid Parallel Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/parallel-case-studies.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Case Studies</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Summary</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#functions-methods-and-dispatch" id="toc-functions-methods-and-dispatch" class="nav-link active" data-scroll-target="#functions-methods-and-dispatch"><span class="header-section-number">3.1</span> Functions, methods, and dispatch</a>
  <ul class="collapse">
  <li><a href="#dispatch" id="toc-dispatch" class="nav-link" data-scroll-target="#dispatch"><span class="header-section-number">3.1.1</span> Dispatch</a></li>
  <li><a href="#object-oriented-programming" id="toc-object-oriented-programming" class="nav-link" data-scroll-target="#object-oriented-programming"><span class="header-section-number">3.1.2</span> Object-oriented programming</a></li>
  <li><a href="#the-expression-problem" id="toc-the-expression-problem" class="nav-link" data-scroll-target="#the-expression-problem"><span class="header-section-number">3.1.3</span> The expression problem</a></li>
  <li><a href="#multiple-dispatch-vs.-operator-overloading" id="toc-multiple-dispatch-vs.-operator-overloading" class="nav-link" data-scroll-target="#multiple-dispatch-vs.-operator-overloading"><span class="header-section-number">3.1.4</span> Multiple dispatch vs.&nbsp;operator overloading</a></li>
  </ul></li>
  <li><a href="#defining-methods" id="toc-defining-methods" class="nav-link" data-scroll-target="#defining-methods"><span class="header-section-number">3.2</span> Defining methods</a>
  <ul class="collapse">
  <li><a href="#generic-function-objects" id="toc-generic-function-objects" class="nav-link" data-scroll-target="#generic-function-objects"><span class="header-section-number">3.2.1</span> Generic function objects</a></li>
  <li><a href="#method-ambiguities" id="toc-method-ambiguities" class="nav-link" data-scroll-target="#method-ambiguities"><span class="header-section-number">3.2.2</span> Method ambiguities</a></li>
  <li><a href="#arbitrary-numbers-of-arguments" id="toc-arbitrary-numbers-of-arguments" class="nav-link" data-scroll-target="#arbitrary-numbers-of-arguments"><span class="header-section-number">3.2.3</span> Arbitrary numbers of arguments</a></li>
  <li><a href="#optional-arguments" id="toc-optional-arguments" class="nav-link" data-scroll-target="#optional-arguments"><span class="header-section-number">3.2.4</span> Optional arguments</a></li>
  <li><a href="#keyword-arguments" id="toc-keyword-arguments" class="nav-link" data-scroll-target="#keyword-arguments"><span class="header-section-number">3.2.5</span> Keyword arguments</a></li>
  <li><a href="#functors" id="toc-functors" class="nav-link" data-scroll-target="#functors"><span class="header-section-number">3.2.6</span> Functors</a></li>
  <li><a href="#anonymous-functions-and-closures" id="toc-anonymous-functions-and-closures" class="nav-link" data-scroll-target="#anonymous-functions-and-closures"><span class="header-section-number">3.2.7</span> Anonymous functions and closures</a></li>
  <li><a href="#local-scope" id="toc-local-scope" class="nav-link" data-scroll-target="#local-scope"><span class="header-section-number">3.2.8</span> Local scope</a></li>
  </ul></li>
  <li><a href="#parametric-methods" id="toc-parametric-methods" class="nav-link" data-scroll-target="#parametric-methods"><span class="header-section-number">3.3</span> Parametric methods</a></li>
  <li><a href="#constructors" id="toc-constructors" class="nav-link" data-scroll-target="#constructors"><span class="header-section-number">3.4</span> Constructors</a>
  <ul class="collapse">
  <li><a href="#outer-constructor-methods" id="toc-outer-constructor-methods" class="nav-link" data-scroll-target="#outer-constructor-methods"><span class="header-section-number">3.4.1</span> Outer constructor methods</a></li>
  <li><a href="#inner-constructor-methods" id="toc-inner-constructor-methods" class="nav-link" data-scroll-target="#inner-constructor-methods"><span class="header-section-number">3.4.2</span> Inner constructor methods</a></li>
  <li><a href="#parametric-constructor-methods" id="toc-parametric-constructor-methods" class="nav-link" data-scroll-target="#parametric-constructor-methods"><span class="header-section-number">3.4.3</span> Parametric constructor methods</a></li>
  <li><a href="#incomplete-initialization" id="toc-incomplete-initialization" class="nav-link" data-scroll-target="#incomplete-initialization"><span class="header-section-number">3.4.4</span> Incomplete initialization</a></li>
  </ul></li>
  <li><a href="#generic-code-and-specialization" id="toc-generic-code-and-specialization" class="nav-link" data-scroll-target="#generic-code-and-specialization"><span class="header-section-number">3.5</span> Generic code and specialization</a></li>
  <li><a href="#coding-guidelines" id="toc-coding-guidelines" class="nav-link" data-scroll-target="#coding-guidelines"><span class="header-section-number">3.6</span> Coding guidelines</a></li>
  <li><a href="#case-study-dispatch-on-empty-types" id="toc-case-study-dispatch-on-empty-types" class="nav-link" data-scroll-target="#case-study-dispatch-on-empty-types"><span class="header-section-number">3.7</span> Case study: dispatch on empty types</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">3.8</span> Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/part1.html">Part 1: Programming in Julia</a></li><li class="breadcrumb-item"><a href="../content/methods-multiple-dispatch.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods &amp; Multiple Dispatch</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec:methods" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods &amp; Multiple Dispatch</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Julia is unique among the major programming languages in that it is built around the multiple dispatch paradigm, a generic programming concept that solves the so-called expression problem. Multiple dispatch provides a powerful and natural paradigm for structuring and organizing programs, especially in research software engineering.</p>
<p>This chapter will discuss the differences between functions and methods, how multiple dispatch works, and how it differs from the single dispatch paradigm of conventional class-based object-oriented languages (CBOO). We will cover the definition of methods in all detail, introduce parametric methods, and revisit constructors for composite types in light of the preceding discussion. We will briefly touch on related topics such as generic code, specialization, and coding style guidelines. This chapter closes with a typical Julia design pattern that is entirely based on multiple dispatch. In summary, we will cover the following topics:</p>
<ul>
<li>Functions, methods, and dispatch</li>
<li>Defining methods</li>
<li>Parametric methods</li>
<li>Constructors</li>
<li>Generic code and specialization</li>
<li>Coding guidelines</li>
<li>Case study: dispatch on empty types</li>
</ul>
<p>As in the previous chapter, we start by defining some terminology and reviewing how this terminology is used with other popular programming languages.</p>
<section id="functions-methods-and-dispatch" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="functions-methods-and-dispatch"><span class="header-section-number">3.1</span> Functions, methods, and dispatch</h2>
<p>A function is a map from a tuple of arguments to a return value. A function can be thought of as an operation that implements a specific conceptual behavior. The actual implementation of that behavior may vary greatly depending on the number and types of the function’s arguments.</p>
<p>For example, the summation and multiplication of integers are very different from the same operations applied to floating-point numbers, although the mathematical operation is the same. The different implementations all describe the same concept and thus should be referred to by the same function name. It would be atrocious if different implementations of summation for different argument types all needed different identifiers such as <code>sum_ints</code>, <code>sum_floats</code>, <code>sum_float_to_int</code>, etc., but that is what many programming languages require. Although most programming languages support calling standard functions such as summation and multiplication for different types by the standard operators <code>+</code> and <code>*</code>, this is a special behavior hardcoded for a limited number of functions and operators and is typically unavailable for user-defined functions. Pythonistas may say that Python allows overloading operators like <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> using so-called <em>magic methods</em>, which is true, but again, this functionality is only available for a limited number of predefined operators. No user-defined function, neither inside nor outside a class, can have more than one implementation depending on the number or type of arguments.</p>
<p>Julia allows the provision of more than a single implementation of a function under the same name. A function can have different implementations, referred to as a <em>method</em>, for different counts and types of arguments (the <em>method signature</em>). The different implementations need not be defined in the same place, at the same time, or even in the same package. This flexibility is one of the main reasons for Julia’s exceptional extensibility. As all functions are first class, this applies to user-defined functions, to functions in the standard library, as well as to a large number of infix operators such as <code>+</code> and <code>*</code>.</p>
<div data-custom-style="PCallout">
<p>Be aware that in Python, the term <em>method</em> refers to an operation associated with a class, while the term <em>function</em> refers to an operation that is not associated with a class. In Julia, the term <em>function</em> refers to some conceptual behavior, while the term <em>method</em> refers to a specific implementation of that behavior for a certain number and type of arguments.</p>
</div>
<section id="dispatch" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="dispatch"><span class="header-section-number">3.1.1</span> Dispatch</h3>
<p>The process of choosing a method is called <em>dispatch</em>. In traditional CBOO languages, dispatch is based solely on the first argument, which is the class to which a method belongs. For example, in Python, a method is called by <code>obj.mymethod(arg1, arg2)</code>, but the definition of that method reads <code>def mymethod(self, arg1, arg2):</code>. That is, the object to which the method belongs is always passed to the method as the first argument, followed by the actual arguments specified by the user. The method executed is selected solely by the first argument, which selects the object and thus the corresponding class in which the method has been defined. In some languages, the argument on which dispatch occurs is implied rather than explicitly written out. For example, in C++ or Java, a method is also called by <code>obj.mymethod(arg1, arg2)</code>, but there is no additional argument in the definition of the function, only <code>arg1</code> and <code>arg2</code>. Still, a reference to the object that receives the method call is accessible inside the method via the <code>this</code> keyword.</p>
<p>Julia selects the method executed when a function is called based on the number of arguments and the types of <em>all</em> the function arguments. This is known as <em>multiple dynamic dispatch</em> or <em>multiple dispatch</em> for short. In scientific computing, this approach turns out to be of great advantage and often appears more natural than a CBOO approach. Considering mathematical operations such as <code>+</code> or <code>*</code>, for example, it makes little sense for these operations to belong to one argument more than the other. In the expression <code>x + y</code>, should the summation operation belong to <code>x</code> or <code>y</code>? There is no obvious choice! Moreover, the particular implementation of the operation depends on the types of all the arguments. Adding two integers, two floating point numbers, or an integer and a float all require different implementations.</p>
<p>This dilemma, however, extends far beyond purely mathematical code.</p>
</section>
<section id="object-oriented-programming" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="object-oriented-programming"><span class="header-section-number">3.1.2</span> Object-oriented programming</h3>
<p>When talking about object-oriented programming languages, many developers think about <em>class-based</em> object-oriented languages, above and below referred to as <em>CBOO</em> languages, such as C++, Java, Python, and Ruby. In CBOO languages, composite types have data fields as well as named functions associated with them, and the combination is called an <em>object</em>. However, not all object-oriented languages are class-based, and even if a language supports classes, not all objects need to be composite types. For example, in Ruby or Smalltalk, all values are objects whether they are composites or not. In other languages like C++ and Java, primitive values, such as integers and floating-point values, are not objects, but only instances of user-defined composite types are proper objects with associated methods. These languages, even though (mostly) class-based, are less pure object-oriented languages.</p>
<p>Julia is a pure object-oriented programming language, as all values are objects, but it is not class-based, as functions are not part of the objects on which they operate. Class-based programming is somewhat antithetical to Julia’s focus on multiple dispatch, where the method that is executed when calling a function is selected based on the types of all the function’s arguments instead of just the first one. Therefore, it does not make sense for a function to be part of any specific composite type. This, however, does not mean that Julia is not an object-oriented language. It is just not class-based.</p>
<p>As everything is an object in Julia, the same is true for functions. Function objects can be thought of as holding all the methods implemented for a given function name. It turns out that organizing methods this way and discerning them by their arguments instead of organizing them as members of composite types and discerning them by the corresponding objects is a highly beneficial aspect of Julia’s design. This will become clearer after the discussion of the next section on the <em>expression problem</em>.</p>
</section>
<section id="the-expression-problem" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="the-expression-problem"><span class="header-section-number">3.1.3</span> The expression problem</h3>
</section>
<section id="multiple-dispatch-vs.-operator-overloading" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="multiple-dispatch-vs.-operator-overloading"><span class="header-section-number">3.1.4</span> Multiple dispatch vs.&nbsp;operator overloading</h3>
</section>
</section>
<section id="defining-methods" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="defining-methods"><span class="header-section-number">3.2</span> Defining methods</h2>
<p>The basics of defining functions (and methods) have already been discussed in <span class="PItalics" data-custom-style="PItalics">Chapter 1</span>. Still, an important point neglected entirely in that discussion is the difference between functions and methods and how to define more than one method for a function.</p>
<p>Most examples of functions we considered so far were defined with a single method that had a fixed number of arguments but no constraints on argument types. Such functions behave very much like functions in traditional dynamically typed languages. However, Julia allows the provision of more than a single method definition. A function can have an arbitrary number of methods, meaning different implementations of a specific behavior for different arguments. To this end, you just need to define the function multiple times with different arguments.</p>
<p>The simplest way to discern different methods is by the number of arguments. Let us define a function <code>printargs</code> with two methods, one taking one argument and one taking two arguments:</p>
<div id="1c6f7747" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printargs</span>(x) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"One argument: "</span>, x)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">printargs</span>(x, y) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"Two arguments: </span><span class="sc">$</span>x<span class="st"> and </span><span class="sc">$</span>y<span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre class=""><code class=" ansi">printargs (generic function with 2 methods)</code></pre>
</div>
</div>
<p>If we call the function, depending on the number of arguments, either the first or the second method is executed:</p>
<div id="4ce51a9f" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printargs</span>(<span class="fl">1</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">printargs</span>(<span class="cn">π</span>, <span class="st">"abc"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">One argument: 1
Two arguments: π and abc</code></pre>
</div>
</div>
<p>If we call the function with a different number of arguments, an error is thrown:</p>
<div id="b0fe0d15" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printargs</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching printargs()

Closest candidates are:
  printargs(<span class="ansi-red-intense-fg">::Any</span>, <span class="ansi-red-intense-fg">::Any</span>)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[2]:2</span>
  printargs(<span class="ansi-red-intense-fg">::Any</span>)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[2]:1</span></code></pre>
</div>
</div>
<p>Julia selects methods not only based on the number of arguments but also the types of arguments. The signatures of method definitions can be annotated with the <code>::</code> type-assertion operator to indicate the types of arguments a method is applicable to.</p>
<p>Consider a function that adds two numbers and multiplies the result by 2:</p>
<div id="2e257f05" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(x<span class="op">::</span><span class="dt">Float64</span>, y<span class="op">::</span><span class="dt">Float64</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre class=""><code class=" ansi">addmul2 (generic function with 1 method)</code></pre>
</div>
</div>
<p>This method definition is only applicable when <code>x</code> and <code>y</code> are both values of type <code>Float64</code>:</p>
<div id="14bcac0b" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(<span class="fl">1.0</span>, <span class="fl">2.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre class=""><code class=" ansi">6.0</code></pre>
</div>
</div>
<p>If any of the two arguments is of another type, we will be confronted with a <code>MethodError</code></p>
<div id="c86b78e4" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(<span class="fl">1.0</span>, <span class="fl">2.0f0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching addmul2(::Float64, ::Float32)

Closest candidates are:
  addmul2(::Float64, <span class="ansi-red-intense-fg">::Float64</span>)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[5]:1</span></code></pre>
</div>
</div>
<p>If the argument types are restricted to concrete types such as <code>Float64</code>, the types of the provided values must match the prescribed types exactly. Julia does not perform automatic conversion, even if lossless conversion is possible. Thus, in the example above, there is no automatic promotion of 32-bit floating-point values to 64-bit floating-point values.</p>
<p>For the implementation of the <code>addmul2</code> function above, it is no problem to loosen the type restrictions:</p>
<div id="d9f92768" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(x<span class="op">::</span><span class="dt">Number</span>, y<span class="op">::</span><span class="dt">Number</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre class=""><code class=" ansi">addmul2 (generic function with 2 methods)</code></pre>
</div>
</div>
<p>This method applies to any pair of arguments whose type is derived from <code>Number</code>. Thus, it can, for example, also be applied to two integer values:</p>
<div id="25485a25" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(<span class="fl">1</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre class=""><code class=" ansi">6</code></pre>
</div>
</div>
<p>The method can even be applied to values of different types as long as both are numeric values:</p>
<div id="f032f80e" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(<span class="fl">1</span><span class="op">+</span><span class="fl">2im</span>, <span class="fl">3.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre class=""><code class=" ansi">8.0 + 4.0im</code></pre>
</div>
</div>
<p>The fact that this works is entirely due to the properties of the <code>+</code> operation and specifically to the fact that it has methods for handling disparate numeric types. Note that the first method can only be called if both arguments are of type <code>Float64</code>. As soon as at least one argument is of a different number type, the more general second method, applicable to all subtypes of <code>Number</code>, is called. For non-numeric values that are not a subtype of <code>Number</code> and for fewer or more arguments, the function <code>addmul2</code> remains undefined, and applying it will still result in a <code>MethodError</code>:</p>
<div id="13a15ebe" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(<span class="fl">1.0</span>, <span class="st">"2.0"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching addmul2(::Float64, ::String)

Closest candidates are:
  addmul2(::Float64, <span class="ansi-red-intense-fg">::Float64</span>)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[5]:1</span>
  addmul2(::Number, <span class="ansi-red-intense-fg">::Number</span>)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[8]:1</span></code></pre>
</div>
</div>
<div id="93594b48" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching addmul2(::Float64, ::Float64, ::Float64)

Closest candidates are:
  addmul2(::Float64, ::Float64)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[5]:1</span>
  addmul2(::Number, ::Number)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[8]:1</span></code></pre>
</div>
</div>
<p>Whenever more than one method is defined for a function and the function is applied, Julia executes the method whose signature matches the number and types of the arguments most closely. In the <code>addmul2</code> example, we specified two method definitions, one for two arguments of type <code>Float64</code> and one more general for two arguments of any subtype of <code>Number</code>. These two methods define the behavior for <code>addmul2</code>. If the <code>addmul2</code> function is called with two <code>Float64</code> arguments, the method that accepts two <code>Number</code> arguments is applicable, but the method that accepts two <code>Float64</code> arguments is more specific and thus called.</p>
<p>Not constraining an argument’s type in a method definition is equivalent to annotating it to be of type <code>Any</code>, which is the supertype of all types in Julia. As this is the least specific type constraint, a method with unconstrained argument types will only be called if no other method definition applies to the provided argument types. This behavior is often used to define a generic fallback method for a function. A typical use case is to print a warning like in the following example:</p>
<div id="b621ccb7" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(x, y) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"addmul2 is not applicable to argument types (</span><span class="sc">$</span>(<span class="fu">typeof</span>(x))<span class="st">,</span><span class="sc">$</span>(<span class="fu">typeof</span>(y))<span class="st">)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre class=""><code class=" ansi">addmul2 (generic function with 3 methods)</code></pre>
</div>
</div>
<p>We can now call <code>addmul2</code> with any pair or arguments without raising an error:</p>
<div id="46f0f338" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2</span>(<span class="fl">1.0</span>, <span class="st">"2.0"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">addmul2 is not applicable to argument types (Float64,String)</code></pre>
</div>
</div>
<p>After this discussion on how to define methods and functions, we will now learn how to retrieve information about them.</p>
<section id="generic-function-objects" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="generic-function-objects"><span class="header-section-number">3.2.1</span> Generic function objects</h3>
<p>In Julia, functions are objects, just like everything else, and they can be assigned to variables, passed as function arguments, or returned as values. The function object is responsible for the bookkeeping of all the methods defined for a function. The definition of the first method for a function creates the actual function object. Every subsequent method definition adds a new method to the existing function object. It is also possible to create a function without defining any methods by specifying just an empty function block without arguments:</p>
<div id="f0315242" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> empty <span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre class=""><code class=" ansi">empty (generic function with 0 methods)</code></pre>
</div>
</div>
<p>This can be useful for separating interface definitions from implementations or for documentation purposes.</p>
<p>A function object can be accessed interactively via its name. For example, if we type the name of the <code>addmul2</code> function, we see that there are currently three methods defined:</p>
<div id="1ffd426a" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>addmul2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre class=""><code class=" ansi">addmul2 (generic function with 3 methods)</code></pre>
</div>
</div>
<p>The signatures of those methods can be retrieved by the <code>methods</code> function:</p>
<div id="75b533f9" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">methods</span>(addmul2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
# 3 methods for generic function <b>addmul2</b> from ꍟ⦃35mMainꍟ⦃39m:<ul><li> addmul2(x::<b>Float64</b>, y::<b>Float64</b>) in Main at In[5]:1</li> <li> addmul2(x::<b>Number</b>, y::<b>Number</b>) in Main at In[8]:1</li> <li> addmul2(x, y) in Main at In[13]:1</li> </ul>
</div>
</div>
<p>It also shows the file and line number where the methods were defined. As the code in this book is executed in a notebook, the line numbers correspond to the input cells.</p>
<p>The <code>applicable</code> function can be used to query if a function has a method that accepts a specific tuple of arguments, for example</p>
<div id="82d28640" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">applicable</span>(addmul2, <span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre class=""><code class=" ansi">false</code></pre>
</div>
</div>
<div id="252b8d94" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">applicable</span>(addmul2, <span class="fl">1.0</span>, <span class="fl">2.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre class=""><code class=" ansi">true</code></pre>
</div>
</div>
<p>This function is handy for checking if a user-provided function has the correct interface, for example, the right-hand side of an ordinary differential equation in some solver package.</p>
</section>
<section id="method-ambiguities" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="method-ambiguities"><span class="header-section-number">3.2.2</span> Method ambiguities</h3>
<p>When defining functions with multiple methods, a little care is needed to avoid method ambiguities. If we define several methods with the same number of arguments, constraining some argument types but not others or constraining some to concrete types and others to abstract types, it is possible to create a situation in which Julia cannot uniquely determine which method to call for a given set of arguments. Consider the following example of a function taking two arguments:</p>
<div id="ae62516c" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iamambiguous</span>(x<span class="op">::</span><span class="dt">Int64</span>, y) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">iamambiguous</span>(x, y<span class="op">::</span><span class="dt">Int64</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre class=""><code class=" ansi">iamambiguous (generic function with 2 methods)</code></pre>
</div>
</div>
<p>If we call this function with an <code>Int64</code> value in only one of the arguments, everything is fine:</p>
<div id="0436ee30" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iamambiguous</span>(<span class="fl">1</span>, <span class="fl">2.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre class=""><code class=" ansi">6.0</code></pre>
</div>
</div>
<div id="a5d908fa" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iamambiguous</span>(<span class="fl">1.0</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre class=""><code class=" ansi">6.0</code></pre>
</div>
</div>
<p>However, see what happens if we call it with two <code>Int64</code> values:</p>
<div id="35c49374" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iamambiguous</span>(<span class="fl">1</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: iamambiguous(::Int64, ::Int64) is ambiguous.

Candidates:
  iamambiguous(<span class="ansi-black-intense-fg">x</span>, <span class="ansi-black-intense-fg">y</span>::<span class="ansi-bold">Int64</span>)
<span class="ansi-black-intense-fg">    @</span> <span class="ansi-black-intense-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[20]:2</span>
  iamambiguous(<span class="ansi-black-intense-fg">x</span>::<span class="ansi-bold">Int64</span>, <span class="ansi-black-intense-fg">y</span>)
<span class="ansi-black-intense-fg">    @</span> <span class="ansi-black-intense-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[20]:1</span>

Possible fix, define
  iamambiguous(::Int64, ::Int64)</code></pre>
</div>
</div>
<p>Julia raises a <code>MethodError</code> as there is no unique most specific method applicable to that set of arguments. Either of the above methods could handle the function call, and neither is more specific than the other. What is nice, though, is that Julia also suggests how to fix this situation, namely by defining an additional method that takes two <code>Int64</code> arguments:</p>
<div id="def0cc1f" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iamnotambiguous</span>(x<span class="op">::</span><span class="dt">Int64</span>, y<span class="op">::</span><span class="dt">Int64</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">iamnotambiguous</span>(x<span class="op">::</span><span class="dt">Int64</span>, y) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">iamnotambiguous</span>(x, y<span class="op">::</span><span class="dt">Int64</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="fu">iamnotambiguous</span>(<span class="fl">1</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre class=""><code class=" ansi">6</code></pre>
</div>
</div>
<p>With these definitions, there is a unique most specific method for all supported combinations of arguments. If both arguments are of type <code>Int64</code>, the first method is invoked. If only the first argument is of type <code>Int64</code>, the second method is invoked. If only the second argument is of type <code>Int64</code>, the third method is invoked. If none of the arguments is of type <code>Int64</code>, then a method error is thrown as no appropriate method has been defined.</p>
<p>If a user-defined function has ambiguous methods, the Julia coding guidelines recommend defining the disambiguating method first in order to avoid the existence of ambiguities at any time.</p>
</section>
<section id="arbitrary-numbers-of-arguments" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="arbitrary-numbers-of-arguments"><span class="header-section-number">3.2.3</span> Arbitrary numbers of arguments</h3>
<p>Functions that accept a variable number of arguments are called varargs functions. Such functions are defined by appending an ellipsis to the last positional argument in a method definition:</p>
<div id="5b0ecaf7" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printvarargs</span>(x<span class="op">...</span>) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"</span><span class="sc">$</span>(<span class="fu">length</span>(x))<span class="st"> arguments: "</span>, x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can call this method with any number of arguments or no arguments at all:</p>
<div id="095514db" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printvarargs</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">0 arguments: ()</code></pre>
</div>
</div>
<div id="0a6e4c4c" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printvarargs</span>(<span class="fl">1</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">2 arguments: (1, 2)</code></pre>
</div>
</div>
<p>The varargs argument can be preceded by other positional arguments, but it always has to be the last argument:</p>
<div id="828e056a" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printxyz</span>(x, y, z<span class="op">...</span>) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"x = </span><span class="sc">$</span>x<span class="st"> and y = </span><span class="sc">$</span>y<span class="st">, and the other </span><span class="sc">$</span>(<span class="fu">length</span>(z))<span class="st"> arguments are </span><span class="sc">$</span>z<span class="st">"</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">printxyz</span>(<span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">x = 1 and y = 2, and the other 2 arguments are (3, 4)</code></pre>
</div>
</div>
<div id="57faed73" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printxy</span>(x<span class="op">...</span>, y) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"x = </span><span class="sc">$</span>x<span class="st"> and y = </span><span class="sc">$</span>y<span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: syntax: invalid "..." on non-final argument around In[29]:1</code></pre>
</div>
</div>
<p>Inside the method, the varargs variable <code>x</code> is an iterable collection with zero or more values. Often, it is not used directly but passed on to another function in the form of single values via splatting:</p>
<div id="d9811cd2" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">printxyz</span>(x, y, z<span class="op">...</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">println</span>(<span class="st">"x = </span><span class="sc">$</span>x<span class="st"> and y = </span><span class="sc">$</span>y<span class="st"> and then we have"</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">printvarargs</span>(z<span class="op">...</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="fu">printxyz</span>(<span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">x = 1 and y = 2 and then we have
2 arguments: (3, 4)</code></pre>
</div>
</div>
<p>Varargs can be constrained similarly to normal arguments in type but also in number using the parametric <code>Vararg{T,N}</code> type. The parameter <code>T</code> restricts the type of possible arguments. It is <code>Any</code> by default but can be restricted to more specific abstract or concrete types. The parameter <code>N</code> denotes the number of varargs. If no restriction on the number of arguments is required, <code>N</code> can be omitted. Let us consider some examples. If we want to restrict the number of varargs but not their types, we can use the following syntax:</p>
<div id="16ca5bb0" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printxy</span>(x, y<span class="op">::</span><span class="dt">Vararg{Any,2}</span>) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"x = </span><span class="sc">$</span>x<span class="st">, y[1] = </span><span class="sc">$</span>(y[<span class="fl">1</span>])<span class="st"> and y[2] = </span><span class="sc">$</span>(y[<span class="fl">2</span>])<span class="st">"</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">printxy</span>(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">x = 1, y[1] = 2 and y[2] = 3</code></pre>
</div>
</div>
<p>This method can only be called with exactly three arguments, no more, no less:</p>
<div id="423aa0b4" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printxy</span>(<span class="fl">1</span>,<span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching printxy(::Int64, ::Int64)

Closest candidates are:
  printxy(::Any, ::Any, <span class="ansi-red-intense-fg">::Any</span>)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[31]:1</span></code></pre>
</div>
</div>
<div id="aa96128e" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printxy</span>(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching printxy(::Int64, ::Int64, ::Int64, ::Int64)

Closest candidates are:
  printxy(::Any, ::Any, ::Any)
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[31]:1</span></code></pre>
</div>
</div>
<p>If we want to restrict the type of varargs, but not their number, we can use the following syntax:</p>
<div id="5c9b36d9" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printints</span>(x<span class="op">::</span><span class="dt">Vararg{Int}</span>) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"x = </span><span class="sc">$</span>x<span class="st">"</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">printints</span>(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre class=""><code class=" ansi">x = (1, 2, 3)</code></pre>
</div>
</div>
<p>This, however, can be expressed more compactly as follows:</p>
<div id="00fd241e" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printints</span>(x<span class="op">::</span><span class="dt">Int...</span>) <span class="op">=</span> <span class="fu">println</span>(<span class="st">"x = </span><span class="sc">$</span>x<span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Type decorations with the <code>Vararg{T,N}</code> type are most useful if the number of varargs needs to be restricted. If only type constraints need to be applied to varargs, the usual type decoration with a trailing ellipsis is shorter and easier to read. Note that no ellipsis is added if types are constrained via the <code>Vararg{T,N}</code> type.</p>
</section>
<section id="optional-arguments" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="optional-arguments"><span class="header-section-number">3.2.4</span> Optional arguments</h3>
<p>Often, it is desirable to specify default values for certain arguments, thus making those arguments optional. Julia supports optional arguments with the usual syntax:</p>
<div id="b68e5f07" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>(x<span class="op">=</span><span class="fl">1</span>, y<span class="op">=</span><span class="fl">2</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre class=""><code class=" ansi">addmul2opt (generic function with 3 methods)</code></pre>
</div>
</div>
<p>We see that this declaration leads to the definition of three methods, namely:</p>
<div id="17fb2b29" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>(x,y) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>(x) <span class="op">=</span> <span class="fu">addmul2opt</span>(x,<span class="fl">2</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>() <span class="op">=</span> <span class="fu">addmul2opt</span>(<span class="fl">1</span>,<span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This implies that optional arguments are not a property of a specific function method but rather a property of the function itself.</p>
<p>Optional arguments always have to follow non-optional arguments. Therefore, this definition is allowed:</p>
<div id="7258880f" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>(x, y<span class="op">=</span><span class="fl">2</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>While this definition raises an error:</p>
<div id="cf067e4b" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>(x<span class="op">=</span><span class="fl">1</span>, y) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: syntax: optional positional arguments must occur at end around In[39]:1</code></pre>
</div>
</div>
<p>Julia’s treatment of optional arguments involves a few potential pitfalls. In the definition above, calling <code>addmul2opt()</code> and calling <code>addmul2opt(1,2)</code> both result in <code>6</code> as <code>addmul2opt()</code> calls the first method with arguments <code>(1,2)</code>. We can alter this behavior by defining an additional, more specialized method. Consider adding the following method:</p>
<div id="a844ab27" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>(x<span class="op">::</span><span class="dt">Int</span>, y<span class="op">::</span><span class="dt">Int</span>, z<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fl">3</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y <span class="op">+</span> z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre class=""><code class=" ansi">addmul2opt (generic function with 5 methods)</code></pre>
</div>
</div>
<div id="ce5374f8" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>(<span class="fl">1</span>,<span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre class=""><code class=" ansi">12</code></pre>
</div>
</div>
<div id="68d78edb" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2opt</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre class=""><code class=" ansi">12</code></pre>
</div>
</div>
<p>With this additional definition, <code>addmul2opt()</code> and <code>addmul2opt(1,2)</code> still return the same result, but now it is <code>12</code> for both. That is, we changed the behavior not only of the method that takes two arguments in case these arguments are of type <code>Int</code>, but we also changed the behavior of the method <code>addmul2opt()</code> that takes no arguments. The latter acts as a relay to the method that takes two arguments, providing it with some default values. Thus, by the dynamic nature of multiple dispatch and the type of the default arguments we provided in the original definition of <code>addmul2opt</code>, the method <code>addmul2opt()</code> now relays to the new method, which is specialized to integer-valued arguments (the type of the default values).</p>
<p>The way Julia implements optional arguments can also lead to unexpected method ambiguities or the unintended override of existing methods. Consider the following definitions:</p>
<div id="a28d7eb2" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2amb</span>(x<span class="op">::</span><span class="dt">Int</span>, y<span class="op">=</span><span class="fl">2</span>, z<span class="op">=</span><span class="fl">3</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y <span class="op">+</span> z)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2amb</span>(x, y<span class="op">::</span><span class="dt">Float64</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2amb</span>(<span class="fl">1</span>, <span class="fl">2.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: addmul2amb(::Int64, ::Float64) is ambiguous.

Candidates:
  addmul2amb(<span class="ansi-black-intense-fg">x</span>, <span class="ansi-black-intense-fg">y</span>::<span class="ansi-bold">Float64</span>)
<span class="ansi-black-intense-fg">    @</span> <span class="ansi-black-intense-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[43]:2</span>
  addmul2amb(<span class="ansi-black-intense-fg">x</span>::<span class="ansi-bold">Int64</span>, <span class="ansi-black-intense-fg">y</span>)
<span class="ansi-black-intense-fg">    @</span> <span class="ansi-black-intense-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[43]:1</span>

Possible fix, define
  addmul2amb(::Int64, ::Float64)</code></pre>
</div>
</div>
<p>Among others, the first declaration results in the following method definition:</p>
<div id="d0351dc5" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2amb</span>(x<span class="op">::</span><span class="dt">Int</span>, y) <span class="op">=</span> <span class="fu">addmul2amb</span>(x, y, <span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Therefore, in the call <code>addmul2amb(1, 2.0)</code>, no unique most specific method exists.</p>
<p>Similarly, we may get an unexpected result if we define the following methods:</p>
<div id="9c511a72" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2override</span>(x, y) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2override</span>(x<span class="op">=</span><span class="fl">1</span>, y<span class="op">=</span><span class="fl">2</span>, z<span class="op">=</span><span class="fl">3</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y <span class="op">+</span> z)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2override</span>(<span class="fl">1</span>, <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre class=""><code class=" ansi">12</code></pre>
</div>
</div>
<p>By the first method definition, we would expect <code>addmul2override(1, 2)</code> to result in <code>6</code>. Still, in practice, it results in <code>12</code>, as the second declaration includes the following method definition, which, in the absence of any type constraints, overwrites the original definition of <code>addmul2override(x, y)</code>:</p>
<div id="88537d2b" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addmul2override</span>(x, y) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y <span class="op">+</span> <span class="fl">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>While this behavior is entirely logical in the context of multiple dispatch, it may at first appear unintuitive. Thus, it is important to know how Julia treats optional arguments.</p>
</section>
<section id="keyword-arguments" class="level3" data-number="3.2.5">
<h3 data-number="3.2.5" class="anchored" data-anchor-id="keyword-arguments"><span class="header-section-number">3.2.5</span> Keyword arguments</h3>
<p>If a function has a large number of arguments, it is often challenging to remember their order. Think, for example, of a plotting routine and all the arguments determining the style of the plot. It is much easier to call such a function when the individual arguments are identified by name instead of position.</p>
<p>When defining a method, the keyword arguments are separated from the positional arguments by a semicolon:</p>
<div id="9b33c5c4" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot</span>(x, y; linewidth, markersize)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When calling such a method, this separation is not necessary, and the semicolon is optional. Therefore, the following function calls are equivalent:</p>
<div id="4535bf1c" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> <span class="fl">2</span>, markersize <span class="op">=</span> <span class="fl">10</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>], linewidth <span class="op">=</span> <span class="fl">2</span>, markersize <span class="op">=</span> <span class="fl">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we omit one of the keyword arguments, an error is raised:</p>
<div id="ff460432" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> <span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: UndefKeywordError: keyword argument `markersize` not assigned</code></pre>
</div>
</div>
<p>In many cases, keyword arguments are specified with a default value, e.g.</p>
<div id="b2eae625" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot</span>(x, y; linewidth <span class="op">=</span> <span class="fl">2</span>, markersize <span class="op">=</span> <span class="fl">10</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If this is the case, the plot function can also be called without passing any of the keyword arguments or just a subset thereof:</p>
<div id="affe0d69" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>])</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> <span class="fl">1</span>)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; markersize <span class="op">=</span> <span class="fl">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Keyword arguments are evaluated from left to right, and default expressions can depend on keyword arguments on the left as well as positional arguments:</p>
<div id="c6e0f615" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot</span>(x, y; linewidth <span class="op">=</span> <span class="fl">2</span>, markersize <span class="op">=</span> <span class="fl">5</span><span class="op">*</span>linewidth)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we call a function that takes keyword arguments, the argument’s name can sometimes be inferred. If, for example, we pass an existing identifier after the semicolon, the name of the keyword argument is inferred from the name of the identifier so that the following two calls to the <code>plot</code> function are equivalent:</p>
<div id="840bcd32" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>linewidth <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> linewidth)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This even works with fields of composite types so that the following two calls to <code>plot</code> are also equivalent:</p>
<div id="a1377b60" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>options <span class="op">=</span> (linewidth <span class="op">=</span> <span class="fl">2</span>, markersize <span class="op">=</span> <span class="fl">10</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; options.linewidth)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> options.linewidth)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To pass keywords at runtime, an expression like <code>key =&gt; value</code> can be used after the semicolon, where <code>key</code> needs to be a symbol:</p>
<div id="7d59d6ff" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>argname <span class="op">=</span> <span class="op">:</span>linewidth</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>argvalue <span class="op">=</span> <span class="fl">5</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; argname <span class="op">=&gt;</span> argvalue)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>is equivalent to</p>
<div id="b9f6d20d" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> <span class="fl">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Similar to positional arguments, it is possible to decorate keyword arguments with type annotations:</p>
<div id="dea42051" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot</span>(x, y; linewidth<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fl">2</span>, markersize<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fl">5</span><span class="op">*</span>linewidth)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note, however, that, unlike positional arguments, keyword arguments do not participate in method dispatch. Instead, keyword arguments are processed only after identifying the appropriate method based on its positional arguments and their types.</p>
<p>Keyword arguments can be used together with a variable number of positional arguments, and in a similar fashion, we can also have additional keyword arguments:</p>
<div id="f2bcfbaa" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot</span>(args<span class="op">...</span>; linestyle <span class="op">=</span> <span class="op">:</span>solid, kwargs<span class="op">...</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Inside the <code>plot</code> function, <code>kwargs</code> is available as a key-value iterator over a named tuple. However, this syntax is most often used to pass on keyword arguments to another function or method along the lines of the following example:</p>
<div id="2c944e5f" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot</span>(x, y, args<span class="op">...</span>; linestyle <span class="op">=</span> <span class="op">:</span>solid, kwargs<span class="op">...</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">plot</span>(x, y; kwargs<span class="op">...</span>)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">setlinestyle!</span>(p, linestyle)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With this syntax, a keyword argument may be provided more than once, typically when splatting varargs and explicitly providing the argument, for example:</p>
<div id="1b897b85" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>options <span class="op">=</span> (linewidth <span class="op">=</span> <span class="fl">2</span>, markersize <span class="op">=</span> <span class="fl">10</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; options<span class="op">...</span>, linewidth <span class="op">=</span> <span class="fl">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In such a case, the rightmost occurrence takes precedence. This means that in the above example <code>linewidth = 5</code> is used, but if we switch the order of the arguments, the value <code>linewidth = 2</code> from the options tuple is used instead:</p>
<div id="17b01768" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> <span class="fl">5</span>, options<span class="op">...</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Keyword arguments may only appear multiple times when all occurrences but one are implicitly specified, e.g., as elements of iterables. Explicitly specifying the same keyword argument twice or more is not allowed and results in a syntax error:</p>
<div id="21e5aace" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>([<span class="fl">0.0</span>, <span class="fl">1.0</span>], [<span class="fl">1.0</span>, <span class="fl">2.0</span>]; linewidth <span class="op">=</span> <span class="fl">3</span>, linewidth <span class="op">=</span> <span class="fl">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: syntax: keyword argument "linewidth" repeated in call to "plot" around In[62]:1</code></pre>
</div>
</div>
<p>This concludes the discussion about passing arguments to a function. Next, we will see how to make objects callable.</p>
</section>
<section id="functors" class="level3" data-number="3.2.6">
<h3 data-number="3.2.6" class="anchored" data-anchor-id="functors"><span class="header-section-number">3.2.6</span> Functors</h3>
<p>Functors are types whose objects are callable and thus behave like functions. This is easily achieved by adding methods to a special function that is identified by the type instead of a generic name:</p>
<div id="2e58f2cb" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Power</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    pow<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (p<span class="op">::</span><span class="dt">Power</span>)(x)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    x<span class="op">^</span>p.pow</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">Power</span>(<span class="fl">5</span>)</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="fu">p</span>(<span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="63">
<pre class=""><code class=" ansi">32</code></pre>
</div>
</div>
<p>Functors are helpful for implementing concise interfaces in many problems, e.g., evaluation of polynomials, integration of differential equations, transfer functions, neural network layers, and many more. Moreover, functors are at the core of type constructors and closures, as will be discussed later in this chapter.</p>
</section>
<section id="anonymous-functions-and-closures" class="level3" data-number="3.2.7">
<h3 data-number="3.2.7" class="anchored" data-anchor-id="anonymous-functions-and-closures"><span class="header-section-number">3.2.7</span> Anonymous functions and closures</h3>
<p>Anonymous functions are functions without an explicit name. We have already encountered them in <span class="PItalics" data-custom-style="PItalics">Chapter 1</span>, but we briefly want to discuss some technical details in light of what we have learned in this chapter.</p>
<p>Anonymous functions can be created in two equivalent ways:</p>
<div id="eb4a319f" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">-&gt;</span> <span class="fu">cos</span>(x)<span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="fu">sin</span>(x)<span class="op">^</span><span class="fl">2</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (x)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cos</span>(x)<span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="fu">sin</span>(x)<span class="op">^</span><span class="fl">2</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre class=""><code class=" ansi">#19 (generic function with 1 method)</code></pre>
</div>
</div>
<p>Both declarations return a generic function object with a compiler-generated name based on consecutive numbering. An anonymous function that does not expect an argument can be defined by</p>
<div id="05f9049d" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>() <span class="op">-&gt;</span> <span class="fl">42</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre class=""><code class=" ansi">#21 (generic function with 1 method)</code></pre>
</div>
</div>
<p>On their own, such declarations are not particularly useful as they do not provide a convenient way for calling the declared function. In order to do so, they have to be assigned to some variable, as in the following example:</p>
<div id="65c7bb9e" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> x <span class="op">-&gt;</span> <span class="fu">cos</span>(x)<span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="fu">sin</span>(x)<span class="op">^</span><span class="fl">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="66">
<pre class=""><code class=" ansi">#23 (generic function with 1 method)</code></pre>
</div>
</div>
<p>Now, the function can be called like any other function via the variable <code>f</code>:</p>
<div id="ae022428" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(<span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="67">
<pre class=""><code class=" ansi">1.0</code></pre>
</div>
</div>
<p>The main use case for anonymous functions is to pass them to other functions as arguments, for example, to the <code>map</code> function, as we have already seen in <span class="PItalics" data-custom-style="PItalics">Chapter 1</span>:</p>
<div id="f6253a04" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(x <span class="op">-&gt;</span> <span class="fu">cos</span>(x)<span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="fu">sin</span>(x)<span class="op">^</span><span class="fl">2</span>, [<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">
<pre class=""><code class=" ansi">3-element Vector{Float64}:
 1.0
 1.0
 1.0</code></pre>
</div>
</div>
<p>Another common use case for anonymous functions is closures. These are functions that refer to their surrounding environment by capturing variables.</p>
<div id="2615bca7" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>timestep <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>nexttimestep <span class="op">=</span> x <span class="op">-&gt;</span> x <span class="op">+</span> timestep</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="fu">nexttimestep</span>(<span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre class=""><code class=" ansi">1.1</code></pre>
</div>
</div>
<p>A typical application of closures is the solution of a nonlinear system of equations of the form <span class="math inline">f(x) = 0</span>, i.e., finding the roots <span class="math inline">x</span> of <span class="math inline">f</span>. Many nonlinear solvers expect the function to solve for to have the interface <code>f!(y,x)</code> computing <span class="math inline">y = f(x)</span>, so that <span class="math inline">y</span> is the value of the function <span class="math inline">f</span> for input <span class="math inline">x</span>. More often than not, the function <code>f!</code> computing <span class="math inline">f</span> takes additional inputs other than <code>y</code> and <code>x</code>, e.g., configuration variables, temporary arrays, or additional static inputs. To pass a function with the correct interface to the solver, a closure is usually the simplest solution, cf.&nbsp;the following example:</p>
<div id="cfca9966" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">f!</span>(y, x, t, params)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">solve</span>(f, x₀)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>parameters <span class="op">=</span> (ω <span class="op">=</span> <span class="fl">0.5</span>, k <span class="op">=</span> <span class="fl">2</span>)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>t₀ <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>x₀ <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">3</span>)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fu">solve</span>((y,x) <span class="op">-&gt;</span> <span class="fu">f!</span>(y, x, t₀, parameters), x₀)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here, the function <code>f!</code> defines the nonlinear function whose zeros we want to determine. The first argument, <code>y</code>, is the value of <code>f</code>. The second argument, <code>x</code>, is the argument on which the function <code>f</code> is evaluted, e.g., the current state of a system of dynamical equations. The third argument, <code>t</code>, is an additional argument, e.g., time. The fourth argument, <code>params</code>, is a NamedTuple of parameters on which the function depends. The function <code>solve</code> performs the actual nonlinear solver step for the function <code>f</code> using <code>x₀</code> as an initial guess. After specifying values for the parameters, the argument <code>t</code>, and the initial guess for <code>x</code>, we call the <code>solve</code> method, passing as the first argument a closure with the expected interface that captures all the additional arguments of <code>f!</code>.</p>
</section>
<section id="local-scope" class="level3" data-number="3.2.8">
<h3 data-number="3.2.8" class="anchored" data-anchor-id="local-scope"><span class="header-section-number">3.2.8</span> Local scope</h3>
<p>Anonymous functions are often defined within a local scope, e.g., within another function. The same is possible with generic, named functions:</p>
<div id="5a96b4ac" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">factory</span>(x)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">addmul2</span>(y<span class="op">::</span><span class="dt">Number</span>) <span class="op">=</span> <span class="fl">2</span>(x <span class="op">+</span> y)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">addmul2</span>(y<span class="op">::</span><span class="dt">Int</span>) <span class="op">=</span> <span class="fl">2</span>y</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> addmul2</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="fu">factory</span>(<span class="fl">2</span>)</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(<span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre class=""><code class=" ansi">4</code></pre>
</div>
</div>
<div id="0aaf1df9" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(<span class="fl">2.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre class=""><code class=" ansi">8.0</code></pre>
</div>
</div>
<p>One should refrain from defining local methods conditionally, e.g., within an <code>if</code>-<code>else</code> clause, as this will obfuscate which method will actually be defined. Still, one can use anonymous functions in such situations.</p>
</section>
</section>
<section id="parametric-methods" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="parametric-methods"><span class="header-section-number">3.3</span> Parametric methods</h2>
<p>Similar to types, method definitions can have type parameters. These typically arise from annotating arguments with parametric types. Parametric methods allow extracting type information from arguments, dispatching on specific parameter values, and matching compatible parameters of argument types. They are expressed using the same <code>where</code> syntax that we have already encountered in the section on <code>UnionAll</code> types in the previous chapter.</p>
<p>The following method has one type parameter that is assigned to the type of its argument:</p>
<div id="2cca3fac" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printtype</span>(x<span class="op">::</span><span class="dt">T</span>) <span class="kw">where</span> {T} <span class="op">=</span> <span class="fu">println</span>(T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre class=""><code class=" ansi">printtype (generic function with 1 method)</code></pre>
</div>
</div>
<p>When the method is called, the value of <code>T</code> is the type of <code>x</code>. Within the signature or body of a method, method parameters can be used just like any other value. Parametric methods are commonly used in Julia to extract parameter values of parametric types. The following functions return the element type and the dimension of an array, respectively:</p>
<div id="c88c45e7" class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eltype</span>(<span class="op">::</span><span class="dt">AbstractArray{T,N}</span>) <span class="kw">where</span> {T,N} <span class="op">=</span> T</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ndims</span>(<span class="op">::</span><span class="dt">AbstractArray{T,N}</span>) <span class="kw">where</span> {T,N} <span class="op">=</span> N</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">3</span>,<span class="fl">4</span>)</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="fu">println</span>(<span class="fu">eltype</span>(x))</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="fu">println</span>(<span class="fu">ndims</span>(x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These methods have two type parameters, <code>T</code> and <code>N</code>, which are assigned to the type parameters of the parametric type <code>AbstractArray</code> and thus hold the values of these parameters when the methods are executed. This example allows for two interesting observations. First, if we have multiple parameters, they can be collected in braces, separated with commas, as in <code>where {T,N}</code> in the example. This syntax is equivalent to the nested expression <code>where N where T</code>. Second, if we are only interested in extracting type information, it is unnecessary to assign a variable name to the argument but only a type decorator.</p>
<p>Method parameters can also be constrained in full analogy to type parameters.</p>
<div id="fbc35cce" class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="fu">isnumber</span>(x<span class="op">::</span><span class="dt">T</span>) <span class="kw">where</span> {T <span class="op">&lt;:</span><span class="dt"> Number</span>} <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="fu">isnumber</span>(x) <span class="op">=</span> <span class="cn">false</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">
<pre class=""><code class=" ansi">isnumber (generic function with 2 methods)</code></pre>
</div>
</div>
<div id="79b9f86c" class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">isnumber</span>(<span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre class=""><code class=" ansi">true</code></pre>
</div>
</div>
<div id="ac35da04" class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">isnumber</span>(<span class="st">"1.0"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<pre class=""><code class=" ansi">false</code></pre>
</div>
</div>
<p>The first method is executed if the argument is an instance of <code>Number</code>, and the second method is elsewise. Defining function behavior by dispatch like this is an idiomatic design pattern in Julia.</p>
<p>Another common pattern is the use of parameters for restricting the applicability of a method to compatible argument types. The following method appends an element to a vector, but only if the element type of the vector and the type of the additional value match:</p>
<div id="3cc1280b" class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">append</span>(a<span class="op">::</span><span class="dt">Vector{T}</span>, x<span class="op">::</span><span class="dt">T</span>) <span class="kw">where</span> {T} <span class="op">=</span> [a<span class="op">...</span>, x]</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="fu">append</span>([<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>], <span class="fl">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<pre class=""><code class=" ansi">4-element Vector{Int64}:
 1
 2
 3
 4</code></pre>
</div>
</div>
<p>If the types do not match, a <code>MethodError</code> is raised as no compatible method has been defined:</p>
<div id="59a33b54" class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="fu">append</span>([<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>], <span class="fl">4.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching append(::Vector{Int64}, ::Float64)

Closest candidates are:
  append(::Vector{T}, <span class="ansi-red-intense-fg">::T</span>) where T
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[77]:1</span></code></pre>
</div>
</div>
<p>Parametric methods are a truly powerful paradigm, facilitating general code while at the same time guaranteeing correct behavior, e.g., by restricting arguments to compatible types and facilitating lean implementations of function behavior by dispatch.</p>
</section>
<section id="constructors" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="constructors"><span class="header-section-number">3.4</span> Constructors</h2>
<p>Now that we have learned the inners of functions and methods, it is time to discuss constructors in more detail. Constructors are functions that create new instances of composite types. They are invoked by applying the type name like a function. Being a function, the behavior of a constructor is defined by its method.</p>
<p>We mentioned in the previous chapter that two default constructors are provided for composite types. Both take as many arguments as the type has fields, but one requires the type of each argument to match the exact type of the corresponding field, while the other accepts arguments of any type and tries to convert the arguments to the correct field types. Of course, no conversion is required if no type restrictions are applied.</p>
<p>Often, these default constructors are all that is needed, but sometimes we need the constructor to do more than assign values to an object’s fields. Typical examples include verifying or enforcing specific properties of the field values, so-called <em>invariants</em>, e.g., the positivity of a float, convenience constructors that compute some or all of the field values on the fly, or the initialization of recursive data structures. In such cases, we need to implement custom constructors.</p>
<p>There are two types of constructors, outer and inner constructors, whose differences and different purposes we will discuss in the following. After that, we will elaborate on the specifics of parametric constructors and incomplete initialization.</p>
<section id="outer-constructor-methods" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="outer-constructor-methods"><span class="header-section-number">3.4.1</span> Outer constructor methods</h3>
<p>The purpose of outer constructors is primarily to add functionality for object creation, such as convenience methods that compute the values for a struct’s fields from some input parameters.</p>
<p>For example, consider a struct holding temporary arrays for a Newton solver that solves a nonlinear equation of the form <span class="math inline">y = f(x)</span> with <span class="math inline">x \in \mathbb{R}^n</span> and <span class="math inline">y \in \mathbb{R}^m</span>. The struct needs to store vectors for <code>x</code> and <code>y</code> and a matrix for the Jacobian <span class="math inline">j = df/dx</span> with <span class="math inline">j \in \mathbb{R}^m \times \mathbb{R}^n</span>:</p>
<div id="ffb54a26" class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> NewtonSolver{T}</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    x<span class="op">::</span><span class="dt">Vector{T}</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    y<span class="op">::</span><span class="dt">Vector{T}</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    j<span class="op">::</span><span class="dt">Matrix{T}</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The default constructors expect three arrays for <code>x</code>, <code>y</code>, and <code>j</code>. However, we typically want to initialize this structure by providing only vectors for <code>x</code> and <code>y</code>. There is no need to initialize <code>j</code> to specific values, and its size can be inferred from the sizes of <code>x</code> and <code>y</code>. To be able to construct a <code>NewtonSolver</code> just from <code>x</code> and <code>y</code>, we need to add a convenience constructor:</p>
<div id="f7f3d11b" class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">NewtonSolver</span>(x<span class="op">::</span><span class="dt">Vector{T}</span>, y<span class="op">::</span><span class="dt">Vector{T}</span>) <span class="kw">where</span> {T}</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">NewtonSolver</span>(<span class="fu">zero</span>(x), <span class="fu">zero</span>(y), <span class="fu">zero</span>(y <span class="op">*</span> x<span class="op">'</span>))</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">3</span>)</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">4</span>)</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="fu">NewtonSolver</span>(x, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="80">
<pre class=""><code class=" ansi">NewtonSolver{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])</code></pre>
</div>
</div>
<p>This method calls one of the default constructors with the three arrays it expects. Similarly, we could add a constructor that takes a datatype and the vector lengths <code>m</code> and <code>n</code> and creates all arrays from scratch:</p>
<div id="291b27ef" class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">NewtonSolver</span>(<span class="op">::</span><span class="dt">Type{T}</span>, n<span class="op">::</span><span class="dt">Int</span>, m<span class="op">::</span><span class="dt">Int</span>) <span class="kw">where</span> {T}</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fu">zeros</span>(T, n)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="fu">zeros</span>(T, m)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> <span class="fu">zeros</span>(T, m, n)</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">NewtonSolver</span>(x, y, j)</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a><span class="fu">NewtonSolver</span>(<span class="dt">Float64</span>, <span class="fl">3</span>, <span class="fl">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">
<pre class=""><code class=" ansi">NewtonSolver{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])</code></pre>
</div>
</div>
<p>We may also want to add an additional constructor that assumes <code>Float64</code> as the default data type:</p>
<div id="6c830df9" class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="fu">NewtonSolver</span>(n, m) <span class="op">=</span> <span class="fu">NewtonSolver</span>(<span class="dt">Float64</span>, n, m)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="fu">NewtonSolver</span>(<span class="fl">3</span>, <span class="fl">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="82">
<pre class=""><code class=" ansi">NewtonSolver{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])</code></pre>
</div>
</div>
<p>The above constructor methods are called outer constructors as they are defined outside a type definition like regular methods. They are limited in that they can only create a new instance by calling another inner constructor method, either the automatically provided or a custom one. Thus, they are also not suited to enforce invariants or to construct self-referential objects. To achieve these tasks, we need custom inner constructor methods.</p>
</section>
<section id="inner-constructor-methods" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="inner-constructor-methods"><span class="header-section-number">3.4.2</span> Inner constructor methods</h3>
<p>As the name suggests, inner constructor methods are defined within a type declaration. In contrast to outer constructors, they have access to a function called <code>new</code> that creates an instance of the respective type. If an inner constructor is defined, it is assumed that we want to override the default behavior, and therefore no default constructor method is provided.</p>
<p>Consider a simple example of a type that stores two values and expects one to be larger than the other. We can enforce this invariant by adding an appropriate <code>@assert</code> statement in a custom inner constructor:</p>
<div id="c6bab807" class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> GreaterThanFooBar</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    foo</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    bar</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">GreaterThanFooBar</span>(foo, bar)</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@assert</span> bar <span class="op">&gt;</span> foo</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">new</span>(foo, bar)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The name of the inner constructor has to match the type’s name. If we try to instantiate this type with incompatible arguments, an <code>AssertionError</code> is raised:</p>
<div id="c849efdb" class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="fu">GreaterThanFooBar</span>(<span class="fl">1.0</span>, <span class="fl">2.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="84">
<pre class=""><code class=" ansi">GreaterThanFooBar(1.0, 2.0)</code></pre>
</div>
</div>
<div id="94962dc3" class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">GreaterThanFooBar</span>(<span class="fl">2.0</span>, <span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class=""><code class=" ansi">LoadError: AssertionError: bar &gt; foo</code></pre>
</div>
</div>
<p>Note that invariants can only be enforced for immutable types, as the fields of mutable types can be altered at any time after instantiation.</p>
<p>We could also add assertions like the above into an outer constructor. However, that would not guarantee that they are indeed always satisfied, as we could directly call one of the default inner constructors unaware of these constraints. As only inner constructors can create an instance of an object, only therein can constraints be enforced.</p>
<p>The Julia coding guidelines suggest defining as few inner constructor methods as possible, namely those that explicitly take values for all fields, perform essential error checking, and enforce invariants. Convenience constructors that supply default values or compute initial data for the fields of a type should be implemented as outer constructors that call the inner constructors, which take care of consistency checks and instantiation.</p>
</section>
<section id="parametric-constructor-methods" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="parametric-constructor-methods"><span class="header-section-number">3.4.3</span> Parametric constructor methods</h3>
<p>Constructors for parametric composite types have a few twists. With the default constructors, type parameters can either be provided explicitly or inferred from the types of the arguments. Recall the <code>ParametricFooBar</code> type from the previous chapter:</p>
<div id="e4686dc5" class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ParametricFooBar{T}</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">::</span><span class="dt">T</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    bar<span class="op">::</span><span class="dt">T</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It can be instantiated with an explicit value for <code>T</code> or with an implied value:</p>
<div id="d1eb2dc6" class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ParametricFooBar</span><span class="dt">{Float64}</span>(<span class="fl">23</span>, <span class="fl">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="87">
<pre class=""><code class=" ansi">ParametricFooBar{Float64}(23.0, 42.0)</code></pre>
</div>
</div>
<div id="7610a905" class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ParametricFooBar</span>(<span class="fl">23</span>, <span class="fl">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="88">
<pre class=""><code class=" ansi">ParametricFooBar{Int64}(23, 42)</code></pre>
</div>
</div>
<p>In the first example, the arguments are converted to the provided type. In the second example, the type parameter is implied by the type of the arguments. For this to work, the types of both arguments must agree. Otherwise, the type parameter cannot be inferred:</p>
<div id="fbf39dc6" class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ParametricFooBar</span>(<span class="fl">23.0</span>, <span class="fl">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre class="ansi"><code class="ansi ansi">LoadError: MethodError: no method matching ParametricFooBar(::Float64, ::Int64)

Closest candidates are:
  ParametricFooBar(::T, <span class="ansi-red-intense-fg">::T</span>) where T
<span class="ansi-black-intense-fg">   @</span> <span class="ansi-magenta-fg">Main</span> <span class="ansi-black-intense-fg ansi-underline">In[86]:2</span></code></pre>
</div>
</div>
<p>For parametric types, Julia provides an inner default constructor, which expects the type parameters to be provided, as well as an outer default constructor, which infers the parameter and passes it on to the inner constructor. These default constructors are equivalent to the following explicit definitions:</p>
<div id="1958fb93" class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ParametricFooBar{T}</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">::</span><span class="dt">T</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    bar<span class="op">::</span><span class="dt">T</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ParametricFooBar</span><span class="dt">{T}</span>(foo, bar) <span class="kw">where</span> {T} <span class="op">=</span> <span class="fu">new</span>(foo, bar)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ParametricFooBar</span>(foo<span class="op">::</span><span class="dt">T</span>, bar<span class="op">::</span><span class="dt">T</span>) <span class="kw">where</span> {T} <span class="op">=</span> <span class="fu">ParametricFooBar</span><span class="dt">{T}</span>(foo, bar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that the outer constructor expects both arguments’ values to be of the same type.</p>
<p>The inner constructor <code>ParametricFooBar{T}</code> constitutes a different function for each value of <code>T</code>, just like the parametric type <code>ParametricFooBar{T}</code> constitutes a concrete type for each value of <code>T</code>. This is to say that, e.g., <code>ParametricFooBar{Float64}</code> and <code>ParametricFooBar{Float32}</code> are different constructor functions and not different methods of the same function. Each function, such as <code>ParametricFooBar{Float64}</code>, behaves like a non-parametric default inner constructor.</p>
<p>It is also possible to define inner constructors that infer the type parameters. Let us reconsider our <code>NewtonSolver</code> above. It would make sense to add an inner constructor that ensures that all arrays are of compatible size:</p>
<div id="addd303b" class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> NewtonSolverStrict{T}</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    x<span class="op">::</span><span class="dt">Vector{T}</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    y<span class="op">::</span><span class="dt">Vector{T}</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    j<span class="op">::</span><span class="dt">Matrix{T}</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">NewtonSolverStrict</span>(x<span class="op">::</span><span class="dt">Vector{T}</span>, y<span class="op">::</span><span class="dt">Vector{T}</span>, j<span class="op">::</span><span class="dt">Matrix{T}</span>) <span class="kw">where</span> {T}</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@assert</span> <span class="fu">axes</span>(j,<span class="fl">1</span>) <span class="op">==</span> <span class="fu">axes</span>(y,<span class="fl">1</span>)</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@assert</span> <span class="fu">axes</span>(j,<span class="fl">2</span>) <span class="op">==</span> <span class="fu">axes</span>(x,<span class="fl">1</span>)</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">new</span><span class="dt">{T}</span>(x, y, j)</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a><span class="fu">NewtonSolverStrict</span>(<span class="fu">zeros</span>(<span class="fl">3</span>), <span class="fu">zeros</span>(<span class="fl">4</span>), <span class="fu">zeros</span>(<span class="fl">4</span>,<span class="fl">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="90">
<pre class=""><code class=" ansi">NewtonSolverStrict{Float64}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])</code></pre>
</div>
</div>
<p>This constructor infers the type of the arrays and passes it on to <code>new</code> as a parameter. As this constructor prevents the generation of default constructors, the type parameter <code>T</code> cannot be set manually.</p>
</section>
<section id="incomplete-initialization" class="level3" data-number="3.4.4">
<h3 data-number="3.4.4" class="anchored" data-anchor-id="incomplete-initialization"><span class="header-section-number">3.4.4</span> Incomplete initialization</h3>
<p>There is one more point we touched upon but did not yet discuss in detail, namely the construction of self-referential objects, or more generally, recursive data structures.</p>
<p>Consider the following type that is supposed to store a reference to a value of itself:</p>
<div id="86afdcf4" class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MeMyselfAndI</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    ref<span class="op">::</span><span class="dt">MeMyselfAndI</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This definition may seem innocent but try to instantiate an object of this type. You will quickly realize that you are facing a chicken and egg problem: in order to call the constructor of this type, you need to provide a value of the same type, but where does that very first instance come from?</p>
<p>This problem can only be solved by making the type mutable and allowing for incomplete initialization so that we can create a <code>MeMyselfAndI</code> instance whose <code>ref</code> field does not refer to any value. The incomplete <code>MeMyselfAndI</code> instance can then be used to initialize another instance or set the reference to itself. We achieve this by calling the <code>new</code> function with fewer arguments than the number of fields in the type:</p>
<div id="da9a0db1" class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutable struct</span> MeMyselfAndI</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    ref<span class="op">::</span><span class="dt">MeMyselfAndI</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MeMyselfAndI</span>() <span class="op">=</span> (m <span class="op">=</span> <span class="fu">new</span>(); m.ref <span class="op">=</span> m)</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MeMyselfAndI</span>(m<span class="op">::</span><span class="dt">MeMyselfAndI</span>) <span class="op">=</span> <span class="fu">new</span>(m)</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first constructor creates an instance whose <code>ref</code> field is uninitialized, assigns a reference to itself, and returns the fully initialized object. The second constructor behaves like the default constructor, which was not provided automatically due to the definition of the first constructor. Let us do some quick experiments with this type:</p>
<div id="d54723a0" class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fu">MeMyselfAndI</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="92">
<pre class=""><code class=" ansi">MeMyselfAndI(MeMyselfAndI(#= circular reference @-1 =#))</code></pre>
</div>
</div>
<div id="3dd6c1a0" class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">===</span> m.ref <span class="op">===</span> m.ref.ref</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">
<pre class=""><code class=" ansi">true</code></pre>
</div>
</div>
<div id="2bf8c4cf" class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="fu">MeMyselfAndI</span>(m).ref <span class="op">===</span> m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="94">
<pre class=""><code class=" ansi">true</code></pre>
</div>
</div>
<p>We observe the expected behavior. Note Julia remarking that we have defined a circular reference.</p>
<p>Inner constructors can also return objects with uninitialized fields, although this is not encouraged. Accessing an uninitialized field results in an immediate error.</p>
</section>
</section>
<section id="generic-code-and-specialization" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="generic-code-and-specialization"><span class="header-section-number">3.5</span> Generic code and specialization</h2>
</section>
<section id="coding-guidelines" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="coding-guidelines"><span class="header-section-number">3.6</span> Coding guidelines</h2>
</section>
<section id="case-study-dispatch-on-empty-types" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="case-study-dispatch-on-empty-types"><span class="header-section-number">3.7</span> Case study: dispatch on empty types</h2>
</section>
<section id="summary" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="summary"><span class="header-section-number">3.8</span> Summary</h2>
<p>In this chapter, we learned the inner workings of functions and methods in Julia. We explored the concept of multiple dispatch and put it in perspective to single dispatch in traditional class-based object-oriented (CBOO) programming languages. We discussed why Julia is an object-oriented language although it is not class-based, even in a purer sense than many traditional object-oriented languages like C++ or Java.</p>
<p>We learned all the details of defining functions and methods with positional arguments, keyword arguments, arbitrary numbers of arguments, arguments with and without default values, and how to define parametric functions, anonymous functions, closures, and functors. In light of this new knowledge, we revisited constructors, in particular the differences between inner and outer constructors, and how to achieve intricate tasks like enforcing invariants or the construction of self-referential objects.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../content/type-system.html" class="pagination-link" aria-label="Julia's Type System">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Julia’s Type System</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../content/arrays.html" class="pagination-link" aria-label="Working with Arrays">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Working with Arrays</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>